= Leitfaden Schulung CMK-1
:revdate: draft

Dies ist der offizielle Leitfaden für das Durchführen der Schulung
CMK-1 „Systemmonitoring mit Checkmk - Teil 1“.


== Technik im Schulungsraum

Für jeden Schulungsteilnehmer haben wir einen eigenen Linuxrechner
(physikalisch oder virtuell) vorbereitet, mit folgenden Eigenschaften:

* Distribution Debian, Ubuntu, SLES, RedHat oder CentOS in einer jeweils aktuellen von Checkmk unterstützten Version.
* Die Installation erfolgt immer mit der *Defaultauswahl*! Das heißt, dass man sich beim Installieren der Distro quasi immer „durchklickt“. Zusätzliche Pakete sollen extra noch *nicht* installiert werden.
* Die Teilnehmerrechner haben einen Login als normaler Nutzer.
* Die Teilnehmer haben Zugriff auf den `root`-Benutzer.
* Die Rechner haben Zugriff zum Internet.
* Die Paketquellen sind so eingerichtet, dass die TN Pakete per `zypper`, `yum` bzw. `apt` nachinstallieren können.
* Jeder Teilnehmer hat Zugriff auf eine VM mit einer aktuellen Windows-Version in einer Grundinstallation.

Ferner gibt es Zugriff auf ein SNMP-Gerät, das die TN später überwachen
können. Dabei soll es uns möglich sein, mit dem Managementinterface des
Switches zu arbeiten und z.B. die Beschreibungen der Switchports zu editieren,
damit wir später zeigen können, wie man diese für die Discovery und Regeln
verwenden kann. Empfehlung: z.B. managebare lüfterlose Switche von TP-Link
(Modell ... kostet z.B. ca 100,-).

Wenn wir wollen, können wir zusätlich noch weitere Geräte oder einen
SNMP-Simulator einsetzen.

== Tag 1

=== Einleitung und Vorgeplänkel

==== Vorstellung Teilnehmer und Dozent

Die Teilnehmer und der Dozent stellen sich vor. Alle tragen sich in die
Teilnehmerliste ein bzw. unterschreiben den Eintrag, der schon für sie
vorbereitet ist.

==== Vorstellung der Firma tribe29

Wir stellen kurz die Firma tribe29 vor. Gründung war durch Mathias Kettner im
Jahr 2007 in München. 2008 Wurde die erste Version von Checkmk veröffentlicht
-- damals noch als Addon zu Nagios.

2019 wurde die Firma von „Mathias Kettner Gmbh“ in „tribe29 GmbH“
umbenannt. Die Firma hat heute ca. 40 Mitarbeiter und mehr als 2000
Kunden, die eine Subskription von Checkmk haben.

image::bilder/tribe29_logo.png[align=center,width=30%]

==== Vorstellung von Checkmk -- Theorieteil

Wir beginnen mit einem theoretischen Teil zu Checkmk. Dieser dauert ca.
30-45 Minuten. Zunächst eine generelle Vorstellung von Checkmk. Was ist es? Was kann es?
Wir machen eine allgemeine Vorstellung, welche Probleme Checkmk löst bzw. welche Features
es hat anhand der Informationen auf der <a href="https://checkmk.de/features.html">Webseite</a>.

Dabei zeigen wir, was die Vorteile sind:

* Security: z.B. ist der Agent read-only
* Leistung, Performance, Skalierbarkeit
* leichtgewichtige Agenten!
* Handlebarkeit durch Bakery und Deployment
* Leichte Erweiterbarkeit des Agenten durch den Anwender selbst
* Vielfalt der überwachbaren Systeme
* Automatische Discovery
* Preis
* Deutscher Support (wir machen für uns selbst Werbung)

Danach zeigen wir das Bild mit der Checkmk-Architektur. Daran zeigen wir
z.B:

* Die Trennung von GUI zum Monitoringkern
* Wo die Alarmierungen ausgelöst werden
* Die Agentenkommunikation
* Wie die Event Console integriert ist


=== Wir installieren Checkmk

==== Editionen

Wir erklären die verschiedenen [intro#editions|Editionen]. Welche Edition
ist für welchen Fall die richtige. Dabei zeigen wir auch die Tabelle
auf der Webseite unter <a href="https://checkmk.de/editions.html">Editions</a>.

Die Schulung selbst führen wir mit der (CEE) durch (bei der (CFE) würde
die Anzahl der Hosts nicht genügen bzw. während der Schulung nerven). Bei
Features, die es in der (RE) nicht gibt, weisen wir immer auf diese Tatsache
hin!

Jetzt zeigen wir den TN noch, dass es die Appliances (rack1, rack4, virt1) gibt
und welche Vorteile diese hat:

* Einfache Administration (ohne Linuxkenntnisse)
* Hochverfügbarkeit
* Einfache Updates des Betriebssystems
* Vorteile beim Support (Hardwareausfall, Austausch ohne Restore der Daten)
* Politische Vorteile, wenn man auf Linux-Server eigentlich keinen Rootzugang hätte (andere Abteilung)

*Vorführen* tun wir die Appliance im offiziellen Teil des Kurses nicht.
Wenn TN Interesse haben, können wir das am Rande (z.B. Freitag-Nachmittag)
einschieben.

Wir teilen den TN jetzt die Passworte für ihren Rechner mit.


==== Runterladen von Checkmk

*Achtung*: Wir arbeiten mit der *vorletzten* stabilen Version von
(CMK), damit wir am letzten Tag auf die letzte stabile Version updaten können.

Entweder stellen wir den TN das Checkmk-Softwarepaket in irgendeinem Verzeichnis bereit
oder wir laden es gemeinsam von der HP von Checkmk runter (falls ein Account für die
Schulung besteht).


==== Installation von Checkmk

Bevor es losgeht, erklären wir den TN, dass Checkmk mehrere Versionen und
auch mehrere Instanzen gleichzeitig auf einem Server haben kann. Und
den Nutzen davon.

Jetzt installieren wir gemäß der [install_packages|Anleitung im Handbuch].
Jeder TN erzeugt eine Instanz, die seinen Vornamen in Kleinbuchstaben trägt.
Wir weisen darauf hin, dass im Handbuch alle Beispiele den Namen `mysite`
verwenden.

Dann ändern wird das Passwort von `cmkadmin` auf ein für alle bekanntes
und einheitliches Passwort.

Jetzt zeigen wir, wie man sich mit `omd su` als Instanzbenutzer einloggt.
Auf der Kommandozeile zeigen wir weitere Dinge:

* `omd version` und `omd versions`
* Starten und Stoppen von Instanzen
* Anzeigen von Instanzstatus
* Grober Überblick über die Verzeichnisstruktur: Erklären, dass der Instanzbenutzer ein eigenens Verzeichnis hat und wo das liegt. Wir erklären nur die vier Toplevelverzeichnisse `etc`, `tmp`, `var` und `local`. Dann erklären wir noch kurz das Prinzip der symbolischen Links auf das Versionsverzeichnis. Einzelheiten lassen wir aus: die kommen in Teil 2 dran!

Zum Verzeichnis `local` sagen wird:

* Dieses Verzeichnis ist (ausschließlich) für eigene Modifitionen an Checkmk, welche ein Versions-Update überlegen sollen.
* Achtung: Beim verteilten WATO werden diese Dateien (per Defaults) auf alle Sites übertragen.
* Die Verzeichnisse im `local` sind „magisch“.

Nun loggen wir uns auf der Instanz als `cmkadmin` ein. Wir helfen den Teilnehmern,
dass das bei allen funktioniert.

*Wichtig:* Wir zeigen den TN auch was passiert (welche Fehlermeldungen
der Browser zeigt), wenn

* die Instanz nicht gestartet ist
* die Instanz nicht existiert (oder man sich vertippt hat)

==== Überblick über die GUI

Wir zeigen den TN jetzt einen Überblick über die GUI von Checkmk:

* Wie kann man die Seitenleiste bedienen (Scrollen, Klappen, Snapins weg- und wieder hinmachen)
* Wie kann man sich ausloggen
* Wie kann man die Sprache auf Deutsch ändern (und welche Konsequenzen hat das, z.B. Regelsuche)
* Und vor allem: wie kann man das coole *Dark Theme* einschalten!

*Achtung 1*: Die Schulung wird immer mit der englischen GUI durchgeführt!

*Achtung 2*: Im Moment zeigen wir nicht viel mehr. Wir erklären
z.B. keine Einzelheiten zu den Feldern der [.guihints]#Tactical Overview}},# weil wir
ja noch keine Hosts und Services haben.


=== Hosts aufnehmen

==== Hosts, Services, Agents

Bevor wir loslegen, erklären wir den TN die Begriffe _Host_ und _Service_.
Dabei nennen wir auch Beispiele, wo ein Host nicht ein echter Server ist, sondern
z.B. eine VM oder sogar ein AWS-Objekt.

Dazu zeigen wir auch die Basiszustände (OK), (WARN), (CRIT), (UNKNOWN),
(UP), (DOWN), (UNREACH) und (PENDING). Wobei wir das mit den Parents erst
später machen.

Dann erklären wir, dass man für die Überwachung von Linux, Windows etc. den
(CMK)-Agent braucht und welche Vorteile das Monitoring mit eigenen Agenten hat.

* Keine externen Befehle (Sicherheit)
* Einfache Erweiterbarkeit durch den Admin selbst
* Man hat den Agenten selbst unter Kontrolle und kann ihn selbst fixen (was bei WMI z.B. schwierig ist)

Wir erwähnen auch kurz SNMP, welches ja keinen Checkmk-Agenten braucht,
weil bei SNMP ja schon ein Agenten auf dem Gerät installiert ist.

Ferner erwähnen wir, dass es Geräte mit APIs gibt, wo Checkmk diese API
direkt abfrage mithilfe von sogenannten „Spezialagenten“ (vSphere, Clouddienste, Storage)

==== Ordner

Wir erklären den TN, dass Checkmk die Hosts in Ordnern verwaltet. Dann
diskutieren wir verschiedene Strukturierungsmöglichkeiten, insbesondere
die nach Standort, Technologie oder Organisation. Wir erwähnen das Prinzip,
dass man über die Ordner Eigenschaften vererben kann, ohne jetzt schon auf
Details einzugehen.

Wir geben für die Schulung folgende Ordnerstruktur verbindlich vor, welche
die TN später dann einrichten sollen:

Oberste Ebene: Standort. München und Berlin

Unter dem Standort München legen wir weitere Unterordner an:

* Zweite Ebene: Technologie: Ordner: Windows, Linux, Infrastructure
* Dritte Ebene unter Windows und Linux: Hier direkt die Hosts anlegen
* Dritte Ebene unter Infrastructure: Router, Switches, Storage, Printers

Die erste Übung der TN ist, diese Ordner alle anzulegen

Jetzt zeigen wir, den TN das WATO-Snapin und sagen ein paar Worte, zu WATO im
allgemeinen.  Dann legen wir einige Ordner an und TN machen das gleiche. Jeder
entscheidet selbst, welche Ordner er in der Schulung anlegen will.

==== Der erste Host

Jetzt installieren wir den Checkmk-Agent für Linux auf dem Checkmk-Server selbst
gemäß der Anleitung im [intro#linux|Leitfaden für Einsteiger].
Wir zeigen den TN auch, wo auf Linux die entsprechenden Verzeichnisse
des Agenten sind.

Wir zeigen den TN auch verschiedene Diagnosemöglichkeiten:

* Diagnoseseite in WATO selbst
* telnet auf Port 6556 (zeigt auch das Security-Level)
* Agent von Hand aufrufen mit `check_mk_agent`

Wir werfen auch einen Blick in den Quellcode vom Linux-Agenten und zeigen
etwas dessen Aufbau. Aber nur kurz.

Jetzt nehmen wir den Host im WATO auf. Dabei gehen wir auch auf das Thema
DNS versus statischer IP-Adresse ein.

* Wenn DNS, dann Lookup bei Activate Changes und nur einmal pro Tag (DNS-Cache erklären, und wie ich den löschen kann)
* Empfehlung: Über Namensschema vorher nachdenken
* Empfehlung: Einheitliche Schreibung was Groß-/Kleinschreibung betrifft festlegen!
* Achtung: Ändern von Namen später schwierig, weil diese Schlüssel zu allen Datenbanken ist.

Das mit den Plugins zeigen wir jetzt noch nicht, sondern später bei
der HW/SW-Inventur.

==== Services aufnehmen

Jetzt gehen wir zur Serviceseite und nehmen die Services alle ins Monitoring
auf. Wir besprechen hier noch nicht das Prinzip von [.guihints]#Disabled Services# oder
ähnlichem.

Wir empfehlen den TN *nicht*, dass sie von Hand entscheiden, welche der
Services sie überwachen wollen. Das machen wir später lieber vernünftig mit
den [.guihints]#Disabled Services}}.# 

Danach machen wir [.guihints]#Activate Changes# und erklären, wie das funktioniert --
das ganze Prinzip von WATO versus Statuswelt.

Wir fordern die TN auf, dass sie jetzt weitere Hosts aufnehmen, indem sie
sich gegenseitig überwachen. Dabei zeigen wir die Funktion „Bulk-Import“ in WATO.


=== Überwachen von Windows

Jetzt stellen wir den Windows-Agenten vor und nehmen mit den Teilnehmern
einen Windows-Host in die Überwachung auf. Dazu hat jeder TN Zugriff
auf einen eigenen Windowsrechner (virtuell oder echt) mit einem frisch
installierten Windows.

* Wir zeigen, wie man den Agenten installiert.
* Wir zeigen, wo die Verzeichnisse auf dem Agenten sind.
* Wir nehmen den Host und seine Services in Checkmk auf.
* Wir zeigen die Diagnosemöglicheiten (z.B. Agenten ohne Dienst direkt aufrufen)

Auf weitere Einzelheiten des Agenten gehen wir hier noch nicht ein.
Insbesondere das mit den Plugins zeigen wir jetzt noch nicht, sondern später
bei der HW/SW-Inventur.


=== Überwachen via SNMP

Wir erklären, was SNMP ist. Was es mit v1, v2c und v3 auf sich hat.
Kurz erwähnen, dass es Traps gibt und das nicht das ist, was wir
jetzt brauchen.

* Unterschiede zwischen v1 und v2c (64-Bit Counter)
* v3 braucht man für Security
* Was eine Community ist. Dass man SNMP auf seinen Geräten freischalten muss.

Die Schulung selbst machen wir mit v2c.

Nun nehmen wir einen Host mit SNMP in das Monitoring auf.
Wir zeigen dabei auch wieder die Diagnoseseite von WATO.


== Tag 2

=== Anpassen/Erweitern des Checkmk Agenten

Der Agent laesst sich bekanntlich durch Plugins erweitern, das haben wir den TN gegenüber am ersten Tag bereits erwähnt.
Heute zeigen wir den Teilnehmern:

* Erweiterung durch eigene Localchecks
* Erweiterung durch MRPE Checks
* Paketieren von angepassten Agenten über die Agentenbäckerei
* Automatische Agenten-Updates

==== Localchecks

* Was genau sind Local Checks und wofür kann ich die nutzen?
* Was müssen diese Checks ausgeben (nur Zeilen, die komplette Ergebnisse liefern) und in welcher Syntax?
* Wofür kann ich den Status "P" verwenden und was benötige ich dazu noch (Metriken mit WARN/CRIT-Schwellwerten)
* Wir geben einen Hinweis auf Werk #10566, welches ab der 1.7 auch Leerzeichen im Servicenamen zulässt.

==== MRPE Checks

* Was genau macht MRPE (z.B. Nagios Plugins von remote Hosts aus ausführen)?
* Wie kann ich MRPE konfigurieren?

==== Agentenbäckerei

Zunächst teilen wir den TN mit, daß es die Bäckerei nur in der CEE (Free/Standard/Manages Services) gibt.

Wir zeigen den TN, wie sie angepasste Agenten über die Bäckerei konfigurieren können:

* Einbinden/-backen von mitgelieferten Agent Plugins
* Einbindung von Localchecks/MRPE in der Agentenbäckerei ({{Deploy custom files with agent}}/{{Execute# MRPE checks}})# 

Abschließend behandeln wir die Möglichkeit automatischer Agenten-Updates, und wir richten diese zusammen mit den TN ein:

* Welche Sicherheitsfeatures werden bzgl. automatischer Updates genutzt (die Kommunikationswege muessen {vorher} bekannt sein/konfiguriert werden, bei HTTPS müssen alle unterschreibenden Zertifikate mit konfiguriert werden (keine Nutzung von im OS vorhandenen Zertifikaten), etc.)?
* Notwendige Schritte, wie in der Bäckerei vorgegeben. Jeder TN registriert dabei seinen eigenen Schulungsrechner an seiner eigenen Site.
* Schlußendlich geben wir den TN noch wichtige Hinweise:
Kein weiteres manuelles Zutun notwendig.
Darauf achten, dass Hosts im AutoUpdate niemals Agents ohne Updater-Plugin angeboten bekommen, ansonsten ist das das letzte AutoUpdate gewesen! ;-)
Beim Wechsel des Checkmk-Server-Zertifikats (bzw. der unterschreibenden Zertifikate) {vor dem Wechsel} die neuen CAs im AgentUpdater-Plugin konfigurieren und warten, bis alle Agenten aktualisiert sind, damit das neue Zertifikat später verifiziert werden kann!
Soll der Agenten-Signatur-Key gewechselt werden, dann prinzipiell genau so vorgehen, wie beim Zertifikatswechsel: neuen Key erstellen, diesen als gültig im Updater-Plugin definieren, die Agenten {mit dem bisherigen Key} signieren, nachdem alle Agenten eine Aktualisierung installiert haben kann der neue Key dann zum signieren genutzt und der bisherige ggf. entfernt werden.
AutoUpdates können aktuell (noch) nur gegen die Mastersite gemacht werden. Eine Feature-Erweiterung, sodaß dies auch gegen Slavesites funktioniert, ist in Arbeit/Test und für 1.7 vorgesehen.

=== Die grafische Oberfläche

Jetzt da wir etliche Hosts im Monitoring haben, können wir uns mit der
Status-Oberfläche befassen. Wir zeigen:

* Die Tactical Overview, was die Zahlen bedeuten, dass man sie anklicken kann
* Das [.guihints]#Views}}-Snapin.# Welches Views gibt es? Wie sind diese untereinander verlinkt? Auch die Views mit der History!
* Das Hauptdashboard, wie man dorthin kommt.
* Wie die Lesezeichen funktioneren
* Die Quicksearch mit einigen ihrer Tricks (wie z.B. `h:` und `s:`)
* Master Control und was die ganzen Schalter bedeuten

Nun zeigen wir noch, wie man die Sidebar anpassen kann und sich ein paar
coole Snapins hinzufügen kann. Dazu zeigen wir als Beispiele:

* WATO-Quickaccess
* Host Matrix
* Folders: Dieses Snapin modifiziert ja den Scope von auf der rechten Seite gezeigten Views und Dashboard. Das zeigen und erklären wir.
* Server Performance bzw. Microcore Statistics

Wir zeigen, wie man die Sidebar einklappen kann durch einen Klick ganz links
am Rand. Wir zeigen auch, wie man durch Klick auf die Icons am Ende einer
View eine View ganz ohne Sidebar bekommt -- bzw. wieder zu der Ansicht mit
Sidebar zurückkommt.

=== Views anpassen

Wir befassen uns jetzt genauer mit den Views. Wir zeigen, wie man diese
anpassen kann. Zunächst die Dinge, die man direkt in der View selbst erreicht:

* Die Refreshzeit
* Die Anzahl der Spalten
* Die Sortierung nach einzelnen Spalten

Jetzt zeigen wir, wie man sich eine View anpassen kann, indem man Spalten
hinzufügt oder entfernt, die Gruppierung ändert, etc. Als Beispiel
zeigen wir, wie man in der View [.guihints]#All Hosts# eine Spalte mit der IP-Adresse
und die Kontaktgruppen des Hosts hinzufügen kann.

Zweites Beispiel: in der View [.guihints]#Service Search# die lästige Gruppierung
nach Hostnamen permanent entfernen und anstelle dessen den Hostnamen
als Spalte hinzufügen.

Drittes Beispiel: für fügen der View [.guihints]#All hosts# eine Service-Spalte
hinzu. Dazu nehmen wir das [.guihints]#Perf-O-Meter# des Services Checkmk
den Titel [.guihints]#Agent}}.# Jetzt sieht man bei jedem Host, wie schnell (und ob)
der Agent abgerufen werden kann.

Wir zeigen auch, wie man es so einstellen kann, das Views auch für
anderen Benutzer sichtbar sind, bzw. wie das mit der Sichtbarkeit
von Views generell funktioniert.

Auch zeigen wir, dass man für globale Views am besten einen eigenen
Benutzer anlegt, der dafür gedacht ist. Z.B. ein Benutzer, der so
berechtigt ist, dass er nur Views anpassen kann.


=== Dashboards

Das erzeugen von eigenen Dashboards in Checkmk ist mächtig, aber nicht einfach
selbst zu lernen. Daher zeigen wir den TN jetzt, wie sie ein eigenes Dashoard
anlegen können, auf dem eigene Views und Metrikgrafen sind.  Wir erklären:

* Dass Checkmk Dashboards mit einem dynamischen Layout unterstützt und begeistern unsere TN dafür.
* Die drei Größenarten fix (weiß), gelber Pfeil und roter Pfeil.
* Wie das mit dem Verankern in den vier Ecken funktioniert
* Wie man direkt bei einer View oder einem Graphen diesen dem DB hinzufügt (und dass sie dadurch als eigenständige Objekte kopiert werden)
* Wie man die hinzugefügten Views editieren und anpassen kann


=== Aktive Checks

Jetzt zeigen wir, wir man aktive Checks einrichten kann, z.B. HTTP oder TCP. Dazu brauchen
wir natürlich Regeln. Diese erklären wir aber noch nicht, sondern beschränken uns auf
explizite Hosts als Bedingung.


=== Das Metriksystem

Als weiteren Teil der GUI stellen wir das Metriksystem vor. Das sind nicht
nur die Graphen, sondern z.B. auch die Tabelle der Messwerte bei einem
Service. Zunächst erklären wir, wie die Messwertaufzeichnung grundsätzlich funktioniert.
Jetzt zur Bedienung:

* Wie komme ich zu den Graphen
* Welche interaktiven Möglichkeiten gibt es (horizontaler Zoom, vertikaler Zoom, verschieben des Zeitbereichs, Klick auf die Vorschauen als Zeitauswahl, Größe der Leinwand ändern)
* Setzen der Nadel -- Korrelation mit anderen Graphen
* Die Graph-Collections und dort auch den Knopf [.guihints]#Export as PDF}}.# Dabei weisen wir darauf hin, dass die vertikale Skalierung in allen Graphen unterschiedlich (und damit schwer vergleichbar) ist.
* Die Combined Graphs

*Achtung:* Die Customgraphen zeigen wir *nicht*. Die werden in CMK-2
behandelt. Das gleiche gilt für das Tuning der RRDs (Aggregationsweise anpassen).

Am Ende des Metrikthemas zeigen wir, wie das Aufzeichnen der Daten
funktioniert.  Und die Zusammenfassung über vier Stufen, wobei jeweils min,
max und average berechnet wird. Die Speicherung in Spezialdatenbanken (RRD).

== Tag 3

=== Das Operating

Jetzt befassen wir uns mit etlichen Themen des Operatings. Der erste Schritt
ist das Verständis für die ganzen verschiedenen Zustände:

* Wiederholung: Die Basiszustände (OK), (WARN), (CRIT), (UNKNOWN), (UP), (DOWN), (UNREACH) und (PENDING). Wobei wir das mit den Parents erst später machen.
* Der Zustand [.guihints]#stale}}:# Was bedeutet das? Wie kann es dazu kommen? Z.B. nicht erreichbarer Agent, Checks die voneinander abhängen (wie z.B. die ORACLE-Checks), Timeouts oder Fehler von Agent plugins. Etc.
* Zustand „on down host“: Wie werden Service gezählt / behandelt, die auf einem Host sind, der (DOWN) ist? Im Bezug auf die [.guihints]#Tactical Overview# und das Dashboard
* Was ist (PEND) und wie kommt es dazu? Erklären auch, warum manchen Checks zwei Runden brauchen (Counter)
* Was ist [.guihints]#flapping# (unstetig)? Wie kommt es dazu? Was hat das für Folgen? Und wie kann man das konfigurieren (z.B. ausschalten)

Jetzt besprechen wir *Acknowledgments*. Erstmal besprechen wir generell
wie man bei Views Kommandos auslösen kann. Einmal ohne Checkboxen, dann mit
den Checkboxen. Dann besprechen wir die Acknowledgments:

* Was haben die für Auswirkungen? Tactical Overview, Problem view, Alarme, etc.
* Was gibt es für Optionen (z.B. sticky und Ablaufzeit, persistent comment)
* Wie kann ich die entfernen?
* Wie kann ich in der GUI sehen, was quittiert ist?

Als nächstes kommen die *Scheduled Downtimes*. Erstmal vorweg: der
korrekte Begriff auf Englisch heißt *Scheduled Downtime* und nicht
einfach nur Downtime, denn letzteres ist _jeder_ Ausfall eines Systems,
egal ob geplant oder nicht! Auf Deutsch ist _Wartungszeit_ der korrekte
Begriff.

Wir erklären den Sinn von DT:

* Generell Kommunikation mit Kollegen, damit diese Bescheid wissen
* Verhinderung von Alarmierungen
* Ausblenden von nicht-(OK) Status von Problemen, da diese aktuell nicht relevant sind
* Korrekte Berechnung von Verfügbarkeiten
* Wartungszeiten sind dafür da, dass man sie *vorher* setzt.

Hinweis: Wenn man eine DT dazu verwendet, um ein Problem zu „quittieren“, verhindert das,
das man eine (OK)-Meldung bekommt, wenn dieser wieder (OK) ist!

Dann besprechen wir Details:

* Warum man sinnvolle Kommentare geben soll?
* Wo kann ich eine Liste der aktuellen Wartungszeiten sehen (global oder für ein Objekt)?
* Wie kann man Wartungszeiten löschen?
* Die Thematik: muss ich für Services auch Wartungszeiten setzen, wenn der Host in Wartung ist? Inklusive der Checkbox: Schedule downtimes on the affected hosts instead of on the individual services.

Und dann noch die [.guihints]#recurring downtimes# (nur (EE)): Wie kann ich diese setzen
und entfernen über die Kommandos? Dann sagen wir, dass es aber viel sinnvoller ist,
diese über Regeln zu machen, weil sie dann auch für Hosts funktionieren, die erst
später in das Monitoring aufgenommen werden.

=== Regelbasierte Konfiguration

==== Regelbasierte Konfiguration allgemein

Danach holen wir etwas weiter aus und zeigen die regelbasierte Konfiguration.
Dazu erstmal die Theorie. Dazu gehört auch die verschiedene „Matchtype“, als
da wären first, dict, list.
Wir erklären den Vorteil gegenüber Tabellen und templatebasierten Systemen.

Als Beispiel nehmen wir die Regel für die [.guihints]#CPU Load# von Linux.

Dann legen wir mit den TN zusammen Regeln für CPU load an. Wir zeigen
den TN:

* Wie sie die richtigen Regelketten auf verschiedenen Wegen finden können (z.B. Regelsuche, Weg über einen bestimmten Service, Link von der Hostseite im WATO, etc.)
* Wir zeigen, wie sie eine Diagnose einer Regelkette machen können (grüne und graue Kugeln im WATO)
* Wir zeigen, wann welche Regel Vorrang hat.
* Wir zeigen, dass auch mehrere Regeln gemeinsam gelten können, wenn jede Regel nur einen Parameter (Checkbox) festlegt.
* Wir zeigen den TN, wo steht, wie das Matching dieser speziellen Regelkette genau funktioniert.

Dann erklären wir, wie die ganzen Bedingungen funktionieren:

* Regeln die nur für besimmte Ordner gelten.
* Regeln nur für bestimmte Hosts oder Services (das mit den Regexen genau zeigen)
* Bedingungen über Hosttags, wobei wir erstmal nur mit den vordefinierten Taggruppen arbeiten.
* Das mit den Labels erwähnen wir nur und zeigen es später.

Dann zeigen wir noch die neuen „Predefined Conditions“.


==== Hosttags

Jetzt erklären wir, wie man eigene Taggruppen anlegen kann. Dass man
bestehende nicht anfassen soll. Das mit den Auxiliary tags erklären wir
nicht näher.

Die TN sollen jetzt eigene Taggruppen definieren und das ganze üben.

Servicetags erwähnen wir hier nicht.


==== Labels

Jetzt zeigen wir die Labels für Host und Services. Es gibt drei Arten:
automatische, manuelle und welche, die per Regel erzeugt werden.


=== Tuning des Monitorings

==== Motivation

Das nächste große Ziel ist, dass wir das Monitoring sauber bekommen,
also fehlerhafte Zustände (Fehlalarme) vermeiden. Wir geben den TN
mit auf den Weg, dass sie erst für Qualität und dann für Quantität sorgen
sollen. Also erst wenige Hosts aufnehmen, sorgen dafür, dass alles (OK)
wird und bleibt (bis auf die Dinge, die wirklich Probleme haben) und
erst danach Kollegen einbinden bzw. das Ganze ausweiten. Siehe dazu
auch die Motivation im [intro#finetuning].

==== Dateisysteme

Wir gehen nochmal zurück zum Regelsatz für Dateisysteme und schauen
uns weitere Möglichkeiten an, wie man intelligent Regeln aufstellen kann:

* Wir zeigen den Magic-Faktor und erklären auch die Referenzplattengröße


==== Hosts, die DOWN gehen dürfen

Beispiel sind Drucker, die nachts abgeschaltet werden. Wir zeigen praktisch,
wie man so ein Gerät trotzdem sinnvoll überwachen kann, ohne dass Fehlalarme
beim Ausschalten kommen.


==== Switchports

Wie im Einsteigerhandbuch zeigen wir, wie man Switchports sinnvoll überwachen kann.

* Überwachung von Core- und Distributionswitchen: jeder genutzte Port wird überwacht
* Accesswitche: Entweder nur die Uplinks überwachen oder alle Ports, dann aber den Linkstatus DOWN als (OK) werten.
* Wir zeigen, wie man mithilfe von Aliassen, die man im Switch konfiguriert, das Monitoring intelligent konfigurieren (Discovery, Schwellwerte)

==== Hosts, die rebooten

Regelmäßige Reboots abfedern durch Recurring Scheduled Downtimes wie im
Einsteigerhandbuch beschreiben.

==== Logwatch bei Windows

Das hier fehlt noch im Einsteigerhandbuch. Wir erklären den TN, welche Optionen sie
haben, damit Logwatch der Eventlogs von Windows nicht soviele Fehlalarme produziert.

. Alle Logmeldungen auf dem Checkmk-Server als "ignore" reklassifieren (und Positivliste auf dem Checkmk-Server pflegen)
. Die Services aus dem Monitoring entfernen
. Die Meldungen in die [ec|Event Console] weiterleiten. Das erwähnen wir aber nur, weil die EC erst im Kurs Teil 2 vorkommt.


==== Mittelwerte

Etliche Check-Plugins haben eine Option, dass Schwellwerte nicht auf den letzen
Minutenwert sondern auf einen Mittelwert von z.B. 15 Minuten angewandt werden
(z.B. CPU-Auslastung). Damit kann man sporadische Fehlalarme verringern.

==== Predictive Monitoring

Das zeigen wir auch.

==== Timespecific Parameters

Auch diese sind eine Methode, um präsizer zu Monitoring / zu bewerten. z.B.
weil zwischen 22:00 und 22:30 die CPU-Auslastung wegen eines Jobs hochgehen kann.
Wir zeigen auch, warum das besser ist, als in der Zeit gar nicht zu monitoren.


==== Sporadische Fehler

Wenn alles nicht hilft, kann man mit dem [.guihints]#Max Check Attempts# einen Alarm
verhindern. Dabei erklären wir dann auch den Unterschied zwischen Soft-
und Hardstates. Wichtigster Einsatzgebiet ist das vermeiden von Alarmierungen.

==== Parents

Wir führen das Konzept der Parents ein, mit denen man einen Netzwerktopologie
aus Sicht von Checkmk definiert. Die Parents sind überhaupt Voraussetzung, damit
ein Host (UNREACH) werden kann.

* Welchen Zweck haben die Parents (z.B. Mehrfahralarme vermeiden)
* Wir konfigurieren Parents, auch unter Verwendung von Folder-Vererbung
* Wir zeigen, dass ein Host mehrere Parents haben kann
* Wir zeigen die Netzwerkkarte aus den Dashboards jetzt nochmal

Wir sprechen kurz das Feature mit dem Parentscan an, und dass dieser
nur auf Layer 3 funktioniert.


==== Prozesse und Services

Wir zeigen wie man Prozesse (Windows und Linux) und Services (Windows)
überwacht.  Dazu zeigen wir zuerst die manuellen Checks. Als Beispiel
nehmen wir den Fall, dass auf jedem Windowsrechner ein Virenscanner laufen
soll. Und dann zeigen wir, wie man eine Discovery-Regel einrichtet, so dass
die Services automatisch angelegt werden.

Bei Windows besprechen verschiedene Methoden, mit dem Services-Check umzugehen,
wie im Einsteigerhandbuch beschrieben.


== Tag 4

=== Fortgeschrittene Serviceverwaltung

==== Services dauerhaft ignorieren

Wir erklären den TN zunächst, dass ein Service in Checkmk verschiedene
Konfigurationszustände haben kann:

* Wird normal überwacht
* Ist vorhanden, wird aber aktuell nicht überwacht (undecided)
* Ist vorhanden, wird aber permanent nicht überwacht (disabled)
* Wird überwacht, ist aber nicht vorhanden (missing)
* Ist statisch konfiguriert ({{Manual Checks}})# 

Jetzt zeigen wir, wie man einen Service zwischen den ersten drei Zuständen
hin- und herbewegen kann. Wir zeigen vor allem auch, dass ein Klick auf
das Icon [.guihints]#Move to disabled services# in Wirklichkeit eine Regel pro Host
anlegt bzw. modifiziert. Wir zeigen, wie man diese Regel durch Entfernen
des expliziten Hosts verallgemeiner kann.

Dann zeigen wir noch den alternativen Regelsatz [.guihints]#Disabled checks}},# mit
dem man ganze Checktypen ausschalten kann. Gerade bei SNMP-Geräten kann das
sinnvoll sein.

Wir weisen nochmal darauf hin, dass es in realen Monitoring nicht gut
ist, wenn Services länger auf [.guihints]#undecided# stehen.


==== Discovery check

Wir zeigen den Discovery check. Wir zeigen auch, wie man den so einrichten
kann, dass er Services automatisch hinzufügt. Wir diskutieren mit den
TN, in welchen Fällen das Sinn macht. Wir erklären, wie das dann mit dem
automatischen Aktivieren der Änderungen funktioniert und welche Auswirkungen
das hat.


==== Bulk discovery

Wir zeigen im WATO die Bulk Discovery mit den verschiedenen Optionen.


=== Benutzer und Rechte

Wir führen Benutzer, Rollen und Rechte so ein wie im Einsteigerhandbuch
beschrieben. Über die Dinge im Einsteigerhandbuch hinaus zeigen wir:

* Wie man eigene Rollen anlegen kann
* Die Rollen- und Rechtematrix

Dann zeigen wir außerdem, wie man als normaler nicht-Admin-User in WATO Hosts
pflegen kann. Dazu muss der Admin Ordner anlegen und bestimmte Kontaktgruppen
in den Permission eintragen.

Wir zeigen, wie die verschiedenen Checkboxen für die Vererbung der
Kontaktgruppen in den Ordnern funktionieren und zeigen dabei auch die
Unterschiede zwischen Sichtbarkeit in der Status-GUI und der Erlaubnis Hosts
in einem Ordner in WATO zu bearbeiten.

Die LDAP-Anbindung zeigen wir hier nicht. Man kann darauf hinweisen, aber
wir zeigen es nicht, weil das erst in CMK-2 drankommt.


=== Alarmierung

==== Vorüberlegungen

Wir besprechen mit den Teilnehmern, welche Ereignisse überhaupt Alarme
auslösen (Zustandswechsel, Wartungszeiten, etc.). Dazu zeigen wir auch
die Views, in denen man die Events sieht, welche Alarme ausgelöst
hätten.

Anhand des Architekturbildes zeigen wir, wie die Alarme vom Core
erzeugt und an das Notificationmodul weitergeleitet werden. Folgende
Ereignisse können alarmiert werden:

* Ein Zustandswechsel (z.B. (OK) → (WARN))
* Der Wechsel zwischen einem stetigen und einem ICON[icon_flapping.png] unstetigen Zustand (flapping)
* Start oder Ende einer ICON[icon_downtime.png] geplanten Wartungszeit
* Die ICON[icon_ack.png] [basics_ackn|Bestätigung eines Problems] durch einen Benutzer ({{Acknowledgement}})# 
* Eine durch ein ICON[icon_commands.png] [commands|Kommando] von Hand ausgelöste Alarmierung
* Die Ausführung eines ICON[icon_alert_handlers.png] [alert_handlers|Alerthandlers] (Ab CEE Version VERSION[1.4.0i2])
* Ein Ereignis, das von der ICON[icon_mkeventd.png] [ec|Event Console] zur Alarmierung übergeben wurde

Dann besprechen wir, welche Konfigurationseigenschaften
die Alarmierung beeinflussen:

* Wartungszeiten
* Max Check Attempts
* Quittierungen mit „sticky“-Attribut bei Wechsel zwischen (WARN) und (CRIT)
* Hauptschalter in Master-Control
* Zugehörigkeit zu Kontaktgruppen
* Hosts, die (DOWN) sind schalten die Alarme der Services ab
* Parents: Hosts, die (UNREACH) sind, werden nicht alarmiert (per Default)

==== Alarmierung aufsetzen

Für die Schulung instalieren wir das Paket `postfix` ohne Smarthost
und stellen die Mails dann direkt an die lokalen Benutzer zu. Als Emailadresse
verwenden wir dann z.B. `linux@localhost`.

Wir erklären den TN aber, dass Sie im echten Leben einen Smarthost einrichten
müssen und zeigen ihnen den Kommandozeilenbefehl, mit dem Sie den Mailversand
ausprobieren können.

Zunächst gehen wir nach dem Einsteigerhandbuch vor. Dabei ist es wichtig,
dass wir den eingebauten Emaildienst von Linux sauber aufgesetzt haben und
den TN auch zeigen, wie sie diesen testen können.

Wir zeigen auch, wie man über eigene Regeln die Alarmierung anpassen kann,
wie im Hauptteil des Handbuchs beschrieben.

Wir zeigen aus den globalen Einstellungen die Fallback-Emailadresse inklusive
der gelben Warnung.

Wir zeigen den TN natürlich auch, wie sie Alarmierungen ausprobieren können:

* Die Liste der letzten 10 Alarme und die Replay-Funktion
* Tests mit „Fake check results“.
* Wir erwähnen, dass es das Logfile `notify.log` gibt, ohne groß darauf einzugehen.


==== Zeitperioden

Wir zeigen, wie man Timeperiods definiert und wie diese funktionieren. Dann
zeigen wir, wie man diese für die Konfiguration der Alarmierung verwenden
kann, und zwar:

* In der Monitoring Konfiguration ({{Notification Period for Hosts/Services}})# 
* In den Alarmierungsregeln selbst

Als Beispiele definieren wir die Zeitperioden `workhours`,
`nonworkhours` und noch eine für die Feiertage, indem wir eine
ical-Datei aus dem Internet runterladen.

Wir weisen darauf hin, dass es keine gute Idee ist, die [.guihints]#Check period}}# 
umzustellen. Wenn es Zeitfenster gibt, in denen der Zustand eines Services
ungewiss ist, soll man lieber mit Recurring Scheduled Downtimes arbeiten.


=== Verteiltes Monitoring

==== Verteile Statusansicht

Dieser Punkt ist nicht im Einsteigerhandbuch enthalten. Wir gehen wir wie
im Handbuchartikel [distributed_monitoring|Verteiltes Monitoring].

Im ersten Schritt setzen wir zwei Checkmk-Instanzen von Hand auf und nehmen
in jede Hosts auf. Die zweite Instanz verbinden wir dann per Livestatus
-- noch ohne zentrales WATO -- unter die GUI der ersten Instanz und zeigen
so ein verteiltes Monitoring mit dezentraler Konfiguration.

Dabei zeigen wir auch das Sidebarsnapin [.guihints]#Site status}}.# 

Wir erklären, wie der Livestatus-Proxy funktioniert. Wir empfehlen
dringend, ihn einzusetzen -- auch für die lokale Site.

Wir zeigen auch, wie die Verschlüsselung funktioniert und wie man
diese aufsetzt.


==== Zentrale Konfiguration

Im zweiten Schritt stellen wir jetzt um auf ein zentrales WATO und
managen auch die Remotesite über das zentrale WATO. Dabei zeigen wir
auch, dass die Hosts der Slavesite dabei überschrieben werden. Wenn
die Frage kommt, wie man das migrieren kann, sagen wir, dass man dazu
Dateien aus `etc/conf.d/wato` von Hand kopieren könnte, dass
das aber über den Einsteigerkurs hinausgeht. Im Zweifel Supportanfrage!

Dann zeigen wir, wie man die Verbindung per SSL absichert: Dazu muss man
den Webserver mit SSL aufsetzen und die Inter-WATO-Verbindung auf HTTPS
umstellen. Das ist mühsam, aber wichtig!

*Hinweis:* wir diskutieren keine Einzelheiten oder Fragen zu OpenSSL,
sondern zeigen nur zielstrebig, was man machen muss, um das abzusichern. Das
Thema sollte auch nicht zulange dauern.


== Tag 5

=== HW/SW-Inventur

Hier gibt es aktuell noch keinen Artikel. Wir zeigen:

. Wie aktiviert man die HW/SW-Inventur auf dem Checkmk-Server (Regel)? Man sieht jetzt für die Server noch nicht viel, aber eine ganze Menge schon für SNMP-Geräte.
. Jetzt installieren für das Inventur-Plugin für unsere Linux-Server.
. Jetzt zeigen wir, wie das unter Windows geht.
. Wir zeigen, wie man die Inventorydaten auf der GUI sieht, und zwar die baumartige Darstellung
. Dann zeigen wir die tabellenartigen Views, z.B. die von den Switchports oder der installierten Software
. Wir zeigen, wie man in der GUI die Geschichte von Änderungen von Hard- und Software sehen kann (dazu simulieren wir Änderungen z.B. durch Installation von Paketen)
. Wir zeigen, wie Checkmk automatisch Hostlabels anhand dieser Daten erzeugt.

=== Konfiguration rekapitulieren

Wir diskutieren jetzt nochmal, welche Ordner- und Tagstruktur sinnvoll ist
für welchen Zweck.

Wir zeigen die WATO-Seite mit dem-„Best practises“-Check.

=== Backup & Restore

Wir zeigen, wie man eine Checkmk-Instanz mit `omd backup` und `omd restore`
sichern kann. Dabei auch die Optione `--no-rrds` und `--no-logs` und `-N`.
Und dann zeigen wir, wie man automatische Backupjobs direkt in WATO einrichten
kann.

Dann weisen wir noch darauf hin, dass das WATO-Backupmodul in verteilten Umgebungen nicht
funktioniert, bzw. nur die Mastersite sichert.

=== Update von Checkmk

Normales Update: Jetzt gehen wir auf die aktuellste stabile Version.
Wir erwähnen, dass ein Upgrade von der (CFE) genauso geht. Sollte
einer der TN bereits die (CRE) einsetzen, erklären wir, wie der
Update auf die (EE) funktioniert.

Deinstallieren von nicht mehr gebrauchten Versionen von Checkmk.

=== Aggregation Metrikdaten aufgreifen

Jetzt ist Freitag und wir haben Daten von fünf Tagen. Jetzt können wir nochmal
live zeigen, welche Unterschiede die drei verschiedenen Funktionen min/max/avg
in den Graphen haben.

* Klicken auf die Spalten min, max, average. Warum ändern sich auch die angezeigten Kurven dabei?

== Feedback und Kritik

*Hier sammeln wir das Feedback unserer Trainingspartner*

=== Robert Sander

Hallo,

hier schonmal kurz ein erstes Feedback der Schulung Teil1 aus der
letzten Woche:

Die meisten Teilnehmer waren doch erheblich über die kurzfristige
Änderung der Inhalte überrascht. Insbesondere hätten sie Local Checks
und die Agent Bakery vermisst, da sich einige extra deswegen angemeldet
hatten.

Wir hatten im Ablauf dann aber reichlich Zeit. Der Dienstag war
inhaltlich schon um 14:00 rum, da habe ich einfach die Local Checks
angehängt. Und am Freitag war ausreichend Zeit für die Bakery und den
Updater.

Ich würde dafür plädieren, diese beiden Themen im Teil 1 zu belassen, da
Local Checks (und MRPE) den Leuten schon sehr viel weiterhilft, ihre
Infrastrukturen individuell zu überwachen. Und die Bakery hilft dem
Admin auch ungemein.

In Teil 2 gibt es ja noch genug Themen, die fortgeschritten sind.

=== Karl Deutsch

* Schade finde ich nur, dass nicht im Tausch klassische Einsteigerthemen wie PDF-Reporting und NagVis in Teil 1 gewandert sind.
* Agent *Bakery* (ohne Updater) und Localchecks wieder in Teil 1 aufnehmen

=== Karl Deutsch (2)

Der Umfang hat perfekt für 5 Tage gepasst. Nach dem Kurs in der nächsten
Woche werde ich das Dokument noch einmal aktualisieren.
