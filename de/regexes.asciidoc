include::global_attr.adoc[]
= Reguläre Ausdrücke in {CMK}
:revdate: draft
:title: {CMK} mit Text-Muster konfigurieren
:description: An vielen Stellen gibt es die Möglichkeit, über reguläre
Ausdrücke eine Gruppe an Objekten zu erfassen. Erst dadurch wird eine hohe
Dynamik ermöglicht.

{related-start}
link:wato_rules.html[Host- und Serviceparameter]
link:views.html[Ansichten von Hosts und Services (Views)]
link:ec.html[Die Event Console]
{related-end}


== Einleitung

// MFS: RegExe ist Mischung aus Deutsch und Englich, besser IMHO auszuschreiben:
// TK: Find ich gut. Ich würde aber trotzdem hinter regexp zusätzlich noch regex einführen, da im Text nach wie vor diverse Male regex vorkommt - oder eben konsequent ersetzen.
Reguläre Ausdrücke (englisch _regular expression_ oder _regex_, selten
_regexp_), werden in {CMK} für die Angabe von Service-Namen und auch an vielen
anderen Stellen verwendet. Es sind Muster, die auf einen bestimmten Text passen
(_match_) oder nicht passen (_nonmatch_). Damit können Sie viele praktische
Dinge anstellen, wie z.B. flexible xref:wato_rules#[Regeln] formulieren, die
für alle Services greifen, bei denen `foo` oder `bar` im Namen vorkommt.

Oft werden reguläre Ausdrücke mit den Suchmustern für Dateinamen verwechselt,
denn die Sonderzeichen `pass:[*]` und `?`, sowie eckige und geschweifte
Klammern gibt es in beiden. 
// TK: Gehören zu den globbing patterns nicht auch die eckigen Klammern - oder ist an dieser Stelle zu viel Info?
// MFS: Erwähnen ja, aber nicht weiter ausführen, da komplett andere Syntax und Semantik:
// ls a[abc].txt
// -> aa.txt  ab.txt  ac.txt
// ls a{a,b,c}.txt
// -> aa.txt  ab.txt  ac.txt
// ls {aa,ab,ac}.txt
// -> aa.txt  ab.txt  ac.txt
Nur haben jene sogenannten _globbing patterns_ eine ganz andere Syntax und sind
bei weitem nicht so mächtig wie die regulären Ausdrücke. 
// Wenn Sie unsicher sind, ob an einer Stelle reguläre Ausdrücke erlaubt sind, dann schalten
// Sie am besten die icon:icon_help[] Onlinehilfe an.
// TK: Der letzte Satz über die Online-Hilfe kommt mir hier zu unvermittelt - und hat auch nichts mit dem Unterschied regexp - glob zu tun. Ich würde den Satz hier löschen und dieses Thema komplett im Tipp weiter unten abhandeln.

// MFS: Neu: Verweis auf die Unterschiede
In diesem Artikel zeigen wir Ihnen die wichtigsten Möglichkeiten der regulären
Ausdrücke, selbstverständlich im Kontext von {CMK}. Da {CMK} zwei verschiedene Komponenten für reguläre Ausdrücke nutzt, steckt manchmal der Teufel im Detail.
Im wesentlichen nutzt der Monitoring-Kern die *C-Bibliothek* und alle weiteren Komponenten *Python 3*. Wo Unterschiede bestehen, erklären wir diese.
// Die Unterschiede zwischen beiden arbeiten wir heraus.
// TK: Ist das nicht zuviel versprochen? Bis auf 1x Achtung Python gibt es doch im folgenden keine Unterscheidung zwischen Python und C?
// MFS: Ich würde den Satz hinsichtlich der baldigen Ergänzung um Unicode drin lassen.

*Tipp:* In {CMK} sind regexp in Eingabefeldern auf unterschiedlichen Seiten
erlaubt. Wenn Sie sich unsicher sind, lassen Sie sich die kontextsensitive
Hilfe über das Help-Menü einblenden (Help > Show inline help). Dann sehen Sie,
ob reguläre Ausdrücke erlaubt sind und wie sie genutzt werden können.

// MFS: Neu: Verweis auf weitere Unterschiede bei Plugins
Bei der Arbeit mit älteren Plugins oder Plugins aus externen Quellen kann es
mitunter vorkommen, dass diese Python 2 oder Perl nutzen und von den hier
geschilderten Konventionen abweichen, bitte beachten Sie daher die jeweilige
Plugin-spezifische Dokumentation. 

// TK: Gibt es denn bei den regexp Unterschiede zwischen Python 2 und 3? In Kap. 1.2 weiter unten schreibst Du nur "Achtung Python" - ohne Version.
// MFS: Wird wenn die Unicode-Handhabung ergänzt wird, auch auf Unterschiede zwischen 2 und 3 hinauslaufen.

In diesem Artikel zeigen wir Ihnen die wichtigsten Möglichkeiten der regulären
Ausdrücke — aber bei weitem nicht alle. Falls Ihnen die hier gezeigten
Möglichkeiten nicht weit genug gehen, finden Sie xref:reference[weiter unten] 
Hinweise, wo Sie alle Details nachlesen können. Und dann gibt es ja immer noch
das Internet.

// TK: 2) Ich verstehe den Satz nicht: Warum jetzt Programmierung? Was meinst Du mit Performance bestimmter regulärer Ausdrücke? Ist das jetzt noch Info für den {CMK}-Benutzer oder für den Plugin-Programmierer? 3) "muss verwiesen werden" liest sich wie in einer Seminararbeit - auch hier besser den Leser direkt ansprechen: "müssen Sie in ... nachschlagen" (passt auch sehr schön zur Bibliothek ;-)

Falls Sie eigene Plugins programmieren wollen, die beispielsweise mit regulären
Ausdrücken Auffälligkeiten in Log-Dateien finden, können Sie diesen Artikel als
Grundlage verwenden. Allerdings ist bei der Suche in großen Datenmengen die
Optimierung der Performance ein wichtiger Aspekt. Daher empfehlen wir, immer in
der Dokumentation der verwendeten Regex-Bibliothek nachzuschlagen.

== Mit regulären Ausdrücken arbeiten

In diesem Abschnitt zeigen wir anhand konkreter Beispiele die Arbeit mit regulären Ausdrücken, von einfachen Matches einzelner Zeichen oder Zeichenketten, bis hin zu komplexen Gruppen von Zeichen.

[#alphanumeric]
=== Alphanumerische Zeichen

Bei den regulären Ausdrücken geht es immer darum, ob ein Muster ("Pattern", 
beziehungsweise der reguläre Ausdruck) auf einen bestimmten Text (z.B. einen
Service-Namen) _passt_ (_matcht_). Der einfachste Anwendungsfall sind Ketten
alphanumerischer Zeichen. Diese (und das als Bindestrich verwendete
Minus-Zeichen) im Ausdruck matchen einfach sich selbst.
 
{CMK} unterscheidet dabei in der Regel _nicht_ zwischen Groß- und 
Kleinschreibung. Der Ausdruck `CPU load` matcht also in den meisten Fällen auf
den Text `CPU load` genauso wie auf `cpu LoAd`. 
 
*Achtung:* Bei Eingabefeldern, in denen ohne reguläre Ausdrücke ein exakter
Match vorgesehen ist (meistens bei Host-Namen), wird Groß- und Kleinschreibung
immer unterschieden! Plugins können von den üblichen {CMK}-Gepflogenheiten
abweichen. Ist nicht aus dem Kontext ersichtlich, welche Komponente ein
Eingabefeld bereitstellt, oder ob reguläre Ausdrücke oder exakte Matches
gefordert sind, aktivieren bitte Sie die Inline-Hife.
 
// TK: Wie erkenne ich denn, ob ein bestimmtes Eingabefeld von einem Plugin erstellt wurde, um in der "jeweiligen Beschreibung" nachsehen zu können, die ich wo finde? Auch in der Inline-Hilfe?
// MFS: In der Tat dürften bei vielen CMK Installationen unterschiedliche Personenkreise die CMK-Installation betreuen (also Plugins installieren, default thresholds setzen etc.) als das Monitoring selbst konfigurieren (Server hinzufügen, Anpassungen von thresholds für Einzelfälle), da ist sicher oft kein Bewusstsein da, woher ein Eingabefeld kommt, in mitgelieferten Plugins stehen Hinweise zur Verwendung von Regexp oft in der Beschreibung des Eingabefeldes. Solange hier kleine Inkonsistenzen bestehen, muss die Dokumentation schwammig bleiben...  

[#dotaswildcard]
=== Der Punkt als Wildcard

Neben den "Klartext"-Zeichenketten gibt es eine Reihe von Zeichen und
Zeichenfolgen, die "magische" Bedeutung haben. Das wichtigste derartige Zeichen
ist der `.` Punkt. *Er matcht genau ein einziges beliebiges Zeichen:*

Beispiel:

[cols="34,22,22",options=header]
|===
|Regulärer Ausdruck |Match |Kein Match 
|`Me.er`  |`Meier` +
           `Meyer` |`Meyyer`
|`.var.log` |`1var2log` +
              `/var/log` |`/var//log` 
|===

[#repetition]
=== Wiederholungen von Zeichen

Sehr häufig möchte man definieren, dass eine Folge von Zeichen bestimmter
Länge vorkommen darf. Hierfür gibt man in geschweiften Klammern die Zahl
der Wiederholungen des vorhergehenden Zeichens an:

[cols="25,35,20,20",options=header]
|===
|Regulärer Ausdruck |Bedeutung |Match | Kein Match
|`Ax{2,5}B` |`x` tritt mindestens einmal, aber höchstens fünfmal auf
	    |`AxxB` +
	     `AxxxxB` |`AxB` +
	               `AxxxxxxB`
|`Ax{0,5}B` |`x` tritt höchstens fünfmal auf, es muss aber nicht 
             auftreten
	    |`AB` +
             `AxxxxxB` | `AxxxxxxB`
|`Ax{3}B`   |`x` tritt genau dreimal auf
            |`AxxxB` |`AxxB` +
                      `AxxxxB`	    
|`Ax{0,}B`  |`x` tritt beliebig oft auf
            |`AB` +
	     `AxxxxxxB` |
|`Ax{1,}B`  |`x` tritt mindestens einmal auf
            |`AxB` +
             `AxxxxxB` | `AB`
|`Ax{0,1}B` |`x` tritt höchstens einmal auf
            |`AB` +
             `AxB` | `AxxB`
|===

Für die letzten drei Fälle gibt es Abkürzungen: `pass:[*]` matcht das
vorhergehende Zeichen *beliebig oft*, `pass:[+]` matcht ein *mindestens
einmaliges Auftreten* und `pass:[?]` matcht das *höchstens einmalige 
Auftreten*. 

Sehr oft möchte man definieren, dass irgendwo im Ausdruck eine beliebige Folge
von Zeichen vorkommen darf. In regulären Ausdrücken schreiben Sie dann 
`pass:[.*]` (Punkt Stern). 

// TK: Dabei gilt auch eine leere Folge als Folge, d.h. das Zeichen vor dem * (Stern) kann auch fehlen.
// MFS: Null mal x ist null, Asterisk nach leerer Zeichenkette matcht also nur leere Zeichenkette und ist damit obsolet

[cols="40,30,30",options=header]
|===
|Regulärer Ausdruck |Match |Kein Match 
|`State.*OK` |`State is OK` +
              `State = OK` +
	      `StateOK` |`StatOK`
|`State*OK`  |`StateOK` +
              `StatOK` |`State OK`
|`a *= *5`   |`a=5` +
              `a{nbsp}={nbsp}5` |`a==5`
|`State.+OK` |`State is OK` +
              `State=OK` +
	      `State OK` |`StateOK`
|`State.?OK` |`State=OK` +
              `State OK` +
	      `StateOK` | `State is OK`   
|===

// TK: In der ersten Zeile State = OK ersetzen durch StateOK (wg. 0x beliebiges Zeichen)

// Das Zeichen `+` ist fast das Gleiche wie `pass:[*]`, erlaubt aber keine leere
// Folge. Das vorangestellte Zeichen muss also *mindestens einmal vorkommen:*
// 
// [cols="34,22,22,22",options=header]
//|===
// |Regular Expression |Match |Match |Kein Match 
// |`State +OK` |State OK |State{nbsp}{nbsp}OK |StateOK
// |`switch +off` |switch off |switch{nbsp}{nbsp}off |switchoff
// |===
// TK: Hier finde ich die 2. Zeile überflüssig, weil gleiches Prinzip wie in der 1. Zeile
// MFS: Oben in einer Tabelle zusammengefasst, "fast das Gleiche" ist nicht sehr präzise!

// MFS: Nur zur Referenz für Reviewer, oben ausführlicher und Reihenfolge IMHO didaktisch sinnvoller
// Möchten Sie die Anzahl von Wiederholungen genauer festlegen, so gibt es
// dafür eine Syntax mit geschweiften Klammern, die die
// *exakte Anzahl oder einen Bereich angibt:*
// TK: ... angibt*, wobei Anfang und Ende des Bereichs durch Komma getrennt werden:"
// TK: Als Regexp-Naivling dachte ich zuerst, bei Ax{2,4} dürfte das x nur 2x ODER 4x vorkommen,
// MFS: Präzisierung in der Tabelle oben

// MFS: Nur zur Referenz für Reviewer, oben ausführlicher und Reihenfolge IMHO didaktisch sinnvoller
// [cols="34,22,22,22",options=header]
// |===
// |Regular Expression |Match |Match |Kein Match 
// |`Ax{3}B` |AxxxB | |AxB
// |`Ax{2,4}` |Axx |Axxxx |Ax
// |===
// TK: In der 2. Zeile würde ich daher auch Axxx (statt Axxxx) als Beispiel nehmen.

// MFS: Nur zur Referenz für Reviewer, oben ausführlicher und Reihenfolge IMHO didaktisch sinnvoller
// Eine Abkürzung für `{0,1}`, also exakt null- oder einmaliges Vorkommen, ist
// das Fragezeichen. Es markiert das vorangegangene Zeichen somit als optional:
// [cols="34,22,22,22",options=header]
//|===
//|Regular Expression |Match |Match |Kein Match 
//|`a-?b` |ab |a-b |a--b
//|`Meyi?er` |Meyer |Meyier |Meyiier
//|===

[#characterclasses]
=== Zeichenklassen, Ziffern und Buchstaben

Zeichenklassen erlauben es, bestimmte Ausschnitte des Zeichensatzes zu matchen,
beispielsweise "hier muss eine Ziffer kommen". Dafür setzen Sie alle zu
matchenden Zeichen innerhalb eckiger Klammern. Mit einem Minuszeichen können
Sie auch Bereiche angeben. *Achtung:* es gilt dabei die Reihenfolge im
https://de.wikipedia.org/wiki/American_Standard_Code_for_Information_Interchange[7-Bit-ASCII-Zeichensatz].

So steht beispielsweise `[abc]` für genau eines der Zeichen
*a, b oder c* und `[0-9]` für *eine beliebige Ziffer -* beides
lässt sich kombinieren. Auch eine Negation des Ganzen ist möglich:
Mit einem `^` in der Klammer steht `[^abc]` dann für ein
beliebiges Zeichen *außer a, b, c.*

Zeichenklassen lassen sich natürlich mit anderen Operatoren
kombinieren. Zunächst mal einige abstrakte Beispiele:

[cols="34,~",options=header]
|===
|Zeichenklasse |Bedeutung 
|`[abc]` |Genau eines der Zeichen a, b, c.
|`[0-9a-z_]` |Genau eine Ziffer, ein Buchstabe oder ein Unterstrich.
// TK: Muss das nicht heißen ein Kleinbuchstabe statt Buchstabe? Oder anderes Bsp nehmen: [0-9A-z_]
// MFS: Da CMK in der Regel case insensitive arbeitet, werden auch Großbuchstaben gematcht, A-z würde auch []\^_` matchen!
|`[^abc]` |Jedes beliebige Zeichen außer a, b, c.
|`[ --]` |Genau eines der Zeichen aus der Menge Leerzeichen, Minuszeichen und alle, die in der ASCII-Tabelle dazwischen liegen: `!"#$%&'()*+,`.
// TK: Die Zeichen in diesem ASCII-Bereich sind interessant, weil das unten im Telefonnummernbeispiel nochmal verwendet wird.
// TK: Vielleicht besser so: Genau ein Zeichen aus dem Bereich von Leerzeichen bis Bindestrich gemäß ASCII-Tabelle. In diesem Bereich befinden sich die folgenden Zeichen: !"#$%&'()*+,
|`[0-9a-z]{1,20}` |Eine Folge von mindestens einem und maximal 20 Buchstaben und/oder Ziffern in beliebiger Reihenfolge.
|===

Dazu einige praktische Beispiele:

[cols="34,33,33",options=header]
|===
|Regulärer Ausdruck    |Match  |Kein Match 
|`[0-7]`               |`0` +
	                `5`    |`9`
|`[0-7]{2}`            |`00` +
                        `53`   |`183`
|M[ae]{1}[iy]{1}e?r    |`Meier` +
			`Meyer` +
			`Mayr` | `Maeier` 
// altes Beispiel myhost_123 matcht, wenn regex nicht terminiert mit $
|`myhost_[0-9a-z_]{3}` |`myhost_1a3` +
                        `myhost_1_5`   |`myhost_xy`
// altes Beispiel myhost_1234 matcht, wenn regex nicht terminiert mit $
|`[+0-9/ ()-]+`        |`+49 89 998209700` +
		        `089 / 9982 097-00` | `089 : 9982 097-00` +
			                      (hier wird nur die Gruppe vor dem Doppelpunkt gematcht)
|===

*Hinweis:* Wenn Sie eines der Zeichen `-` oder `[]` brauchen, müssen Sie
etwas tricksen. Den `-` schreiben Sie ans _Ende der Klasse_ -- wie im letzten
Beispiel bereits gezeigt. Dann weiss der Interpreter der regulären Ausrücke,
dass keine Folge gemeint sein kann. Eine schließende eckige Klammer platzieren
Sie als _erstes_ Zeichen in der Klasse, eine öffnende gegebenenfalls als
_zweites_ Zeichen. Da keine leeren Klassen erlaubt sind, wird die schließende
eckige Klammer dann als normales Zeichen interpretiert. Eine Klasse mit genau
diesen beiden Sonderzeichen sähe also so aus: `[]-]`, beziehungsweise `[][-]`.

// TK: ... und wenn man auch noch die öffnende eckige Klammer [ braucht, dann so?: [][-]
// TK: Aber das führt dann wohl doch zu weit...
// MFS: Nö, sehr valide Frage. Wann möchte man schon nur schließende eckige Klammern matchen ohne öffnende? Ich packe eckige Klammern immer mit \ Escape in meinen Regex nach hinten, diese manchmal besser lesbare Möglichkeit erwähne ich aber dann weiter unten.

[#prefixinfixsuffix]
=== Anfang und Ende -- Präfix, Suffix und Infix
// TK: Ich glaube zu verstehen, wieso dieses Kapitel so aufgebaut ist, wie es ist, aber ich finde es didaktisch besser, anders vorzugehen:
// TK: Zuerst erklären wie man Präfix-Match, Infix-Match, Suffix-Match und exakter Match "allgemein" als regexp notiert.
// TK: Dann kann man sagen, dass in {CMK} standardmäßig die Eingabe als Präfix-Match interpretiert wird (und in der EC als Infix-Match) und man daher die Präfix/Infix-Auszeichnung weglassen darf/muss(?)
// MFS: Volle Zustimmung! Umgebaut:

In vielen Fällen ist es erforderlich, zwischen Matches am Anfang, am Ende oder 
einfach irgendwo innerhalb einer Zeichenkette zu unterscheiden. Für den Match
des Anfangs einer Zeichenkette (Präfix-Match) verwenden Sie den Zirkumflex
`pass:[^]`, für das Ende (Suffix-Match) das Dollarzeichen `pass:[$]`. Ist
keines der beiden Zeichen angegeben, ist bei den meisten Bibliotheken für
reguläre Ausdrücke Infix-Match Standard -- es wird an beliebiger Stelle in der
Zeichenkette gesucht. Für exakte Matches verwenden Sie sowohl `pass:[^]` als
auch `pass:[$]`.

[cols="34,33,33",options=header]
|===
|Regulärer Ausdruck |Match |Kein Match 
|`/var` |`/var` +
          `/var/log` +
	  `/usr/var` |  
|`^/var` |`/var` +
          `/var/log` |`/usr/var` 
|`/var$` |`/var` +
          `/usr/var` |`/var/log`
|`^/var$` |`/var`    |`/var/log` +
                      `/usr/var` 
// |`.*/var$` |/var |/test/var |/var/log
// |`.*/var` |/test/var |/test/var/log |\test\var\log
|===
// TK: In dieser Tabelle wird nicht klar, ob die "allgemeine" regexp oder der {CMK} Präfix-Match beschrieben wird.
// TK: Das ^ für den Präfix-Match wird verwendet, aber erst nach der Tabelle erklärt.
// TK: Oder anders: Was passiert, wenn ich ^/var in {CMK} eingebe, wenn dort der Präfix-Match verwendet wird, also /var reichen würde?
// MFS: Das redundante ^ wird ignoriert (zumindest in Python), ich habe umgestellt und erkläre die CMK Defaults weiter unten

*Hinweis:* {CMK} prüft beim Vergleichen von regulären Ausdrücken mit
Service-Namen und anderen Dingen grundsätzlich, ob der Text mit dem _Anfang_
des Ausdrucks übereinstimmt (Präfix-Match).
// Der Grund dafür ist, dass das meistens das ist, was Sie brauchen.
// MFS: Klingt bevormundend. Wenn ich nach "Memory" suche, will ich dann wirklich nur "Memory usage" oder bspw. auch "Kernel memory"? Diese Aussage wird zudem dadurch aufgeweicht, dass viele Suchfelder Substring-Suche sind und die ist per se Infix-Match
In der Event-Konsole verwendet {CMK} den Infix-Match als Standard. Eine Regel, 
bei der Sie bei [.guihint]#Services# die Begriffe `CPU` und `Kernel` angeben,
matcht also auf alle Services, die mit einem dieser Begriffe _beginnen:_

image::regexes_servicematch.png[]
// TK: Schade, dass gerade dieser Hilfetext sich so liest, als ob er nach einem 15h Arbeitstag um 2h morgens geschrieben worden ist ;-)

//Das bezeichnet man auch als _Präfix-Match._ Benötigen Sie einen
//_exakten Match_, so können Sie das durch Anhängen eines `$`
//bewerkstelligen. Dieser matcht quasi auf das _Ende_ des Texts. Genügt es,
//wenn der Ausdruck _irgendwo_ im Text matcht, ein sogenannter _Infix-Match,_
//erreichen Sie das mit dem bekannten `pass:[.*]` vorab:
// TK: vielleicht besser so: ... Ausdruck _irgendwo_ im Text vorkommen soll, d.h. ein sogenannter _Infix-Match,_ erreichen Sie das ...

Wegen des Standard-Verhaltens _Präfix-Match_ (siehe Erläuterungen im 
Screenshot), müssen Sie an den meisten Stellen der {CMK}-GUI ein wenig 
tricksen, um Infix-Match oder Suffix-Match zu erhalten, stellen Sie mit `.*`
den Ausdruck für eine beliebige Zeichenkette vorne an:

[cols="34,33,33",options=header]
|===
|Regulärer Ausdruck |Match |Kein Match 
|`/var` |`/var` +
          `/var/log` | `/usr/var` 
|`.*/var` |`/var` +
          `/usr/var` +
	  `/var/log` | 
|`/var$` |`/var` |`/var/log` +
                  `/usr/var` 
|===

*Tipp:* Sie können _jede_ Suche am Anfang einer Zeichenkette mit `pass:[^]` und
_jede_ Suche innerhalb mit `pass:[.*]` einleiten, die Interpreter für reguläre
Ausdrücke ignorieren redundante Symbole.

////
Eine Ausnahme von der Regel, dass {CMK} immer einen Präfix-Match verwendet,
ist die xref:ec#[Event Console (EC)], welche immer mit einem Infix-Match
arbeitet -- also nur auf _Enthaltensein_ prüft. Hier können Sie durch
Voranstellen von `^` ein *Match für den Anfang erzwingen,*
also einen Präfix-Match.

[cols="34,22,22,22",options=header]
|===
|Regular Expression in EC |Match |Match |Kein Match 
|`ORA-` |ORACLEserver |myORACLEserver |myoracleserver
|`^ORA-` |ORACLEserver |ORACLEhost |myORACLEserver
|===
////
// TK: Die Beispiele verstehe ich nicht: Warum matcht ein ORA- auf ORACLEserver? Der Bindestrich wird doch als normales Zeichen interpretiert? Oder nicht?
// MFS: Beispiele komplett rausgenommen, ist nun nach der neuen Gliederung alles in den beiden Tabellen oben verwurstet.

[#escaping]
=== Sonderzeichen mit Backslash maskieren

Da der Punkt alles matcht, matcht er natürlich auch einen Punkt. Wenn Sie nun
aber _genau_ einen Punkt matchen wollen, so müssen Sie diesen mit einem
`\` (Backslash) maskieren (eingedeutscht: „escapen“). Das gilt analog
auch für alle anderen Sonderzeichen. 
// , die Sie noch kennenlernen werden.
// MFS: Haben wir alle kennengelernt bis auf & und das ist als Klassenseparator zeimlich esoterisch... 
Dies sind: `\ . * + ? { } ( ) [ ] | & ^` und `$`. Der `\`
Backslash *wertet das nächste dieser Sonderzeichen als normales Zeichen:*

[cols="34,33,33",options=header]
|===
|Regulärer Ausdruck |Match |Kein Match 
|`example\.com` |`example.com` |`example\.com` +
                                `example-com`
|`Wie\?` |`Wie?` |`Wie\?` +
		  `Wie` 
|`C:\\Programs` |`C:\Programs` |`C:Programs` +
                                `C:\\Programs` 
|===

*Achtung Python:* Da in 
https://docs.python.org/3/howto/regex.html#the-backslash-plague[Python] der
Backslash in der internen Zeichenkettendarstellung intern mit einem weiteren
Backslash maskiert wird, müssen diese beiden Backslashes wiederum maskiert
werden, was zu insgesamt vier Backslashes führt:

[cols="34,33,33",options=header]
|===
|Regulärer Ausdruck |Match |Kein Match 
|`C:\\\\Programs` |`C:\Programs` |`C:Programs` +
                                  `C:\\Programs` 
|===

[#alternatives]
=== Alternativen

Mit dem senkrechten Strich `|` können Sie _Alternativen_ definieren, sprich
eine ODER-Verküpfung verwenden: `1|2|3` matcht also _1, 2 oder 3._ Wenn Sie die
Alternativen inmitten eines Ausdrucks benötigen, gruppieren Sie diese innerhalb
runder Klammern.

[cols="34,33,33",options=header]
|===
|Regulärer Ausdruck |Match |Kein Match 
|`CPU load\|Kernel\|Memory` |`CPU load` +
                             `Kernel` |`CPU utilization`
|`01\|02\|1[1-5]`           |`01` + 
			     `02` +
			     `11` bis `15` |05
|`server\.(intern\|dmz\|123)\.net` |`server.intern.net` +
                                    `server.dmz.net` |`server.extern.net` 
|===


[#matchgroups]
=== Match-Gruppen

Match-Gruppen erfüllen zwei Zwecke: Der erste ist -- wie im letzten Beispiel
gezeigt -- die Gruppierung von Alternativen oder Teil-Matches, dabei sind auch
verschachtelte Gruppierungen möglich. Zudem ist es zulässig, hinter runden
Klammern die Wiederholungsoperatoren `pass:[*]`, `+`, `?` und `{`...`}` zu
verwenden. So passt der Ausdruck `(/local)?/share` sowohl auf `/local/share`
als auch auf `/share`.

Der zweite Zweck ist das "Einfangen" gematchter Zeichengruppen in Variablen.
In der xref:ec#[Event Console (EC)], xref:bi#[Business Intelligence (BI)] und
auch beim xref:wato_hosts#rename[Massenumbenennen von Hosts] besteht die
Möglichkeit, den Textteil der dem regulären Ausdruck in der ersten Klammer
entspricht, als `\1` zu verwenden, den der zweiten Klammer entsprechenden als
`\2` usw.

// MFS: Alter Text als Referenz.
////
dass Sie sich auf Textteile beziehen, die im Ursprungstext gefunden wurden. Dabei
werden Muster in regulären Ausdrücken mit Klammern markiert. Der Textteil,
der auf den ersten Klammerausdruck passt, steht dann beim Ersetzen als
`\1` zur Verfügung, der zweite Ausdruck als `\2` usw.
////

[cols="34,22,22,22",options=header]
|===
|Regulärer Ausdruck |Zu matchender Text |Gruppe 1 |Gruppe 2 
// TK: Statt Text würde ich Eingabewert oder Texteingabe im Header schreiben.
// MFS: Tatsächlich handelt es sich um "zu matchenden Text", eingegeben wird ja auf der einen Seite der reguläre Ausdruck und auf der anderen Seite der neue Text, der die Variable verwendet 
// MFS: Fallstrick, hier war das + außerhalb der Klammer!
|`([a-z]+)([123]+)` |`def231` |`def` |`231`
|`server-(pass:[.*])\.local` |`server-lnx02.local` |`lnx02` |
|===

Folgende Abbildung zeigt eine solche Umbenennung. Alle Host-Namen, die auf
den regulären Ausdruck `server-(pass:[.*])\.local` passen, werden durch
`\1.servers.local` ersetzt. Dabei steht das `\1` genau für
den Text, der mit dem `pass:[.*]` in der Klammer „eingefangen“ wurde:

image::bulk_renaming_regex.png[]

Im konkreten Fall wird also `server-lnx02.local` in
`lnx02.servers.local` umbenannt.


[#characters]
== Tabelle der Sonderzeichen

Hier noch einmal zusammengefasst die Liste von allen oben erklärten
Sonderzeichen und Funktionen der regulären Ausdrücke, die {CMK} verwendet:
// TK: Hier noch einmal zusammengefasst > Hier finden Sie zusammengefasst

[cols="34,~"]
|===
|`.` |Passt auf _ein_ link:#dotaswildcard[beliebiges Zeichen].
|`\` |Wertet das nächste link:#escaping[Sonderzeichen als normales Zeichen].
|`{5}` |Das vorherige Zeichen muss genau link:#repetition[fünfmal vorkommen].
|`{5,10}` |Das vorherige Zeichen muss mindestens fünf- und höchstens zehnmal vorkommen.
|`*` |Das vorherige Zeichen darf beliebig oft vorkommen (entspricht `{0,}`).
|`+` |Das vorherige Zeichen darf beliebig oft, aber muss mindestens einmal vorkommen (entspricht `{1,}`).
|`?` |Das vorherige Zeichen darf null- oder einmal vorkommen (entspricht `{0,1}`).
|`[abc]` |Steht für genau link:#characterclasses[eines der Zeichen] `a`, `b` oder `c`.
|`[0-9]` |Steht für genau eines der Zeichen `0`, `1` ... `9` (also eine Ziffer).
|`[0-9a-z_]` |Steht für genau eine Ziffer, einen Buchstaben oder den Unterstrich.
// TK: Wie oben: Thema Kleinbuchstaben
// MFS: Da CMK fast überall case insensitive arbeitet, deckt das auch Großbuchstaben ab
|`[^"']` |Steht für genau ein beliebiges Zeichen _außer_ dem einfachen oder doppelten Anführungszeichen.
|`$` |Matcht das link:#prefixinfixsuffix[_Ende_ eines Textes].
|`^` |Matcht den _Anfang_ eines Textes.
|`A\|B\|C`   |Matcht auf link:#alternatives[`A` oder auf `B` oder auf `C_`].
|`(_A_)` |Fasst den Unterausdruck _A_ zu einer link:#matchgroups[Match-Gruppe] zusammen.
// TK: Was ist ein Unterausdruck? Und warum kursiv ausgezeichnet?
// MFS: Siehe [#matchgroups], an dieser Stelle nur Erinnerung
|`\t` |Matcht einen Tabstop (Tabulator), dieses Zeichen kommt oft in Log-Dateien oder CSV-Tabellen vor
|`\s` |Matcht alle Leerzeichen (ASCII kennt 5 verschiedene)
|===

Folgende Zeichen müssen durch link:#escaping[Backslash maskiert werden], wenn sie wörtlich
verwendet werden sollen: `\ . * + ? { } ( ) [ ] | & ^ $`.


// MFS: Auskommentiert, bis Unicode-Handling in den Bestandteilen von CheckMK geklärt
// TK: Daher kein Review von mir.
////

=== Unicode in Python 3 

Insbesondere, wenn Eigennamen in Kommentaren oder beschreibenden Texten per
Copy und Paste übernommen wurde und daher Unicode-Zeichen oder verschiedene
Typen von Leerzeichen im Text auftreten, sind Pythons erweiterte Klassen sehr hilfreich:

[cols=2]
|===
|\t |Matcht einen Tabstop (Tabulator), teils in Logdateien oder CSV-Tabellen
|\s |Matcht alle Leerzeichen (Unicode kennt 25 verschiedene, ASCII 5)
|\S |Invertierung von \s, matcht alle Zeichen, die keine Leerzeichen sind
|\w |Matcht alle Zeichen, die Wortbestandteil sind, also Buchstaben, in Unicode aber auch Akzente oder chinesische, arabische oder koreanische Worte… 
|\W |Invertierung von \w, matcht alles, was typischerweise kein Wortbestandteil ist
|\u |Gibt mit vier folgenden Hexadezimalziffern an, welches Unicode-Zeichen gematcht werden soll
|===

An Stellen, an denen {CMK} Unicode-Matching erlaubt, ist \w vor allem zur Suche nach ähnlich geschriebenen Worten in verschiedenen Sprachen hilfreich, beispielsweise Eigennamen, die mal mit und mal ohne Accent geschrieben werden.

[cols="34,22,22,22"]
|===
|Regular Expression |Match | Match | Kein Match 

|\w{1,3}ni\w{1,2}el |Schnitzel (Deutsch) |șnițel (Rumänisch) |šnicl (Kroatisch) 
|===
////

[#testing]
== Test regulärer Ausdrücke

Die Logik regulärer Ausdrücke ist insbesondere bei verschachtelten Match-Gruppen 
oder der Frage in welcher Reihenfolge von welchem Ende des zu matchenden Strings
ausgewertet wird, nicht immer einfach zu durchschauen. Neben Trial and Error in
{CMK} haben Sie im wesentlichen zwei Möglichkeiten zum Test regulärer Ausdrücke:
Online-Dienste wie https://regex101.com/ bereiten Matches grafisch auf und
erklären darüber die Reihenfolge der Auswertung in Echtzeit. 

image::regexes_testing.png[]

Die zweite Testmöglichkeit ist der Python-Prompt, den jede Python-Installation
mitbringt. Unter Linux und auf dem Mac ist Python 3 in der Regel
vorinstalliert. Gerade weil reguläre Ausdrücke am Python-Prompt exakt wie in
{CMK} ausgewertet werden, gibt es auch bei komplexen Schachtelungen keine
Abweichungen bei der Interpretation. Profis schwören daher auf den
Python-Prompt.

// TK: minimalen und maximalen Matches? Hatten wir noch nicht.
// Auch Profis testen daher gerne im Python-Prompt. 
// TK: Auch Profis? Oder gerade Profis? Ist das denn auch was für Nicht-Profis?
// TK: Was ist denn von einem Online-Tester wie https://regex101.com/ für Python zu halten? Ist das eher was für Anfänger?
// MFS: Ich habe bei dreifach verschachtelten Matchgruppen Abweichungen im Verhalten zwischen "echtem" Python und RegEx101 festgestellt. RegEx101 ist zweifellos klasse zum Üben und erklärt wunderbar, aber in Grenzfällen ist der Python-Prompt besser. Ich habe daher auf "gerade Profis" erweitert, weil man bei 95% der Fälle mit RegEx101 gut klar kommt.

Nach dem Öffnen müssen Sie das Modul `re` importieren. Im Beispiel schalten wir
zudem mit `re.IGNORECASE` die Unterscheidung zwischen Groß- und Kleinschreibung
ab:

[{shell}]
----
{c-omd} *python3*
Python 3.8.10 (default, Jun  2 2021, 10:49:15) 
[GCC 9.4.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> *import re*
>>> *re.IGNORECASE*
re.IGNORECASE
----

Um das Verhalten der regulären Ausdrücke von C nachzubilden, das auch in vielen 
Python-Komponenten genutzt wird, schränken Sie auf ASCII ein:

[{shell}] 
----
>>> *re.ASCII*
re.ASCII
----

Nun können Sie mit der Funktion `re.match()` direkt einen regulären Ausdruck
gegen einen String matchen und die link:#matchgroups[Matchgruppe] ausgeben,
`group(0)` steht hierbei für den gesamten Match, mit `group(1)` wird der
Match ausgegeben, der zum ersten in einer runden Klammer gruppierten
Unterausdruck passt.

[{shell}]
----
>>> *x = re.match('M[ae]{1}[iy]{1}e?r', 'Meier')*
>>> *x.group(0)*
'Meier'
>>> *x = re.match('M[ae]{1}[iy]{1}e?r', 'Mayr')*
>>> *x.group(0)*
'Mayr'
>>> *x = re.match('server-(.pass:[*])\.local', 'server-lnx23.local')*
>>> *x.group(0)*
'server-lnx23.local'
>>> *x.group(1)*
'lnx23'
----


[#reference]
== Wenn Sie es genau wissen möchten
// TK: Ist schon klar, dass es in diesem Kapitel um die vollständige Information geht. 
// TK: Trotzdem würde ich gern wissen, ob sich das oben beschriebene allgemeine Handling in den verschiedenen regexp Varianten unterscheidet.
// TK: Oder andersrum: Wenn ich nur mit den oben beschriebenen "Basics" arbeite, können mir die Unterschiede der Varianten egal sein, oder? 
// MFS: Nein, das allgemeine Handling ist fast identisch. Ich schreibe fast, weil es tatsächlich feine Unterschiede bei verschachtelten Matchgruppen gibt und bei Suffixmatches, die treten in der Praxis selten zu Tage. Wichtig ist IMHO, sich der modernen Erweiterungen wie (?:…) bewusst zu werden. Solche "non-capturing groups" matchen zwar, stellen aber keine group(n) bzw. \n bereit, gut bei geschachtelten Groups, wo man sonst hinterher nicht weiss, welchen Index man jetzt sucht. Später wird der nicht gierige Stern erwähnt, *?, das ist was ich als "minimales Matching" drin hatte - der ist meiner Ansicht nach der wichtigste Unterschied zu POSIX regex.

Ken Thompson, einer der Erfinder von UNIX, hat schon in den 1960ern als erster
reguläre Ausdrücke in der heutigen Form entwickelt -- unter anderem im bis
heute gebräuchlichen Unix-Befehl `grep`. Seitdem wurden zahlreiche
Erweiterungen und Dialekte von regulären Ausdrücken geschaffen -- darunter
erweiterter Regexe, Perl-kompatible Regexe und auch eine sehr ähnlich
Variante in Python.

{CMK} verwendet in den xref:views#filter[Filtern in Ansichten] _POSIX
erweiterte reguläre Ausdrücke_ (extended REs). 
// TK: Anmerkung: in den Filtern gibt es leider keine kontextsensitive Hilfe und daher auch keine Info, ob und wie regexp genutzt werden können.
Diese werden im
Monitoring-Kern in C mit der Regexfunktion der C-Bibliothek
ausgewertet. Sie finden eine komplette Referenz dazu in der
Linux-Manpage zu `regex(7)`:

[{shell-raw}]
----
{c-omd} man 7 regex

REGEX(7)                   Linux Programmer's Manual                   REGEX(7)

NAME
       regex - POSIX.2 regular expressions

DESCRIPTION
       Regular  expressions  ("RE"s), as defined in POSIX.2, come in two forMFS:
       modern REs (roughly those of egrep; POSIX.2 calls these "extended"  REs)
       and  obsolete  REs (roughly those of *ed*(1); POSIX.2 "basic" REs).  Obso-
       lete REs mostly exist for backward compatibility in some  old  programs;
----

An allen anderen Stellen stehen darüber hinaus alle Möglichkeiten der
regulären Ausdrücke von Python zur Verfügung. Dies betrifft unter
anderem die xref:wato_rules#[Konfigurationsregeln], xref:ec#[Event Console (EC)]
und xref:bi#[Business Intelligence (BI)]. Die Python-Regexe sind
eine Erweiterung der extended REs und sehr ähnlich zu denen aus Perl.
Sie unterstützen z.B. den sogenannten _negative Lookahead_, einen
nicht gierigen `pass:[*]` Stern, oder ein Erzwingen der Unterscheidung von
Groß-/Kleinschreibung. Die genauen Möglichkeiten dieser Regexe finden Sie
in der Online-Hilfe von Python zum Modul `re`, oder ausführlicher in der https://docs.python.org/3/library/re.html[Online-Dokumentation] von Python:

[{shell-raw}]
----
{c-omd} pydoc3 re
Help on module re:

NAME
    re - Support for regular expressions (RE).

MODULE REFERENCE
    https://docs.python.org/3.8/library/re
    
    The following documentation is automatically generated from the Python
    source files.  It may be incomplete, incorrect or include features that
    are considered implementation detail and may vary between Python
    implementations.  When in doubt, consult the module reference at the
    location listed above.

DESCRIPTION
    This module provides regular expression matching operations similar to
    those found in Perl.  It supports both 8-bit and Unicode strings; both
    the pattern and the strings being processed can contain null bytes and
    characters outside the US ASCII range.
    
    Regular expressions can contain both special and ordinary characters.
    Most ordinary characters, like "A", "a", or "0", are the simplest
    regular expressions; they simply match themselves.  You can
    concatenate ordinary characters, so last matches the string 'last'.
----

Eine sehr ausführliche Erklärung zu regulären Ausdrücken finden Sie in
der link:https://de.wikipedia.org/wiki/Regulärer_Ausdruck[Wikipedia]. 

