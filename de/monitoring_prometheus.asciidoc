= Prometheus integrieren
:revdate: 2020-05-18
:title: Prometheus integrieren
:description: Mit dieser Erweiterung integrieren Sie Prometheus Instanzen in Checkmk. Details zur Konfiguration erfahren Sie hier.


== Einleitung

=== Hintergrund und Motivation

Vielleicht fragen Sie sich jetzt, warum man überhaupt Prometheus in Checkmk integrieren
sollte. Deswegen an dieser Stelle ein wichtiger Hinweis: Unsere Integration von
Prometheus richtet sich an alle unsere Nutzer, die Prometheus bereits im Einsatz
haben. Damit Sie nicht dauerhaft zwei Monitoring-Systeme prüfen müssen, schließen
wir durch die Integration von Prometheus in Checkmk die hier entstandene Lücke.

Damit ermöglichen wir eine Korrelation der Daten aus den beiden Systemen,
beschleunigen eine etwaige Fehlerursachenanalyse und erleichtern gleichzeitig
die Kommunikation zwischen Checkmk- und Prometheus-Nutzern.


====  Endlich wieder Kontext

Mit der angenehmste Nebeneffekt dieser Integration ist es wohl, dass Ihre
Metriken aus Prometheus in Checkmk automatisch einen sinnvollen Kontext erhalten.
Während Prometheus Ihnen beispielsweise die Menge des belegten
Hauptspeichers korrekt anzeigt, müssen Sie in Checkmk keine weiteren manuellen
Schritte gehen um zu erfahren, wie groß dabei der Anteil am insgesamt
verfügbaren Speicher ist. So banal das Beispiel sein mag, zeigt es an welchen
Stellen Checkmk das Monitoring bereits im ganz Kleinen erleichtert.


===  Exporter oder PromQL

Mit dem Erscheinen des <a href="https://blog.checkmk.com/">Feature Pack 2</a>
können Sie Prometheus in Checkmk ab der Version VERSION[1.6.0p12] integrieren. Die
Integration der wichtigsten Exporter für Prometheus wird dabei über einen
[datasource_programs#specialagents|Spezialagenten] zur Verfügung gestellt.

### SK: Hier würde ich gerne den Blog-Artikel zum FP2 verlinken den Timo gerade schreibt.

Nach der [mkps#feature_packs|Aktivierung des Erweitungspakets] für Prometheus
stehen Ihnen die folgenden Exporter zur Verfügung.

*  [check_plugins_catalog#cAdvisor|cAdvisor (Container Advisor)]
*  <a href="https://github.com/prometheus/node_exporter/blob/master/README.md">node_exporter</a>
*  <a href="https://checkmk.com/check_mk-werks.php?werk_id=10859">kube-state-metrics</a>

Sollte unter den von uns unterstützen Exportern noch nicht das richtige für Sie
dabei sein, haben erfahrene Nutzer von Prometheus auch die Möglichkeit direkt über
(CMK) selbst-definierte Abfragen an Prometheus zu richten. Dies geschieht in der
Prometheus-eigenen [monitoring_prometheus#promQL|Abfragesprache PromQL].


== Einrichten der Integration

=== Host anlegen

Da es das Konzept der Hosts in Prometheus schlicht nicht gibt, schaffen Sie zuerst
einen Ort, der die gewünschten Metriken sammelt. Dieser Host bildet die zentrale
Anlaufstelle für den Spezialagenten und verteilt die angelieferten Daten dann
später an die richtigen Hosts in Checkmk. Erzeugen Sie dazu einen neuen Host über
das gleichnamige WATO-Modul.

image::bilder/prometheus_hostname.png[]

Sollte der angegebene Hostname keiner FQDN entsprechen, geben Sie hier noch die
IP-Adresse an unter der der Prometheus-Server erreichbar ist.

Nehmen Sie alle weiteren Einstellungen Ihrer Umgebung entsprechend vor und
bestätigen Sie Ihre Auswahl über [.guihints]#Save & Finish}}.# 


=== Regel für Datasource Prometheus anlegen

Bevor Checkmk Ihre Metriken aus Prometheus finden kann, müssen Sie zuerst noch
den Spezialagenten über den Regelsatz [.guihints]#Prometheus# einrichten. Diesen finden
Sie in WATO über [.guihints]#Host & Service Parameters => DatasourcePrograms => Prometheus}}.# 
Unabhängig davon welchen Exporter Sie verwenden wollen, geben Sie unter TCP Port
number den Port an über den auch das Webfrontend Ihres Prometheus-Servers
erreichbar ist.


[#node_exporter]
==== Integration per Node Exporter

Wenn Sie nun beispielsweise die Hardware-Komponenten eines sogenannten _Scrape
Targets_ aus Prometheus integrieren möchten, nutzen Sie dafür den sogenannten
Node Exporter. Wählen Sie nun [.guihints]#Add new Scrape Target# und im sich öffnenden
Dropdown-Menü [.guihints]#Node Exporter# aus:

image::bilder/prometheus_ruleset_exporter.png[]

Desweiteren können Sie hier auswählen, welche Hardware bzw. welche
Instanzen des Betriebssystems durch den Node Exporter abgefragt werden
sollen. Die dadurch erzeugten Services benutzen dieselben Checkplugins,
wie sie auch für andere Linux-Hosts verwendet werden. Dadurch sind sie
in ihrem Verhalten identisch zu den bekannten und Sie können ohne große
Umstellung Schwellwerte konfigurieren, oder mit den Graphen arbeiten.


[#cadvisor]
==== Integration per cAdvisor

Der Exporter cAdvisor erlaubt die Überwachung von Docker-Umgebungen und liefert
dabei Metriken zu Verwendungs- und Performancedaten zurück.

Über das Auswahlmenü [.guihints]#Entity level used to create Checkmk piggyback hosts}}# 
können Sie festlegen, ob und wie die Daten aus Prometheus schon aggregiert
abgeholt werden sollen.  Ihnen stehen dabei die folgenden drei Optionen
zu Auswahl:

*  [.guihints]#Both - Display the information for both, pod and container, levels}}# 
*  [.guihints]#Container - Display the information on container level}}# 
*  [.guihints]#Pod - Display the information for pod level}}# 

Wählen Sie hierbei entweder [.guihints]#Both# oder [.guihints]#Container# aus, legen Sie
außerdem noch fest, unter welchem Namen Hosts für Ihre Container angelegt
werden. Die folgenden drei Option stehen Ihnen für die Benamung zur
Verfügung. Die Option [.guihints]#Short# ist hierbei der Standard:

*  [.guihints]#Short - Use the first 12 characters of the docker container ID}}# 
*  [.guihints]#Long - Use the full docker container ID}}# 
*  [.guihints]#Name - Use the containers' name}}# 

image::bilder/prometheus_cadvisor_names.png[]

Bitte beachten Sie, dass ihre Auswahl an dieser Stelle Auswirkungen auf das
automatische Anlegen und Löschen von Hosts entsprechend Ihrer
[monitoring_prometheus#dcd_cadvisor|dynamischen Hostkonfiguration] hat.


[#kube_state_metrics]
==== Integration per kube-state-metrics

Mit dem Exporter kube-state-metrics lassen sich Deployments, Nodes und Pods
innerhalb eines Kubernetes-Clusters abfragen. Die Mechanik ist hier weitgehen
die gleiche, wie auch für den [monitoring_prometheus#node_exporter|Node Exporter]
oder den [monitoring_prometheus#cadvisor|cAdvisor] oben
beschrieben: Sie wählen die Metriken aus, die Sie überwachen wollen. Einzig
über das Feld [.guihints]#Cluster name# können Sie individuell bestimmen, wie der
Host heißt, unter dem die Daten zu einem Cluster angezeigt werden sollen.


[#promQL]
==== Integration per PromQL

Wie bereits erwähnt ist es mit Hilfe des Spezialagenten auch möglich Ihren
Prometheus-Server über PromQL anzufragen. Geben Sie auch hier den Port an
über den Prometheus erreichbar ist und wählen Sie
[.guihints]#Service creation using PromQL queries => Addnew Service# aus. Mit dem Feld
Service name bestimmten Sie, wie der neue Service in Checkmk heißen soll.

Wählen Sie dann [.guihints]#Add new PromQL query# und legen Sie über das Feld
[.guihints]#Metric label# fest, wie die zu importierende Metrik in Checkmk heißen soll.
In das Feld [.guihints]#PromQL query# geben Sie nun Ihre Abfrage ein. Dabei ist es
wichtig, dass diese Abfrage nur *einen* Rückgabewert haben darf.

image::bilder/prometheus_ruleset_promql.png[]

In diesem Beispiel wird Prometheus nach der Anzahl der laufenden und blockierten
Prozesse gefragt. In Checkmk werden diese dann in einem Service mit dem Namen
[.guihints]#Processes# und den beiden Metriken [.guihints]#Running# und [.guihints]#Blocked# zusammengefasst.

*Wichtig:* Zurzeit ist es noch nicht möglich den auf diese Weise importierten
Metriken Schwellwerte zuzuweisen.


==== Regel dem Prometheus-Host zuweisen

Weisen Sie diese Regel explizit dem soeben angelegten Host zu und bestätigen Sie
Ihre Angaben mit [.guihints]#Save}}.# 

image::bilder/prometheus_ruleset_explicit_host.png[]


=== Service Discovery

Nachdem Sie den Spezialagenten nun konfiguriert haben, ist es Zeit, eine
[wato_hosts#services|Serviceerkennung] auf dem Prometheus-Host durchzuführen.

image::bilder/prometheus_discovery.png[]


[#dcd]
== Dynamische Hostkonfiguration

=== Generelle Konfiguration

Die Überwachung von Kubernetes Clustern ist vermutlich eine der Aufgaben, die am
häufigsten mit Prometheus bewerkstelligt wird. Um eine Integration der mitunter
sehr kurzlebigen Container, die per Kubernetes orchestriert und mit Prometheus
überwacht werden auch in Checkmk ohne großen Aufwand zu gewährleisten, bietet
sich die Einrichtung einer [dcd|dynamischen Hostkonfiguration] an. Die Daten der
einzelnen Container werden dabei als Piggyback-Daten an Checkmk weitergeleitet.

Legen Sie einfach über [.guihints]#WATO => Hosts => Dynamic config => Newconnection# eine
neue Verbindung an, wählen als Sie als Connector type [.guihints]#Piggyback data# und
legen Sie über [.guihints]#Add new element# die Bedingungen fest unter denen neue Hosts
dynamisch erstellt werden sollen.

Beachten Sie bitte auch ob es für Ihre Umgebung notwendig ist, Hosts auch wieder
dynamisch zu löschen, wenn keine Daten mehr über den Piggyback-Mechanismus bei
(CMK) ankommen. Stellen Sie die Option [.guihints]#Delete vanished hosts# entsprechend
ein.


[#dcd_cadvisor]
=== Besonderheit im Zusammenspiel mit cAdvisor

Normalerweise bekommen Container eine neue ID, wenn sie neu gestartet
werden. In Checkmk werden die Metriken des Hosts mit der alten ID nicht
automatisch auf die neue ID übertragen. Das würde in den meisten Fällen
auch gar keinen Sinn ergeben. Im Falle von Containern kann das aber durchaus
nützlich sein, wie in dem Beispiel eben gesehen: Wenn ein Container nur
neu gestartet wird, möchten Sie sehr wahrscheinlich auch die Historie nicht
verlieren. Um das zu erreichen, legen Sie die Container nicht unter ihrer ID,
sondern stattdessen unter ihrem Namen (Option [.guihints]#Name - Use the containers' name}}# 
in der [monitoring_prometheus#cadvisor|Prometheus-Regel]) an.
Auf diese Weise können Sie nicht mehr vorhandene Container dennoch
mit der Option [.guihints]#Delete vanished hosts# in der dynamischen Hostkonfiguration
löschen, ohne befürchten zu müssen, dass die Historie damit auch verloren
ist. Stattdessen wird diese -- durch den identischen Namen des Containers --
fortgeführt, auch wenn es sich um einen anderen Container handelt, der aber
denselben Namen hat.
