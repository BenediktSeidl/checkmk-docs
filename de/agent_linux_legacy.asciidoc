// -*- coding: utf-8 -*-
include::global_attr.adoc[]
= Linux überwachen im Legacy-Modus
:revdate: draft
:title: Linux überwachen im Legacy-Modus
:description: Der Linux-Agent kann im Legacy-Modus ohne Agent Controller betrieben werden, wenn er die Voraussetzungen für den verschlüsselten Pull-Modus nicht erfüllt.


{related-start}
xref:agent_linux#[Linux überwachen]
{related-end}


== Einleitung

[{image-left}]
image::linux.png[width=120]

Seit der {CMK} Version {v21} beherrscht der neue Linux-Agent mit dem *Agent Controller* den registrierten, TLS-verschlüsselten und komprimierten *Pull-Modus*.
Allerdings muss dafür der Agent Controller auf dem Host, auf dem er installiert werden soll, als Hintergrundprozess (_daemon_) vom init-System `systemd` gestartet werden.
Im Artikel xref:agent_linux#[Linux überwachen] erfahren Sie, wie Sie den Agenten mit Agent Controller installieren, konfigurieren und erweitern können.

In einigen Fällen kann der neue Agent Controller nicht verwendet werden, beispielsweise wenn kein oder ein sehr alter `systemd` installiert ist, oder Sie die Installation unter einer anderen Prozessorarchitektur als x86-64 durchführen.
Hierfür unterstützt der Linux-Agent den sogenannten *Legacy-Modus*.
//SK: "Der neue wie der alte" ist hier im Sinne von "so wie" oder "genau wie" und nicht "und" gemeint, richtig? Ich kam wegen diesem "wie" beim Lesen nicht ganz flüssig durch den Satz.
// MFS: Fixed it for you.
In diesem Modus arbeiten sowohl der "alte" (bis zur Version {v20}) als auch der neue Agent ohne Agent Controller und damit ohne Registrierung, TLS-Verschlüsselung und Komprimierung.

Dieser Artikel zeigt Ihnen, wie Sie den Linux-Agent im Legacy-Modus einrichten.
Er deckt dabei sowohl die Situation ab, dass Sie per Paketmanager installieren konnten und jetzt die Konfiguration nur abschließen oder kontrollieren müssen, als auch die Verwendung unter eher exotischen Umgebungen, die eine manuelle Installation erfordern.
Dabei werden hier nur die Aufgaben behandelt, die im Legacy-Modus anders als im Pull-Modus durchzuführen sind.

Die Themen, für die der Modus des Agenten keine Rolle spielt, können Sie im Artikel über den Linux-Agenten im Pull-Modus nachlesen:

* xref:agent_linux#disabled_sections[Sektionen deaktivieren]
* xref:agent_linux#plugins[Agent um Plugins erweitern]
* xref:agent_linux#e2e_monitoring[Einbinden von klassischen (Nagios-) Check-Plugins]
* xref:agent_linux#hw_monitoring[Hardware überwachen]

////
Der Agent besteht aus einem simplen Shellskript, das nach `/usr/bin/check_mk_agent` installiert wird und der Reihe nach *vorhandene Systembefehle* aufruft, um Daten für das Monitoring zu ermitteln.
Seine Ausgabe stellt er per `xinetd` an TCP-Port 6556 bereit oder er wird alternativ per SSH aufgerufen.
Und wenn Ihnen beides nicht gefällt, können Sie auch eigene Methoden implementieren, wie {CMK} die Daten vom Agenten bekommen soll.
////


[#install]
== Installation

=== Voraussetzungen

// SK: Ich habe mal diesen Einschub vorgenommen, wo der Superserver vorhanden sein muss. Das mag irgendwie klar sein, aber warum soll man es in den "Voraussetzungen" nicht nochmal klarstellen.
Der Legacy-Modus erfordert - auf dem zu überwachenden (Linux-)Host - einen laufenden Internet Superserver zur Portüberwachung und zum Start des Agentenskripts.
Alernativ können Sie auf einen Internet Superserver verzichten und später den Agenten-Zugriff über einen xref:ssh[SSH-Tunnel] einrichten.
// SK: Worauf bezieht sich "dies" im folgenden Satz? Mit ps überpüfe ich ja, ob ein solcher Superserver derzeit läuft und somit auch vorhanden ist.
// MFS: Fixed it.
Am einfachsten stellen Sie das Vorhandensein eines `inetd` mit dem Befehl `ps` fest:

[{shell-raw}]
----
{c-root} ps ax  | grep inetd
 1913 ?        Ss     0:00 /usr/sbin/xinetd -pidfile /run/xinetd.pid -stayalive -inetd_compat -inetd_ipv6
----

Am ausgeführten Prozess erkennen Sie, ob es sich um den moderneren `xinetd` oder einen der anderen Internet Superserver (GNU-Inetutils, OpenBSD-Inetd, Busybox-Inetd) handelt.

Ist kein `inetd` aktiv, stellen Sie _vor_ der Installation des {CMK} Agenten sicher, dass `xinetd` auf dem System vorhanden ist.
Für diesen bringt der {CMK} Agent eine fertig vorbereitete Konfiguration mit.
Andere Superserver können verbleiben, erfordern aber eine xref:otherinetd[manuelle Konfiguration].
// TK: ... die wir auch beschreiben? oder nur teilweise?
// MFS: Ja, siehe #otherinetd
// SK: Ich habe mich kurz gefragt, ob ein Link zu #otherinetd hier ablenken würde. Ein wenig vermutlich schon, aber ich würde den Link wohl trotzdem - Achtung - links liegen lassen. Für alle die manuell konfigurieren müssen, wäre ein Link hilfreich.

Falls bislang kein Internet Superserver konfiguriert ist, installieren Sie das Paket `xinetd` vor der Installation des Agenten, dies erspart Ihnen einen Konfigurationsschritt.
// TK: Also keine Beschreibung, wie xinetd zu installieren ist?
// MFS: Nope, wir begeben uns gerade aufs Territorium von Exotendistris, da sollten die Anwender schon wissen, wie Paketmanagement funktioniert.
// SK: Da bin ich bei MFS. Ein mehr oder weniger gängier Superserver ist einfach eine Voraussetzung für die Nutzung unseres Agenten. Fertig.
// SK: ABER: M.E. müssen wir hier auch erstmalig darauf hinweisen, dass es auch Szenarien gibt, die ohne xinetd auskommen. So einen Hinweis gibt es am Ende von 2.3. Wenn jetzt jemand den Artikel durchgeht und erst einen xinted installiert, nur um  ihn dann wieder "abzuklemmen", weil er nicht benötigt wird, freut sich vermutlich nicht sehr darüber.
// MFS: Ganz oben ein Satz hinzugefügt.

=== Installation per RPM/DEB-Paket

Der Agent kann in verschiedenen Modi arbeiten, aber das Software-Paket, mit dem er installiert wird, ist stets das gleiche.

// SK: Der Link geht zwar derzeit nach 3.2, aber das Kapitel "Installation" im verlinkten Artikel ist lang. Wie weiß der Nutzer, wo er anfangen und wo er im anderen Artikel wieder aufhören muss?
// SK: Könnte man den Abschnitt aus agent_linux nicht copy-pasten, statt den Nutzer hier auf die Reise zu schicken? Der Pflegeaufwand für uns ist sicherlich größer aber für den Leser wäre es womöglich leichter.
// MFS: Nicht mal C&P, sondern das Include splitten in Installation x.3-x.5 und Rest x.3-x.5 dann hier einbinden, beide Teile nur in den Artikel zum neuen Agenten.
Das RPM/DEB-Paket installieren Sie dann genauso wie es im xref:agent_linux#download[Installationskapitel] für den Agenten im Pull-Modus beschrieben ist.

Nach der Installation ist der Agent sofort aktiv und kann auf TCP Port 6556 abgefragt werden.


[#manual]
=== Manuelle Installation

// SK: Was mach das cee-only hier bzw. wo ist die ganze Anleitung für die manuelle Installation aus dem alten Artikel hin? -> https://docs.checkmk.com/latest/de/agent_linux.html#manual
// SK: Die manuelle Installation sollte ja auch weiterhin für die Raw beschrieben werden.
// MFS: Das gibt ein Blockkommentar!
////
Wir sollten abwarten und die Relevanz des Themas später beurteilen, evtl. zusammen mit Forennutzern. Warum da nicht einfach fragen, wie weit Exotendistris oder OSless containers verbreitet sind? Denn dieses Problem betrifft nur Nutzer, die sowohl:

* CRE verwenden
* Eine Distribution nutzen, die NICHT auf Debian/Redhat/Suse/Arch basiert (Arch hat ein ordentlich aktualisiertes Repo für den Agenten)

Unabhängig davon würde ich gerne in 6 einen neuen Artikel "Der Linux-Agent für Paket-Maintainer" erstellen, der auch beschreibt, wie ein Startup-Script für den Agent-Controller aussehen kann, das für verschiedene Init-Systeme angepasst werden kann und vielleicht sogar, wie man den Agent Controller kompiliert, weil man fancy aarch64 Server im Einsatz hat.

Dazu noch Hinweise auf das OpenWRT Agenten-Skript, das bei Umgebungen mit ash als Standardshell (Embedded, Alpine Linux, viele Yocto Targets) sinnvoller ist, als das Linux-Skript.  

Schlußendlich könnte man dann Leser, die es komplett zu Fuß machen wollen, auf diesen Artikel verweisen. Begründung: Was Du vorhast, machen sonst eher Nutzer mit tausenden Custom-Images und nicht Bastler mit einem One-Off-System.
////
{cee-only} Auch wenn der {CMK} Server nur Enterprise-Linux-Distributionen unterstützt, die deren Hersteller noch unterstützt, ist der {CMK} _Agent_ hier viel genügsamer.
Er unterstützt _jede_ Linux-Distribution -- selbst uralte „Dinosaurier“, auf denen noch ein Kernel der Version 2.4 läuft!
Es kann dann zwar sein, dass nicht alle Plugins im Agenten korrekt laufen, aber die grundsätzliche Überwachung wird funktionieren.
Die manuelle Installation des Agenten ist zwar selten nötig, aber auch nicht sehr schwierig.

Sie benötigen den Linux-Agenten im TGZ-Archivformat, den Sie in den {EE} im Setup-Menü über [.guihint]#Agents > Windows, Linux, Solaris, AIX# herunterladen können.
Das TGZ-Archiv enthält die komplette Verzeichnisstruktur des Linux-Agenten zum Entpacken des Agenten im Wurzelverzeichnis des überwachten Hosts.

// MFS: Hier muss Screenshot Download des Tarballs hin!
// SK: @MFS meinst du den folgenden Screenshot? Kann dein Kommentar damit weg?
// MFS: Nein, falls wir in der Raw doch noch den Tarball bekommen, sollte der Screenshot ausgetauscht werden.
image::agent_linux_legacy_agents.png[]

Damit alle Pfade stimmen, ist der Parameter `-C` ("change directory") beim Entpacken unerlässlich.
Wir verwenden zudem `--no-overwrite-dir`, damit Berechtigungen von bereits vorhandenen Verzeichnissen nicht verändert werden:
// MFS: Evtl. Rücksprache mit Entwicklern wegen der Rechte im Tarball, erstmal --no-overwrite-dir

[{shell-raw}]
----
{c-root} tar -C / --no-overwrite-dir -xvf /tmp/check-mk-agent_2.1.0b1.tar.gz
----

Wenn Sie alles richtig gemacht haben, muss der Agent jetzt einfach als Befehl ausführbar sein und seine typische Ausgabe erzeugen.
// Das geht auch, wenn Sie nicht in `/usr/local/bin` stehen.
Das `|{nbsp}head` schneidet hier alles ab der 11. Zeile weg:

[{shell-raw}]
----
{c-root} check_mk_agent | head
<<<check_mk>>>
Version: 2.1.0b1
AgentOS: linux
Hostname: mycmkserver
AgentDirectory: /etc/check_mk
DataDirectory: /var/lib/check_mk_agent
SpoolDirectory: /var/lib/check_mk_agent/spool
PluginsDirectory: /usr/lib/check_mk_agent/plugins
LocalDirectory: /usr/lib/check_mk_agent/local
<<<df>>>
----

// SK: Wieso /usr/local/bin? War das mal das Default-Verzeichnis? Könnte man hier nicht mit `which check_mk_agent` nachschauen, welcher Agent vermutlich statt dem gerade installierten ausgeführt wurde?
// MFS: Ja, /usr/local/bin war mal Default. Which wäre ein zusätzlicher Schritt, der nur für wenige Nutzer relevant ist.
// SK: Allerdings frage ich mich, ob das wirklich hier stehen muss. Kann man das nicht in Test und Fehlerdiagnose ansprechen?
// MFS: Man könnte, aber ist es nicht sinnvoller, das Pfadproblem gleich hier abzufangen?
Wird hier eine Versionsnummer kleiner als {v21} ausgegeben, haben Sie vermutlich noch eine ältere Version des Agentenskripts als `/usr/local/bin/check_mk_agent` installiert.
Verschieben Sie dieses alte Skript, oder benennen Sie es um, beispielsweise indem Sie `.bak` an den Dateinamen anhängen.

Falls Sie den Agenten grundsätzlich über SSH abrufen möchten, brauchen Sie keine Konfiguration für den `xinetd` und benötigen nur noch die SSH-Konfiguration.
Wie das geht, beschreiben wir xref:ssh[weiter unten.]

// SK: An dieser Stelle fällt erstmalig auf, dass die Struktur des Artikels seltsam ist. Die Konfiguration von (x)inetd ist ein eigenes Kapitel und ssh folgt dann als Unterkapitel nach einem Kapitel namens "Test und Fehlerdiagnose".
// MFS: Die Hierarchisierung wurde von agent_linux übernommen und sollte IMHO konsistent dazu bleiben.

[#inetdconfig]
== (x)inetd-Konfiguration

[#xinetd]
=== xinetd

Für die Konfiguration eines bereits vorhandenen `xinetd`, der das Verzeichnis `/etc/xinetd.d/` zur Konfiguration verwendet, liegt im entpackten TGZ-Archiv ein Skript bei, welches in zwei Schritten zuerst die Konfiguration installiert und dann den `xinetd` die neue Konfiguration einlesen lässt.
Das Skript müssen Sie mit vollem Pfad aufrufen:

[{shell-raw}]
----
{c-root} /var/lib/cmk-agent/scripts/super-server/1_xinetd/setup deploy
{c-root} /var/lib/cmk-agent/scripts/super-server/1_xinetd/setup trigger
----

Auch hier gilt:
War bereits eine ältere Version des {CMK} Agenten installiert, prüfen Sie die Pfade, welche in der Datei `/etc/xinetd.d/check-mk-agent` eingetragen sind.
// SK: "Nun"? Im Artikel agent_linux der 1.6.0 wird /usr/bin bereits in der Einleitung beschrieben: https://docs.checkmk.com/1.6.0/de/agent_linux.html
// SK: Das .deb aus einer 1.5.0 installiert den Agenten auch bereits nach /usr/bin.
// MFS: Ja, aber die alte manuelle Installation packte das nackige Agentenskript nach /usr/local/bin und legte dann ein paar Dateien drumherum an…
Der Installationsordner des Agentenskripts ist nun `/usr/bin`.
Falls Ihr `xinetd` das alte Konfigurationsschema mit lediglich einer großen `/etc/xinetd.conf` nutzt, übertragen Sie die Beispielkonfiguration aus `/etc/check_mk/xinetd-service-template.cfg` in die `/etc/xinetd.conf`.

// MFS: Weiter oben
// Die Konfiguration per `xinetd` ermöglicht einen Zugriff auf die Agentendaten via TCP Port 6556 und ist der Standardweg im lokalen Netzwerk.
// Installieren Sie dazu das Paket `xinetd`.

[#otherinetd]
=== Andere inetd

Prüfen Sie zunächst, ob Ihre `/etc/services` bereits einen Eintrag für Port 6556 enthält:

[{shell}]
----
{c-root} *grep 6556/ /etc/services*
----

Ist dies nicht der Fall, muss {CMK} als Dienst bekannt gemacht werden.
Fügen Sie dafür folgende Zeile hinzu, die Schreibweise entspricht dabei exakt der in der link:https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml?search=checkmk-agent[IANA-Tabelle hinterlegten^] mit nur einem Bindestrich:
// TK: Link zu https://de.wikipedia.org/wiki/Liste_der_standardisierten_Ports ?
// MFS: Link zur IANA-Liste hinzugefügt

./etc/services
[{file}]
----
checkmk-agent        6556/tcp   #Checkmk monitoring agent
----

Das Format der Konfigurationsdatei `/etc/inetd.conf` unterscheidet sich zwischen den verschiedenen Varianten.
Entnehmen Sie den Kommentaren in der Konfigurationsdatei und der Manualpage (`man 5 inetd.conf`) das zu Ihrem `inetd` passende Format.
Es folgt die Konfiguration passend zum `openbsd-inetd` mit zwei Zeilen für IPv4- und IPv6-Unterstützung.
Auch hier gilt es, die korrekte Schreibweise zu beachten:

./etc/inetd.conf
[{file}]
----
checkmk-agent stream tcp  nowait root /usr/bin/check_mk_agent
checkmk-agent stream tcp6 nowait root /usr/bin/check_mk_agent
----

Nach Änderung der Konfigurationsdatei starten Sie den `inetd` neu, bspw. mit:

[{shell}]
----
{c-root} */etc/init.d/inetd restart*
----

Je nach verwendetem init-System und installiertem Superserver kann dieses Kommando abweichen.
// TK: Ist hier nicht init-System und Superserver identisch?
// SK: Nein. Die Namen init und inet liegen zwar nah beieinander, haben aber nichts miteinander zu tun.


// SK: Ich verstehe, dass ihr hier nicht duplizieren wolltet, aber das Kapitel "Test und Fehlerdiagnose" in agent_linux enthält halt auch vieles zum Agent Controller.
// SK: Das führt zu Verwirrung, gerade bei denen die am meisten auf das Handbuch angewiesen sind. Ich plädiere hier erneut für copy-paste oder includes.
// SK: Außerdem in ich dafür solche Kapitel *immer* ans Ende der Artikel zu stellen. Da könnte man dann auch in Zukunft ganz elegant in die KB linken.
// MFS: Evtl. wie oben vorgeschlagen das Include-File so splitten, dass eines davon in beide Artikel eingebunden werden kann. Duplicate Content ist nur dann ein Problem, wenn sich zwei Artikel zu 90% überschneiden.

[#testing]
== Test und Fehlerdiagnose

Zum Testen der Verbindung zwischen Agent und {CMK} Server gehen Sie prinzipiell genauso vor wie im Artikel xref:agent_linux#test[Linux überwachen] beschrieben.
Allerdings können Sie sich dabei den Test zum Aufruf des Agent Controllers sparen, da dieser im Legacy-Modus nicht vorhanden ist.


[#security]
== Absicherung

// SK: Meines Erachtens müssen wir in der Vorüberlegung wiederum auf den neuen Agenten verweisen. Der neue Agent mit Controller und Receiver muss als der Königsweg für eine einfache und sichere Übertragung beschrieben werden.
// SK: Beim Lesen der folgenden Vorüberlegung könnte man ansonsten den Eindruck bekommen, dass Controller/Receiver gar nicht so wichtig ist.


=== Vorüberlegung

Sicherheit ist ein wichtiges Kriterium für jegliche Software, hier darf Monitoring keine Ausnahme machen.
Da der Monitoring-Agent auf jedem überwachten Server installiert wird, hätte hier ein Sicherheitsproblem besonders gravierende Auswirkungen.

Deswegen wurde schon beim Design von {CMK} auf Sicherheit Wert gelegt und es gilt seit den ersten Tagen von {CMK} ein eherner Grundsatz:
_Der Agent liest keine Daten vom Netzwerk. Punkt._
Somit ist mit Sicherheit ausgeschlossen, dass ein Angreifer über den Überwachungsport 6556 irgendwelche Befehle oder Skriptbestandteile einschleusen kann.

Doch, selbst wenn ein Angreifer keine Befehle ausführen kann:
Die Monitoring-Daten des Agenten könnten für ihn bereits nützlich sein, denn sie enthalten unter anderem eine Liste von allen auf dem System laufenden Prozessen, Hinweise auf die Betriebssystemversion und häufig noch ausstehende Updates.

Aus diesem Grund empfehlen wir in jedem Fall die Absicherung der Datenübertragung.
Wenn die Verwendung des seit {v21} vorhandenen Agent Controllers mit TLS-Verschlüsselung nicht möglich ist, haben Sie die folgenden Möglichkeiten, Zugriff und Transport abzusichern:

* Das niedrigste Schutzniveau bietet die IP-Beschränkung via `xinetd` Konfiguration: Daten werden dennoch im Klartext übertragen, lediglich die direkte Anforderung durch einen potentiellen Angreifer schlägt fehl.
* Ein etwas höheres Schutzniveau bietet die symetrische Verschlüsselung. Da hier derselbe Schlüssel für Ver- und Entschlüsselung verwendet wird, kann ein Angreifer, der ein Update-Paket abgefangen hat oder Zugriff auf einen Host im Monitoring erlangt hat, die Agentenkommunikation aller so verschlüsselnden Hosts mitlesen.
* Ein sehr gutes Schutzniveau bietet die Übertragung der Agentenausgabe über einen SSH-Tunnel, hier kommt Public-Key-Kryptographie zum Einsatz: Ein Angreifer kann weder mit einem abgefangenen öffentlichen Schlüssel noch mit mitgeschnittenen Kommunikationsinhalten etwas anfangen.

Die ersten beiden Möglichkeiten werden hier vor allem aus Gründen der Kompatibilität zu vorhandenen {CMK}-Umgebungen beschrieben.
Wo immer möglich, empfehlen wir die Nutzung des SSH-Tunnels.

// Das allein liefert bereits ein so hohes Sicherheitsniveau, dass die meisten Anwender _im LAN_ auf weitere Maßnahmen verzichten. 
// Kann das überwachte System nur über eine unsichere Internetverbindung erreicht werden, gelten natürlich ganz andere Maßstäbe und hier ist sicher eine Verschlüsselung mit SSH die erste Wahl.

// Der {CMK} Agent verfügt ferner über eine _eingebaute Verschlüsselung_, welche einen guten Kompromiss aus Sicherheit und Aufwand darstellt.
// Im Folgenden zeigen wir Ihnen alle Möglichkeiten zur Absicherung im Detail.
// FIXME!
// MFS: Leider gaukelt die eingebaute Verschlüsselung Sicherheit vor, die nicht immer gegeben ist. Sie ist symetrisch, jeder, der ein Agentenpaket mit dem Schlüssel in die Finger bekommt, kann entschlüsseln!

[#ssh]
=== Aufruf über SSH

Die beste Sicherheit beim Aufruf des {CMK} Agenten bietet dessen Aufruf über eine Secure Shell Sitzung.

// MFS: Entfernt, da SSH immer angebracht ist. OpenSSH als Implementierung interessiert uns nicht, auch Dropbear ist OK und Windows-SSH ist eh OpenSSH…
////
-- bei Linux in Form der Implementierung _OpenSSH_.
Diese Methode ist angebracht bei:

* Überwachung von Linux-Servern, die nur über das Internet erreichbar sind.
* Überwachung von Rechnern in einer DMZ.
* In ähnlichen Situationen, in denen eine TCP-Verbindung vom {CMK} Server auf den Agenten überhaupt möglich ist.
////

Das Einrichten geschieht in folgenden Schritten:

. Erstellen Sie ein SSH-Schlüsselpaar speziell für diesen Zweck.
. Erlauben Sie auf den Zielsystemen den Zugriff auf den Agenten mittels dieses Schlüssels.
. Klemmen Sie den Zugriff über `xinetd` ab.
. Konfigurieren Sie den {CMK} Server so, dass er anstelle der TCP-Verbindung auf Port 6556 SSH verwendet.

Und das Ganze jetzt Schritt für Schritt mit allen notwendigen Details:


==== SSH-Schlüsselpaar erstellen

// SK: Bitte noch den Hinweis einfügen, dass die Eingabe des Dateinamens (Enter file in which to save the key) optional ist und man nur zu den im weiteren benutzen Dateinamen kommt, wenn man hier auch wirklich keinen Dateinamen an- bzw. vorgibt.

SSH arbeitet mit einer „Public-Key-Authentifizierung“.
Dazu erzeugt man zunächst ein Paar von aufeinander abgestimmten Schlüsseln, bei denen einer öffentlich (public) ist und einer geheim (private).
Bei der Wahl der Algorithmen können Sie wählen zwischen `rsa`, `ecdsa` oder `ed25519`.
In dem nachfolgenden Beispiel nutzen Sie den Befehl `ssh-keygen -t ed25519` als Instanzbenutzer:

[{shell-raw}]
----
{c-omd} ssh-keygen -t ed25519
Generating public/private ed25519 key pair.
Enter file in which to save the key (/omd/sites/mysite/.ssh/id_ed25519):
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in /omd/sites/mysite/.ssh/id_ed25519.
Your public key has been saved in /omd/sites/mysite/.ssh/id_ed25519.pub.
The key fingerprint is:
cc:87:34:d2:ed:87:ed:f7:1b:ec:58:1f:7c:23:00:e2 mysite@mycmkserver
The key's randomart image is:
+--[ED25519  256--+
|                 |
|       . .       |
|      ..+..      |
|      .=.+.o     |
|       ES +.o    |
|         . o. o  |
|            ...B.|
|             .=.*|
|             . o+|
+-----------------+
----

Lassen Sie den Dateinamen leer, um den vorgeschlagenen Dateinamen zu verwenden.
Selbstverständlich können Sie einen anderen Pfad angeben, beispielsweise wenn Sie mit xref:multiplekeys[verschiedenen Schlüsseln für verschiedene Hosts] arbeiten wollen.

*Wichtig*: Geben Sie *keine* Passphrase an!
Es nützt Ihnen nichts, die Datei mit dem geheimen Schlüssel zu verschlüsseln.
Denn Sie möchten ja sicher nicht jedes Mal beim Start des {CMK} Servers die Passphrase eingeben müssen...

Das Ergebnis sind zwei Dateien im Verzeichnis `.ssh`:

[{shell}]
----
{c-omd} ll .ssh
total 8
-rw------- 1 mysite mysite 1679 Feb 20 14:18 id_ed25519
-rw-r--r-- 1 mysite mysite  398 Feb 20 14:18 id_ed25519.pub
----

Der private Schlüssel heißt `id_ed25519` und ist nur für den Instanzbenutzer lesbar (`-rw-------`) -- und das ist auch gut so!
Der öffentliche Schlüssel `id_ed25519.pub` sieht etwa so aus:

[{shell}]
----
{c-omd} cat .ssh/id_ed25519.pub
ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIGb6AaqRPlbEmDnBkeIW3Q6Emb5lr2QEbWEQLmA5pb48 mysite@mycmkserver
----


==== Zugriff per SSH erlauben

Der nächste Schritt muss jetzt auf (je-)dem per SSH überwachten Linux-Server stattfinden.
Loggen Sie sich dort als `root` ein und legen Sie in dessen Home-Verzeichnis (`/root`) das Unterverzeichnis `.ssh` an, falls es das nicht bereits gibt.
Mit dem folgenden Befehl werden die Zugriffsrechte gleich korrekt auf 700 gesetzt:

[{shell}]
----
{c-root} mkdir -m 700 /root/.ssh
----

Öffnen Sie jetzt die Datei `authorized_keys` mit einem (konsolenbasierten) Texteditor Ihrer Wahl.
Falls die Datei nicht existiert, wird sie der Editor automatisch anlegen:

[{shell}]
----
{c-root} vim /root/.ssh/authorized_keys
----

Kopieren Sie jetzt den Inhalt der öffentlichen Schlüssel in diese Datei.
Das geht z.B. mit der Maus und Copy & Paste.
Seien Sie genau!
Jedes Leerzeichen zählt.
Achten Sie auch darauf, dass *nirgendwo zwei* Leerzeichen hintereinander stehen.
Und: Das ganze ist *eine Zeile!*
Wenn die Datei schon existiert, dann hängen Sie einfach unten eine neue Zeile an.


==== Zugriff auf die Ausführung des Agenten beschränken

Was jetzt kommt, ist sehr wichtig!
Der SSH-Schlüssel soll _ausschließlich_ zur Ausführung des Agenten dienen.
SSH bietet so etwas unter dem Namen _Command restriction_ an.
Dazu setzen Sie den Text `command="/usr/bin/check_mk_agent"` an den Anfang der Zeile, die Sie gerade erzeugt haben -- mit *einem* Leerzeichen vom Rest getrennt.
Das sieht dann etwa so aus:

./root/.ssh/authorized_keys
[{file}]
----
command="/usr/bin/check_mk_agent" ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIGb6AaqRPlbEmDnBkeIW3Q6Emb5lr2QEbWEQLmA5pb48 mysite@mycmkserver
----

Speichern Sie die Datei, kontrollieren Sie die Rechte.
Diese *müssen* auf `600` gesetzt sein:

[{shell}]
----
{c-root} chmod 600 /root/.ssh/authorized_keys
{c-root} ll /root/.ssh/authorized_keys
#-rw-------# 1 root root 1304 Feb 20 14:36 authorized_keys
----

Testen Sie jetzt einmalig den Zugriff auf den Agenten per SSH.
Beim ersten Mal müssen Sie den Fingerprint des Schlüssels mit der Eingabe von `yes` bestätigen.
Erst danach können die Zugriffe im Hintergrund durch {CMK} erfolgen:

[{shell-raw}]
----
{c-omd} ssh root@myhost123
The authenticity of host 'localhost (127.0.0.1)' can't be established.
ECDSA key fingerprint is 55:34:f9:dd:2b:db:a7:fc:5d:4c:9d:37:28:f7:69:62.
Are you sure you want to continue connecting (yes/no)? yes
<<<check_mk>>>
Version: 2.1.0b1
AgentOS: linux
Hostname: myhost123
AgentDirectory: /etc/check_mk
DataDirectory: /var/lib/check_mk_agent
SpoolDirectory: /var/lib/check_mk_agent/spool
PluginsDirectory: /usr/lib/check_mk_agent/plugins
LocalDirectory: /usr/lib/check_mk_agent/local
<<<df>>>
----

Die Abfrage nach dem `key fingerprint` kommt übrigens nur beim ersten Mal.
Wenn es nicht klappt, überprüfen Sie bitte:

* Ist der SSH-Server auf dem Zielsystem überhaupt installiert?
* Haben die genannten Dateien und Verzeichnisse die richtigen Berechtigungen?
* Haben Sie die Syntax von `authorized_keys` korrekt getippt?
* Haben Sie dort den richtigen öffentlichen Schlüssel eingetragen?
* Haben Sie sich als der richtige Benutzer eingeloggt (`root@...`)?
* Haben Sie an das `command="..."` gedacht?

Bei sehr alten Zielsystemen kann es zudem vorkommen, dass Schlüssel mit elliptischen Kurven (ed25519 und ecdsa) nicht bekannt sind.
Erzeugen Sie in diesem Fall zusätzlich einen RSA-Schlüssel und tragen Sie auch diesen in die `authorized_keys` ein.
SSH wird für die Verbindung dann automatisch den stärksten bekannten Schlüssel verwenden.

// SK: Generelles zum Abschnitt "xinetd abklemmen¨: Was ist denn, wenn ich - aus Gründen - ssh nutzen will oder muss, obwohl ich über systemd verfüge? Dann kann ich lange versuchen den xinetd abzuschalten.
// SK: Den muss es ja gar nicht zwangsläufig geben. Stattdessen müsste ich dann den check_mk.socket per systemctl disablen.
// SK: Interessant könnte auch sein, dass "Save & go to connection tests" bereits die Regel "Individual program call instead of agent access" berücksichtigt.

==== Zugriff über xinetd abklemmen

// SK: Hier könnte der geneigte Leser inzwischen vergessen haben, wo diese Änderung vorzunehmen ist. Nacher macht jemand den xinetd für den Agenten auf dem Checkmk Server aus...
// MFS: Guter Punkt!

Das ganze Einrichten von SSH nützt nichts, wenn der Zugriff auf Port 6556 des Hosts im Monitoring nach wie vor möglich ist.
// SK: "Setzen Sie den Dienst auf disabled"... Tatsächlich muss man in der Config-Datei den Wert von disable auf "yes" ändern. Im Code unten sieht man das zwar, aber die Umschreibung hier ist irreführend.
Um den zu schließen, deaktivieren Sie den xinetd-Dienst von {CMK}, indem Sie den Wert von `disabled` auf `yes` setzen.
Löschen Sie _nicht_ die ganze Konfigurationsdatei – diese würde beim nächsten Agenten-Update sonst wieder auftauchen!

// SK: Die Datei scheint seit mindestens 2.0.0 nur noch check_mk zu heißen.
// MFS: Nope. In 2.1.0, Installation aus dem .deb (Devuan) heisst sie so…

Das Deaktivieren führen Sie in der Datei `/etc/xinetd.d/check-mk-agent` durch (bei Systemen mit älterer Agenten-Installation heisst die Datei möglicherweise `/etc/xinetd.d/check_mk`):

./etc/xinetd.d/check-mk-agent
[{file}]
----
service check_mk
{
        type           = UNLISTED
        port           = 6556
        socket_type    = stream
        protocol       = tcp
        wait           = no
        user           = root
        server         = /usr/bin/check_mk_agent
        disable        = yes
}
----

Danach starten Sie xinetd neu:

[{shell}]
----
{c-root} /etc/init.d/xinetd restart
----

// MFS: Absoluter, alter Grenzfall, darüber muss ich nachdenken… Erstmal auskommentiert drinlassen.
// Die Deinstallation von xinetd ist natürlich auch möglich -- aber dann wird sich der {CMK} Agent beim nächsten Update unter Umständen wieder über systemd aktivieren!

Vergessen Sie auf keinen Fall einen abschließenden Test.
Eine Verbindung auf Port 6556 darf jetzt nicht mehr möglich sein:

[{shell}]
----
{c-omd} telnet myhost123 6556
Trying 10.118.15.23...
telnet: Unable to connect to remote host: Connection refused
----

Sollte Port 6556 noch erreichbar sein, finden Sie mit einem der Befehle `sockstat`, `netstat` oder `lsof` zunächst heraus, wer am Port lauscht:

[{shell-raw}]
----
{c-root} lsof | grep '6556.*LISTEN'
systemd       1                   root   87u     IPv6              14158        0t0        TCP *:6556 (LISTEN)
----

Hier steht in der ersten Spalte, welcher Prozess den Port belegt, je nach Update-Historie kommen zwei Programme in Frage:
Ist dies `inetd`, passen Sie die Konfigurationsdatei `/etc/inetd.conf` an und starten den Prozess dann neu.
Ist es `systemd`, müssen Sie jetzt den exakten Namen der Konfiguration ermitteln, die den Socket bereitstellt:

[{shell-raw}]
----
{c-root} systemctl list-units | grep 'check.*mk.*socket'
  check-mk-agent.socket                                           loaded active listening CheckMK Agent Socket
----

Nun können Sie den Dienst zunächst stoppen und dann deaktivieren:

[{shell-raw}]
----
{c-root} systemctl stop check-mk-agent.socket
{c-root} systemctl disable check-mk-agent.socket
Removed /etc/systemd/system/sockets.target.wants/check-mk-agent.socket.
----

Nun darf kein Zugriff auf Port 6556 mehr möglich sein.

[#multiplekeys]
==== Zugriff von {CMK} auf SSH umstellen

Das Zielsystem ist vorbereitet.
Jetzt fehlt nur noch die Konfiguration von {CMK} selbst.
Das geschieht über den Regelsatz [.guihint]#Setup > Agents > Other integrations> Custom integrations > Individual program call instead of agent access#.
Erstellen Sie hier für die betroffenen Hosts eine Regel und tragen Sie als Befehl `ssh -T root@$HOSTADDRESS$` ein:

.Der Aufruf des Agenten über SSH erfolgt per Regel
image::agent_linux_rule_ssh_key.png[alt=Regel zum Aufruf des Agenten über SSH."]

// SK: Wie oben bereits angemerkt: Statt cmk -d/D kann auch der Connection Test in der GUI verwendet werden, um zu sehen, ob der Agent Output ankommt.

Nach einem Speichern und einem xref:glossar#activate_changes[Aktivieren der Änderungen] sollte alles funktionieren!
Sie können in der GUI unter [.guihint]#Setup > Hosts > Properties of host > Test connection to host# mit dem Button #[.guihint]Run tests# den Verbindungstest durchführen.
Im Monitoring ist nun der Dienst _Check-MK Agent_ mit dem Hinweis _Transport via SSH_ versehen.
Zur weiteren Diagnose bieten sich die Befehle `cmk -D` und `cmk -d` an, die im xref:cmk_commandline#cmk[Artikel über die Kommandozeile] erklärt werden.

[#multiplekeys]
==== Mehrere SSH-Schlüssel

Sie können auch mit mehr als einem SSH-Schlüssel arbeiten.
Legen Sie die Schlüssel in einem beliebigen Verzeichnis ab.
In der Regel [.guihint]#Individual program call instead of agent access# müssen Sie den Pfad zum jeweiligen privaten Schlüssel dann mit der Option `-i` angeben.
Verwenden Sie hier am besten `$OMD_ROOT` als Ersatz für den Pfad zum Instanzverzeichnis (`/omd/sites/mysite`).
Der vollständige Befehl könnte dann `ssh -i $OMD_ROOT/.ssh/my_key -T root@$HOSTADDRESS$` lauten und damit wäre die Konfiguration auch in einer Instanz mit einem anderen Namen lauffähig:

.Um mehrere SSH-Schlüssel zu verwenden, muss das Kommando in der Regel erweitert werden
image::agent_linux_rule_multiple_ssh_keys.png[alt="Regel zum Aufruf des Agenten mit mehreren SSH-Schlüsseln."]

Sie können so für verschiedene Gruppen von Hosts verschiedene SSH-Schlüssel verwenden, indem Sie mehrere unterschiedliche Regeln verwenden.

// SK: Ich würde bevorzugen solche Dinge ("übliche Felermeldungen") immer und überall in einem Kaptiel am Ende des Artikels zu beschreiben. Aber gut... kann man auch so lassen.

==== Übliche Fehlermeldungen beim Umgang mit SSH

Wenn Sie den {CMK} Agenten über SSH abrufen möchten, kann es mitunter vorkommen, dass eben dieser Abruf nicht klappt und der Service [.guihint]#Check_MK# auf Ihrem Host in den Zustand {CRIT} wechselt.
Diese Fehlermeldungen beginnen dann häufig mit `Agent exited with code 255`.

Informationen zur Behebung solcher Fehler, können Sie in dem link:https://kb.checkmk.com/display/KB/Executing+the+Linux+agent+over+ssh[entsprechenden Artikel in unserer Wissensdatenbank^] finden.


// MFS: Wird das bald deprecated? Dann nehmen wir es raus…
// SK: Dass diese Geschichte bald deprecated wird, ist eigentlich nur Wasser auf meine oben gebauten Mühlen -> ssh und xinetd als gleichwertige Methoden darstellen und Kapitel 5 auflösen.
[#encryption]
=== Eingebaute (symmetrische) Verschlüsselung

Der {CMK} Agent kann seine Daten ohne Zusatzmittel selbst verschlüsseln.
Dies ist streng genommen kein Ersatz für eine Zugangskontrolle.
Da aber ein Angreifer ja keine Befehle senden und mit verschlüsselten Ausgabedaten nichts anfangen kann, kommt es einer solchen schon sehr nahe.

Der Aufwand für die Verwendung der Verschlüsselung und die nötige zusätzliche CPU-Last sind beide geringer, als bei der oben beschriebenen Methode mit SSH, welche wir aber nach wie vor bei der Übertragung über das Internet empfehlen.

Die Verschlüsselung braucht natürlich sowohl auf dem Agenten als auch auf dem Server eine passende Konfiguration.
Diese kann entweder von Hand erstellt werden ({RE}) oder mit der Agentenbäckerei ({EE}).


==== Aufsetzen ohne Agentenbäckerei

Auch ohne Agentenbäckerei geht der erste Schritt wieder über das [.guihint]#Setup#-Menü und das Anlegen einer Regel im Regelsatz [.guihint]#Setup > Agents > Access to agents > Checkmk agent > Encryption (Linux, Windows)#.
Die Regel soll auf alle Hosts greifen, für die Sie Verschlüsselung einsetzen möchten.
SNMP-Hosts ignorieren diese Einstellung, daher müssen Sie sie nicht explizit ausschließen.

.Auch die eingebaute Verschlüsselung wird über eine Regel eingerichtet
image::agent_linux_encrypt.png[alt="Regel zur Konfiguration der eingebauten Verschlüsselung."]

Wichtig ist die Einstellung für [.guihint]#Encryption for Agent#.
Solange Sie die Regel auf dem Default [.guihint]#Disable# lassen, bleibt natürlich alles beim Alten.
Sie haben also die Wahl zwischen:

* [.guihint]#Enable#: Verschlüsselung wird aktiviert, aber Daten von Agenten ohne Verschlüsselung werden weiter akzeptiert.
* [.guihint]#Enforce#: Verschlüsselung wird aktiviert, nur noch verschlüsselte Daten werden akzeptiert.

Sinnvoll ist es, zunächst mit [.guihint]#Enable# zu beginnen.
Sobald Sie meinen, dass alle Agenten auf Verschlüsselung umgestellt sind, stellen Sie auf [.guihint]#Enforce#, um dadurch Hosts zu finden, die noch Daten im Klartext senden.

Die Verschlüsselung funktioniert mit einem gemeinsamen Passwort, das Sie hier angeben und sowohl auf dem {CMK} Server als auch auf dem Agenten im Klartext gespeichert werden muss (_shared secret_).
Wählen Sie ein zufälliges Passwort aus und halten Sie es parat für den zweiten Schritt: die Konfiguration des Agenten.

Dort erzeugen Sie die Datei `/etc/check_mk/encryption.cfg` mit folgendem Inhalt:

./etc/check_mk/encryption.cfg
[{file}]
----
ENCRYPTED=yes
PASSPHRASE='MyPassword'
----

Natürlich setzen Sie hier bei `PASSPHRASE` Ihr eigenes Passwort ein.
Und Sie sollten die Datei unbedingt vor Lesezugriffen anderer Benutzer schützen:

[{shell}]
----
{c-root} chmod 600 /etc/check_mk/encryption.cfg
----

Jetzt können Sie folgende Tests machen (siehe dazu auch den xref:cmk_commandline#[Artikel über die Kommandozeile von {CMK}]):

* Der Aufruf von `check_mk_agent` auf dem Zielsystem muss wirren Zeichensalat ausgeben.
* Der Zugriff via `telnet myhost123 6556` vom {CMK} Server muss den gleichen Zeichensalat ausgeben.
* Der Befehl `cmk -d myhost123` auf dem {CMK} Server muss die sauberen Klartextdaten anzeigen.


==== Aufsetzen mit Agentenbäckerei

{cee-only}
Das Aufsetzen der Verschlüsselung mit der Agentenbäckerei ist sehr einfach.
Mit dem Erstellen der gerade beschriebenen Regel sind Sie im Grunde fertig.
Sie brauchen nur noch neue Agenten zu backen und zu verteilen.
Die Datei `/etc/check_mk/encryption.cfg` wird automatisch für Sie erzeugt und mit in die Agentenpakete eingebaut.

=== xinetd: IP-Beschränkung

Auch wenn ein Angreifer keine Befehle ausführen kann:
Die Monitoring-Daten des Agenten könnten für ihn bereits nützlich sein, denn sie enthalten unter anderem eine Liste von allen auf dem System laufenden Prozessen.
Am besten ist es daher, wenn die Daten nicht jeder einfach abrufen kann.

// SK: Hier passt dann auch das "ganz normal" nicht mehr. Ganz normal sollte ja der Agent Controller sein.
// MFS: Fixed it…

Wenn Sie den {CMK} Agenten über den `xinetd` freigeben, ist es sehr einfach und effektiv, den Zugriff auf bestimmte IP-Adressen zu beschränken -- und zwar natürlich auf die des Monitoring-Servers.
Das ist über die Direktive `only_from` der Konfigurationsdatei Ihres `xinetd` schnell zu erreichen.
Tragen Sie durch Leerzeichen getrennt IP-Adressen oder Adressbereiche (in der Form `12.34.56.78/29` oder `1234::/46`) ein.
// SK: Doppelpunkt nach Doppelpunkt finde ich persönlich seltsam.
// MFS: IPv6 meint dazu: Is halt so.
Zulässig sind auch Host-Namen: in diesem Fall wird geprüft, ob der durch _Rückwärtsauflösung_ der IP-Adresse des anfragenden Hosts ermittelte Host-Name mit dem eingetragenen übereinstimmt:

./etc/xinetd.d/check-mk-agent
[{file}]
----
service check_mk
{
        type           = UNLISTED
        port           = 6556
        socket_type    = stream
        protocol       = tcp
        wait           = no
        user           = root
        server         = /usr/bin/check_mk_agent
        only_from      = 10.118.14.5 10.118.14.37
        disable        = no
}
----

{cee-only}
In den {EE} können Benutzer der Agentenbäckerei die erlaubten IP-Adressen über den Regelsatz [.guihint]#Allowed agent access via IP address (Linux, Windows)# konfigurieren.
Diesen Regelsatz finden Sie über [.guihint]#Setup > Agents > Windows, Linux, Solaris, AIX > Agent rules > Generic Options#.

Natürlich kann ein Angreifer sehr leicht seine IP-Adresse fälschen und so eine Verbindung zum Agenten bekommen.
Aber dann ist es sehr wahrscheinlich, dass er die Antwort nicht bekommt -- weil diese zum echten Monitoring-Server geht.
Oder er bekommt sie tatsächlich, aber der {CMK} Server bekommt keinerlei Daten und wird sehr bald einen Fehler melden.

// SK: Zurück zur Struktur: Meines Erachtens könnten wir in diesem Artikel xinted und ssh *die* zwei sinnvollen Wege für die Datenübertragung im Legacy-Modus gleichwertig nebeneinander stellen.
// SK: SSH würde also ein eigenes (Unter-)Kapitel auf der gleichen Ebene wie xinetd bekommen und der ganze übrige Absicherungskram kommt dann in den Abschnitt von xinetd.
// SK: Aktuell ist nämlich das Kapitel 5 von der Story her unklar. Der Leser könnte sich fragen, ob sich die Kapitel 5.2 bis 5.4 irgendwie ergänzen und aufeinander folgen, oder ob sie jeweils Alternativen darstellen.
// SK: So könnte man dann auch den ersten Satz von 5.3 ("Die beste Sicherheit") besser in den Kontext des Artikels einbauen. Alleine genommen steht der sonst wieder in harter Konkurrenz zum Agent Controller.
// MFS: Zusammengezogen, früher hatte IP-Adressbeschränkung zwei Unterkapitel, da es hier nur xinetd gibt, ist das unnötig
