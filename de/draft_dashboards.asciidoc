include::global_attr.adoc[]
= Dashboards
:revdate: draft
:title: Dashboards
:description: {CMK}-Dashboards sind extrem flexibel und sie passen sich automatisch dem verfügbaren Platz an. Lesen Sie hier, wie Sie Dashboards interpretieren und erstellen.

{related-start}
link:views.html[Ansichten von Hosts und Services]
link:graphing.html[Messwerte und Graphing]
{related-end}

== Einleitung
// TK: Allgemeiner Kram:
// TK: Kannst du bitte im ganzen Artikel vor und nach einem > im GUI-Pfad jeweils ein Leerzeichen einfügen? Dann sieht es auch so ähnlich aus wie der GUI Breadcrumb.
// TK: Typos und GUI Texte hab ich direkt im Text korrigiert, ausserdem Hostname > Host-Name (sofern kein GUI text)
// TK: Anker setzen für zumindest alle H2 und H3? Ich glaub, wir haben da keine Regel zu, ich finds aber sinnvoll.

=== Was genau sind Dashboards?
Dashboards sind in {CMK} die zentralen Ansichten für Ihr Monitoring. Sie liefern Ihnen sowohl Übersichten als auch detaillierte Einsichten in bestimmte Bereiche. Sie können etwa den allgemeinen Status ganzer Netzwerksegmente visualisieren, aber auch schlicht auflisten, welche Services just für eine Aus- oder Überlastung bestimmter Systemressourcen sorgen. {CMK} bringt einige Standard-Dashboards mit sich, so für Probleme, {CMK}-Server-Statistiken und natürlich einen Gesamtüberblick. Sie dürfen aber völlig individuelle Dashboards von Grund auf selbst gestalten.
// TK: Dashboards sind in {CMK} die zentralen Ansichten: Das ist eine problematische Definition, da bei uns Views Ansichten sind (oder auch Statusansichten, Tabellenansichten oder auch schön und englisch Views). Dass wir Views im deutschen nicht einheitlich übersetzen/verwenden ist das eine, was wir auch mal in den Griff bekommen sollten. Hier sagst du aber eigentlich Dashboard=View und das sollten wir vermeiden. Wie wärs mit sowas (Kondensat meines Kapitels aus user_interface): Ein Dashboard bereitet auf einer Seite Informationen aus dem Monitoring auf und nutzt und kombiniert dabei verschiedene Visualisierungen von Daten, etwa Views, Verlaufsgraphen, Tabellen, Diagramme und viele andere Elemente.

Welche Werkzeuge dafür zur Verfügung stehen und wie genau Sie damit eigene Übersichten aufbauen, lesen Sie in diesem Artikel. Zunächst zeigen wir Ihnen, wie Dashboards funktionieren und wie Sie damit arbeiten. Anschließend beleuchten wir die Grundlagen für Layout und Konfiguration, um darauf aufbauend im Anschluss ein komplettes, einfaches Beispiel-Dashboard Schritt für Schritt zu kreieren. Anschließend folgt eine kurze Zusammenfassung zum Thema link:dashboards.html#filter[Filter,] da diese an mehreren Stellen gesetzt werden können. Weiter geht es mit der Vorstellung aller bereits eingebauten Dashboards und Dashlets -- den einzelnen Bausteinen für Übersichten. Den Abschluss bilden Tipps zum Umgang mit Fehlern und Problemen.
// TK: Anschließend ... im Anschluss ... Anschließend: zur Abwechslung zwischendrin mal "dann" oder "weiter geht es" verwenden?
// TK: Nicht nur für Filter einen Link setzen, sondern auch für die anderen Hauptkapitel

Das auffälligste Dashboard sehen Sie übrigens direkt als Startseite von {CMK}, allerdings können Dashboards wie sonstige Ansichten behandelt und ganz einfach über Menüs in der Seitenleiste und die Hauptnavigation aufgerufen werden. Und natürlich eignen sich Dashboards bestens, um sie separat auf einzelne Monitore zu legen, sei es für einen großen Leitstand, als Info-Display für Serverräume oder als schlichtes Kiosk-Display für den Konferenzsaal.
// TK: als Startseite > auf der Startseite
// TK: über Menüs in der Seitenleiste und die Hauptnavigation aufgerufen werden > über die Navigationsleiste und die Seitenleiste aufgerufen werden
// TK: Für Navigationsleiste, Seitenleiste etcpp. gibt es jetzt Kapitel=Linkziele im user_interface

=== Features
// TK: Features > Was können Dashboards? oder Das können Dashboards
Das Besondere an {CMK}-Dashboards ist, dass sie sich über einen intelligenten Algorithmus automatisch an die Dimensionen des Displays beziehungsweise des Browserfensters anpassen. Dabei können Sie für alle einzelnen Elemente des Dashboards, die Dashlets, festlegen, wie genau sie sich verhalten, und in welche Richtungen sie sich bei Bedarf ausdehnen.

Für den Inhalt stehen Dashlets unterschiedlicher Kategorien zur Verfügung: Reguläre Ansichten, Graphen, Metriken, vorgefertigte Elemente für diverse Statistiken und Zeitleisten sowie Kästen für statische Texte und beliebige URLs. Eine Übersicht aller rund 20 Dashlets finden Sie weiter unten. Einige der Dashlets gibt es exklusiv in den {EE}. 

Ein wichtiges Feature bei der Dashboard__-Nutzung:__ Über Filter können selbst Dashboards, die Werte für alle Hosts oder Services im Netzwerk anzeigen, auf bestimmte Bereiche heruntergebrochen werden. Dashboards sind also nicht bloß starre Anzeigen, sondern echte Werkzeuge zum Auffinden und Analysieren von Problemen und Status.

=== Dashboards nutzen
==== Main-Dashboard interpretieren
// TK: Evtl. H3 (Dashboards nutzen) rauskicken und die beiden H4s eine Ebene höher ziehen.
Auf der Startseite von {CMK} sehen Sie das [.guihint]#Main-Dashboard,# das Sie auch im Sidebar-Widget [.guihint]#Views# und in der Hauptnavigation jeweils unter [.guihint]#Overview>Main Dashboard# finden. 
// TK: > ... das Sie im [.guihint]#Monitor#-Menü und auch im Seitenleisten-Snapin [.guihint]#Views# jeweils unter [.guihint]#Overview > Main dashboard# finden.

{RE} und {EE} kommen mit unterschiedlichen Standard-Dashboards, hier zunächst ein Blick auf die Variante der {CEE}:

image::dashboard_main_numbered.png[]

[cols="7,~,<.>~", options="header"]
|===
|Nr. |Titel |Funktion

|1 |Filter-Knopf |Filter aufrufen
|2 |Layout-Knopf |Layout-Modus ein-/ausschalten
// TK: Echte Hürde für den Dashboard-Newbie: Den Layout-Knopf gibt es beim Editieren eines bestehenden Dashboards per Default nicht. Ich muss zuerst EINMAL über Dashboard > Customize builtin dashboard in den Layout Mode gewechselt sein, dann gibt es auch den Knopf, der dann bleibt. Sobald der Layout-Knopf angezeigt wird, heisst der obige Menüeintrag statt Customize builtin dashboard > Enter Layout mode. Wer soll das denn verstehen?
|3 |Host statistics | Aktueller Status der Hosts
|4 |Total host problems |Zeitleiste der Host-Probleme
|5 |Service statistics | Aktueller Status der Services
|6 |Total service problems |Zeitleiste der Service-Probleme
|7 |Problem notifications |Zeitleiste der Alarmierungen
|8 |Percentage of total service problems |Zeitleiste aktiver Services
|9 |Host overview |Per Mausrad zoombare Visualisierung von Problemen auf Hosts
|10 |Top alerters (last 7 days) |Für Alarmierungen verantwortliche Services
|11 |Filter |Filter zur Beschränkung des Dashboards auf einzelne Hosts/Services
|===
// TK: Da fast jedes Dashlet inzwischen mal wieder(?) anders heisst, hab ich mal die Tabelle korrigiert mit den Titeln der 2.0.0p1.

Wenn Sie mit dem Mauszeiger über die Graphen oder die Host-Symbole im Dashlet [.guihint]#Host overview# fahren, bekommen Sie sofort weitere Detailinformationen via Hover-Menü. Die Farben entsprechen jeweils der Darstellung der Dashlets zu aktuellen Host- und Service-Statistiken. Über die Titelzeilen der Dashlets gelangen Sie zu ausführlicheren Darstellungen. Bei der [.guihint]#Host overview# kann es schnell mal zu Hunderten Hexagons kommen, daher können Sie in diesem Dashlet mit dem Mausrad zoomen. 
// TK: Hover-Menü > Hover-Tooltip oder nur Tooltip
// TK: Über die Titelzeilen der Dashlets gelangen Sie ... > Durch Anklicken der Titelzeile eines Dashlets gelangen Sie ... (vorher reichte Hover, jetzt muss geklickt werden)
// TK: Zoomen per Mausrad: Bei meinen kargen 3 Hosts kann ich endlos am Rad drehen: es tut sich nix - und ich kann mir auch schwer vorstellen, was da beim Zoomen passiert...

Bei der {CRE} sehen Sie auf der Startseite hingegen das [.guihint]#Problem Dashboard,# welches auch in den {EE} über icon:icon_dashboard_problems[] aufrufbar ist und ganz klassisch unerledigte Probleme und aktuelle Events in Listenform zeigt:
// TK: Nur heisst in der RAW das Problem Dashboard eben nicht so, sondern einfach Main. Ich hab mir in meinem kleinen Dashboard-Kapitelchen im user_interface einen abgebrochen, um das klarzumachen. Ich versteh's, weil ich es schon wusste: andere Leute ...?

image::dashboard_main_numbered_raw.png[]

[cols="7,~,<.>~", options="header"]
|===
|Nr. |Titel |Funktion

|1 |Filter-Knopf |Filter aufrufen
|2 |Layout-Knopf |Layout-Modus ein-/ausschalten
|3 |Host statistics | Aktueller Status der Hosts
|4 |Service statistics | Aktueller Status der Services
|5 |Host Problems |Liste unbehandelter Host-Probleme
|6 |Service Problems |Liste unbehandelter Service-Probleme
|7 |Events of recent 4 hours |Ereignisse der letzten vier Stunden
|8 |Filter |Filter zur Beschränkung des Dashboards auf einzelne Hosts/Services
|===

==== Dashboards filtern
Wie Sie später sehen werden, lassen sich Dashboards natürlich von vornherein für eine bestimmte Auswahl von Hosts oder Services erstellen. Über Filter können Sie aber jedes Dashboard temporär auf eine Auswahl beschränken:

1. Filterfunktion über icon:icon_dashboard_filter[] aufrufen.
2. Filter über [.guihint]#Add filter# hinzufügen -- beispielsweise [.guihint]#Hostname#.
3. Filter konfigurieren -- beispielsweise [.guihint]#myhost#.

Der dritte Schritt ist von Filter zu Filter unterschiedlich, wichtig ist hier vor allem die Handhabung eingegebener Suchbegriffe, also beispielsweise für Host-Namen: Wie üblich wertet {CMK} diese als link:regexes.html[reguläre Ausdrücke.] Ein Filter nach [.guihint]#myhost# würde daher sowohl den Host [.guihint]#myhost# finden als auch [.guihint]#2myhost# und [.guihint]#myhost2.# Wenn Sie nur [.guihint]#myhost# im Dashboard sehen wollen, müssen Sie als Suchbegriff entsprechend _^myhost$_ verwenden, um Anfang und Ende der Zeile einzubeziehen und so einen exakten Match zu provozieren.

Natürlich lassen sich auch mehrere Filter miteinander kombinieren, die die Treffermenge dann per _UND-Verknüpfung_ reduzieren. Innerhalb eines Filters dürfen Sie _ODER-Verknüpfungen_ mit den Mitteln der regulären Ausdrücke verwenden, also beispielsweise [.guihint]#myhost1|db_server#.

== Layout, Konfiguration, Rechte
Dashboard-Einstellungen gliedern sich in zwei Teile: Über das Layout bestimmen Sie die Anordnung der Dashlets, deren Dimensionen und dynamische Skalierung. Die Konfiguration bezieht sich auf die Eigenschaften des Dashboards an sich, vor allem aber auf die einzelnen Dashlets, also welche Inhalte sie wie aufbereitet zeigen.

=== Layout
Das Besondere am Dashboard-Layout ist die Dynamik: Dashlets können zwar mit fixer Höhe und Breite angelegt werden, sie können aber auch automatisch in beiden Dimensionen wachsen, um den vorhandenen Platz bei jeder Skalierung optimal auszunutzen -- ähnlich wie beim Responsive-Webdesign, aber detaillierter zu konfigurieren. 

Das Prinzip ist simpel: Eine beliebige Ecke eines Dashlets wird als Anker festgelegt. Von diesem Fixpunkt aus kann das Dashlet dann in Höhe und/oder Breite wachsen, sobald mehr Platz zur Verfügung steht, also zum Beispiel schlicht auf einem größeren Bildschirm, aber auch, wenn sich die Position oder Größe anderer Dashlets verändert.

==== Beispiel-Layout
// TK: Beispiel klingt so nach mitmachen. Kann man hier aber (noch) nicht. Ich würde kurz erwähnen, dass es darum geht, das dynamische Verhalten zu zeigen ohne hier zu erklären, wie man die Dashlets auswählt und mit ihnen umgeht.

Zur Verdeutlichung des Prinzips hier ein Beispiel mit einem Host-Matrix-Dashlet mit manueller Höhe und Breite in der Mitte.

Umrahmt wird es von Host-Overview-Dashlets, allesamt mit automatischer Höhe, die seitlichen auch mit automatischer Breite -- die Dashlets oben und unten bekommen die Einstellung [.guihint]#max width#. Standardmäßig sitzt der Anker oben links, hier bekommt jedoch das rechte Dashlet den Anker oben rechts und das untere unten links.
// TK: Umrahmt wird es von Host-Overview-Dashlets > Umrahmt wird es von vier Host-Overview-Dashlets.
// TK: Ich hab mich blöd gesucht nach dem Host-Overview-Dashlet bis ich drauf gekommem bin, mir die Properties des Dashlets im Main Dashboard anzusehen. Nenn es doch einfach Site-Overview-Dashlet im ganzen Artikel.
// TK: Vielleicht doch kurze Bildbeschreibung (ist schwer zu erkennen, ohne die Grafik anzuzeigen): Verankerte Ecke wird im Dashlet in grün gekennzeichnet und die aktuelle Einstellung von Breite und Höhe in der Mitte.

image::dashboard_layout_example_1.png[]

Wenn man nun das Host-Matrix-Dashlet zum Beispiel weiter nach links und unten verschiebt, verändern sich die Site-Dashlets links, rechts und unten -- denn sie wachsen automatisch von ihren Ankern hin zum zentralen Host-Matrix-Dashlet.
// TK: Site-Dashlets > siehe Kommentar oben
// TK: denn sie wachsen > denn sie wachsen oder schrumpfen

Das obere Dashlet hingegen bleibt wie es ist -- nach unten kann es schließlich nicht wachsen, da die beiden seitlichen Dashlets oben verankert sind. Einfacher zu verstehen ist das, wenn Sie sich solch einen Testaufbau selbst anlegen und die Dashlets ein wenig herumschubsen. 
// TK: Letzten Satz ans Kapitelende verschieben - und umformulieren: Klingt nach Ich kann es ja eh nicht gut genug erklären (was ja gar nicht stimmt). 
// TK: "herumschubsen" ist ein sehr schöner Begriff! 

image::dashboard_layout_example_2.png[]

Zur Verdeutlichung: Schaltet man nun das untere Dashlet von [.guihint]#max width# auf [.guihint]#auto width# geht es nicht mehr über die gesamte Breite -- weil die automatische Höhe des rechten Dashlets vor der automatischen Breite des unteren Dashlets gerendert wird. 
// TK: Zur Verdeutlichung: würde ich mir schenken, weil hier was neues beschrieben wird.
// TK: Wie ist denn das Prinzip? Zuerst wird immer die Höhe gerendert und dann erst die Breite? Oder zuerst die rechten Dashlets und dann die linken? Uff. Ist wahrscheinlich noch viel komplizierter..., aber wenns im Handbuch nicht steht: Wo sonst?

image::dashboard_layout_example_3.png[]

Wenn Dashlets mit automatischen Dimensionen um denselben Raum streiten, können Sie mit der Maximal-Einstellung quasi den Gewinner festlegen -- aber Vorsicht: Konkurrieren zwei auf Maximum gesetzte Dashlets um denselben Raum, kann es zu Überlappungen kommen.

=== Konfiguration: Dashboard
Die Dashboard-Konfiguration sehen Sie automatisch beim Anlegen eines neuen Dashboards, später erreichen Sie sie über die Icons in der Dashboard-Liste oder den Menüeintrag [.guihint]#Dashboard>Properties# eines geöffneten Dashboards.
// TK: Icons in der Dashboard-Liste: Die kommt erst später. Vielleicht in Klammern dranhängen ([.guihint]#Customize > Dashboards#)

image::dashboard_config_dashboard.png[width=60%]

Die Eigenschaften des Dashboards an sich sind trivial, hier werden lediglich Metadaten wie Name, Menüeintrag oder Sichtbarkeit gesetzt, zudem bei Bedarf Kontextfilter. Kontextfilter beschränken Dashboards und Dashlets schlicht auf bestimmte Hosts und/oder Services.

image::dashboard_config_example_dashboard.png[]


=== Konfiguration: Dashlets
Die Konfiguration einzelner Dashlets sehen Sie wieder automatisch beim Hinzufügen zu einem Dashboard; später rufen Sie sie direkt über das Zahnrad-Icon der Dashlets im Layout-Modus auf.
// TK: Die Konfiguration einzelner Dashlets sehen Sie wieder automatisch > Die Konfiguration einzelner Dashlets sehen Sie automatisch

image::dashboard_config_dashlet.png[width=60%]

Die Konfiguration der meisten Dashlets ist recht simpel, wie etwa das Dashlet mit der Host-Matrix aus den obigen Screenshots zeigt: Dabei handelt es sich nämlich eigentlich um ein Dashlet vom Typ [.guihint]#Sidebar element# und die ganze Konfiguration beschränkt sich auf die Auswahl eben dieses Seitenleistenelements. Bei allen Dashlets, die sich auf einige oder einzelne Hosts und Services beziehen, finden Sie zudem entsprechende Filtermöglichkeiten. Und letztlich bieten einige Dashlets noch Optionen zur genauen Gestaltung der Visualisierung, beispielsweise über Grenzwerte. Als Beispiel hier der [.guihint]#Properties#-Kasten des [.guihint]#Gauge#-Dashlets:

image::dashboard_config_example_dashlet.png[]

=== Rechte
Auch abseits des Dashboard-Bereichs gibt es in {CMK} wichtige Einstellungen, nämlich die Rechte. Unter [.guihint]#Setup>Users>Roles & permissions>Edit user role# können Sie einfach nach _dashboard_ filtern, um alle Optionen aufzulisten. Hier lässt sich detailliert festlegen, welche Standard-Dashboards Nutzer beziehungsweise Nutzerrollen sehen und was genau sie mit sonstigen Dashboards anfangen dürfen.
// TK: Der 1. Satz holpert etwas, vielleicht so: Auch abseits der Dashboard- und Dashlet-Konfiguration gibt es in {CMK} wichtige Einstellungen, die Dashboards betreffen, nämlich die Rechte.
// TK: Edit user role# > // Edit role user#
// TK: Hier lässt sich detailliert festlegen, welche Standard-Dashboards Nutzer beziehungsweise Nutzerrollen sehen > Hier lässt sich für eine link:wato_user.html#role[Rolle] detailliert festlegen, welche Standard-Dashboards deren zugewiesene Benutzer sehen 
// TK: und was genau sie mit sonstigen Dashboards anfangen dürfen: Das sieht man im Screenshot gerade nicht. Vielleicht ein anderes Motiv wählen (die Dashboard-Liste gibt es ja später ausführlich)? Mit ausgeklappten General Permissions und den anderen Kästen eingeklappt?

image::dashboard_config_permissions.png[]
// TK Bei dem Screenshot ist die Aktionsleiste eingeklappt, die wollten wir ja eigentlich ausgeklappt zeigen: gilt auch noch für einige andere im folgenden.

////
tbd
=== Erweiterte/Verwandte Einstellungen
==== Verteiltes Monitoring
==== Kiosk-Modus
==== Diverses
////

== Beispiel-Dashboard
// TK: Regeln hin oder her: Hier würde ich das ganze eine Ebene weiter hochziehen: Inhalt von Dashboard-Beschreibung hier rein und dann H3s für die 5 Einzelschritte. 

=== Dashboard-Beschreibung
Das Beispiel-Projekt führt Sie einmal durch die notwendigen Schritte, um ein Dashboard von Grund auf aufzusetzen. Dabei werden Sie grundsätzlich alle Möglichkeiten exemplarisch zu Gesicht bekommen. Dazu dienen vier Dashlets:

Das [.guihint]#Performance graph#-Dashlet zeigt die Nutzung eines Dateisystems eines Hosts, [.guihint]#Gauge# die durchschnittliche CPU-Auslastung der letzten Minute, die [.guihint]#Alert timeline# visualisiert Alarmierungen für eine Auswahl von Hosts und Services über einer Zeitleiste und die in den {EE} bereits existierende Ansicht [.guihint]#Scheduled downtimes# listet geplante Wartungszeiten.
// TK: Scheduled downtimes gibt es doch auch in der CRE?
// TK: Aber Gauge + Alert timeline gibt es nur in den EE. Auch wenn es bei den einzelnen Schritten erwähnt wird, würde ich hier schreiben, dass man das gesamte Beispiel nur in den EEs nachkochen kann.

Und so wird das fertige Dashboard aussehen:

image::dashboard_example_view.png[]

=== Beispiel-Dashboard aufsetzen
==== 1. Dashboard anlegen
Legen Sie zunächst ein Dashboard über [.guihint]#Customize>Dashboards>Add dashboard# an. Sie gelangen umgehend zu einer ersten grundsätzlichen Einstellung: Über [.guihint]#Select specific object type# können Sie das Dashboard von vornherein auf bestimmte Hosts, Services und sogar einzelne Objekte wie Docker-Images oder Lüfter beschränken. Für das Beispiel belassen Sie es bei der Vorgabe [.guihint]#No restrictions to specific object#, filtern können Sie zudem auch später noch.
// TK: zu einer ersten grundsätzlichen Einstellung: dann dashboard_example_1.png, dann weiter im Text

image::dashboard_example_1.png[]

Anschließend landen Sie in den Eigenschaften des zu erstellenden Dashboards.
// TK: Anschließend > Mit [.guihint]#Continue#

image::dashboard_example_2.png[]

Verlangt werden hier lediglich Name und Titel für das Dashboard im Kasten [.guihint]#General Properties#, hier [.guihint]#my_dashboard# und [.guihint]#My Dashboard.# Interessant sind hier zudem die Optionen zur Sichtbarkeit, insbesondere der Punkt [.guihint]#Topic in 'Monitor' menu.# Darüber bestimmen Sie, unter welchen Thema das Dashboard später in der Hauptnavigation sowie in den Seitenleistenelementen [.guihint]#Views# und [.guihint]#Dashlets# aufgelistet wird.
// TK: Hauptnavigation > im Monitor-Menü der Navigationsleiste
// TK: [.guihint]#Dashlets# > [.guihint]#Dashboards# 

Wichtig sind aber auch die Kontextfilter, die hier gleich zwei mal auftauchen: Im Kasten [.guihint]#Context / Search Filters# können Sie einen Standardfilter für das Dashboard setzen, so dass bei dessen Aufruf umgehend bestimmte Hosts und/oder Services auftauchen.

Im Kasten [.guihint]#Dashboard Properties# lassen sich über [.guihint]#Required context filters# hingegen benötigte, aber *leere* Filter setzen: Wenn Sie hier beispielsweise den Filter [.guihint]#Host: Hostname# setzen, startet das Dashboard mit eben diesem Filter -- und der Nutzer muss dann entsprechend selbst angeben, auf welchen Host-Namen gefiltert werden soll. Auf diese Weise können Sie Nutzer mit dynamischen Dashboards versorgen und direkt darauf stoßen, dass sie noch für den benötigten Kontext sorgen müssen.

Für das Beispiel-Dashboard lassen Sie die Filter einfach komplett leer -- die Filterung erfolgt über die einzelnen Dashlets. Bestätigen Sie mit [.guihint]#Save & go to dashboard#.
// TK: Hier ergänzen, dass das leere Dashboard angezeigt wird (und auch immer wieder über den ausgewählten Monitor-Menüeintrag aufgerufen werden kann) UND dass man jetzt mit dem Layout-Knopf zwischen Editieren und Glotzen=Überprüfen wechseln kann.

==== 2. Dashlet Performance Graph hinzufügen
Fügen Sie nun auf dem leeren Dashboard das Dashlet über [.guihint]#Add>Performance graph# hinzu. Unter [.guihint]#General Settings# sollten Sie einen sprechenden Titel vergeben, ansonsten werden Dashboards mit vielen Dashlets schnell unübersichtlich -- vor allem, wenn sie nicht von vornherein auf bestimmte Elemente gefiltert werden. Da hier das Root-Dateisystem vom Host [.guihint]#myhost# visualisiert werden soll, bietet sich [.guihint]#My Host Filesystem/# an. Komfortabler geht das wie in vielen Eingabefeldern in {CMK} über Makros: [.guihint]#$HOST_NAME$: $SERVICE_DESCRIPTION$# Welche Makros Sie jeweils nutzen können, entnehmen Sie der icon:icon_main_help[] Inline-Hilfe.
// TK: icon_main_help: Da ist (fast) nix zu sehen? besser stattdessen: entnehmen Sie den Hilfetexten, die Sie sich mit [.guihint]#Help > Show inline help# einblenden können.

image::dashboard_example_3.png[]

Im Kasten für die Kontextfilter geben Sie den Host-Namen und das gewünschte Dateisystem an. In beiden Eingabefeldern können Sie schlicht den ersten Buchstaben eingeben und dann mit der Pfeil-runter-Taste durch die möglichen Einträge scrollen.

image::dashboard_example_4.png[]

Im dritten Kasten [.guihint]#Properties# werden die beiden Filter automatisch für die Einstellung [.guihint]#Graph# übernommen. Sie müssen lediglich noch den gewünschten Graphen wählen, hier also [.guihint]#Filesystem size and used space.# Die weiteren Darstellungsoptionen können Sie vorerst belassen.
// TK: können Sie vorerst belassen > können Sie vorerst unverändert lassen

image::dashboard_example_5.png[]

Wenn Sie das Dashlet nun speichern, landen Sie im Layout-Modus. Da das Dashlet über die gesamte Breite laufen soll, klicken Sie auf [.guihint]#manual width,# um die manuelle Breite auf [.guihint]#auto width# umzuschalten. 

image::dashboard_example_6.png[]
// TK: Evtl. hinzufügen, dass die Default Ankerpoistion links oben richtig gesetzt ist und nicht verändert werden muss.

==== 3. Dashlet Gauge hinzufügen
Das [.guihint]#Gauge#-Dashlet steht nur in den {EE} zur Verfügung und visualisiert Werte wie die CPU-Auslastung in Anlehnung an einen Tachometer.

Die Konfiguration unterscheidet sich kaum von der des eben erzeugten Graphen, wieder filtern Sie auf [.guihint]#myhost# und jetzt auf den Service [.guihint]#CPU load#.

Und wieder werden beide Werte automatisch in den [.guihint]#Properties#-Kasten übernommen, nun unter [.guihint]#Metric# (statt wie zuvor unter [.guihint]#Graph#). Als Metrik wählen Sie [.guihint]#CPU load average of last minute.#

Allerdings müssen Sie dieses mal noch eine weitere Einstellung setzen, nämlich das Maximum der Skala unter [.guihint]#Date range.# Hier können Sie [.guihint]#Floating point number# belassen und das Maximum auf 10 setzen. Ohne diese Angabe landen Sie in einer Fehlermeldung.
// TK: Ohne diese Angabe landen Sie in einer Fehlermeldung.: Das klingt nach Bug, was es ja hier wohl ausnahmsweise nicht ist ;-) Vielleicht statt dieses Satzes vorne ergänzen: > weitere Einstellung setzen, da sich die Minimum- und Maximumwerte im Datenbereich unterscheiden müssen. ... 

image::dashboard_example_7.png[]

Nach dem Speichern landen Sie wieder im Layout-Modus und können das Dashlet unterhalb des Performance-Graphen platzieren (der zunächst vom neuen Dashlet überlagert wird!); hier bieten sich manuelle Breite und Höhe an. An dieser Stelle könnten Sie nun auch das Graphen-Dashlet auf automatische Höhe setzen und die Höhe dann schlicht durch die Platzierung des neuen Gauge-Dashlets bestimmen.
// TK: > hier bieten sich manuelle Breite und Höhe an. Die gewünschte Größe bestimmen Sie durch Ziehen mit der Maus an den Dashlet-Rändern.
// TK: des neuen Gauge-Dashlets bestimmen > des neuen Gauge-Dashlets bestimmen lassen
// TK: Im folgenden Screenshot (und auch in dashboard_example_9c.png weiter unten) steht der Graph-Dashlet aber immer noch auf manual height.

image::dashboard_example_8.png[]

==== 4. Dashlet Alert Timeline hinzufügen
Als drittes Dashlet folgt nun die [.guihint]#Alert timeline# zur Darstellung der Alarmierungen auf einer Zeitachse; ebenfalls exklusiv in den {EE} zu finden.

In diesem Dashlet sollen nun Daten mehrerer Hosts und Services landen -- daher auch oben der Verzicht auf eine Dashboard-weite Vorabfilterung. Um alle Alarmierungen aller Hosts zu bekommen, die mit _my_ anfangen, setzen Sie den Host-Namenfilter auf _^my*_.
// TK: Vielleicht an dieser Stelle 1x explizit hinzufügen (obwohl es oben hier und da auch schon mal gepasst hätte): Wenn man alle Hosts auswerten will, braucht man gar nicht zu filtern, d.h. nix eingeben.

image::dashboard_example_9a.png[]

Für das Beispiel-Dashlet wird die Darstellung [.guihint]#Bar chart# beibehalten, der Zeitraum auf [.guihint]#The last 35 days# gesetzt, die Einheit auf ganze Tage.

image::dashboard_example_9b.png[]

Nach dem Speichern platzieren Sie das Dashlet wieder auf dem Dashboard, auch hier bietet sich eine automatische Breite mit manueller Höhe an, um die Zeile mit dem Gauge-Dashlet zu füllen.

image::dashboard_example_9c.png[]


==== 5. Dashlet per Ansicht hinzufügen
Auch bereits existierende reguläre link:views.html[Ansichten] können als Dashlet genutzt werden. Das funktioniert etwa über [.guihint]#Add>Link to existing view,# aber auch über Ansichten selbst.
// TK: Was sind reguläre Ansichten? "reguläre" streichen?
// TK: über Ansichten selbst. > über die Ansichten selbst. Zur Abwechlung werden wir im folgenden die Einbindung in das Dashboard über die Ansicht vorstellen.

Um die Ansicht der geplanten Wartungszeiten einzufügen, rufen Sie diese zum Beispiel über die Seitenleiste und dort [.guihint]#Views>Overview>Scheduled downtimes# auf. Anschließend fügen Sie die Ansicht Ihrem Dashboard über [.guihint]#Add to>My Dashboard# hinzu und platzieren es als letzte Zeile -- hier bieten sich nun automatische Höhe und Breite an, um leere Bereiche zu vermeiden.
// TK: Aufruf über Snapin Views ist ein wenig kompliziert, denn das Ding muss man sich erst in die Seitenleiste holen > rufen Sie diese am schnellsten über [.guihint]#Monitor > Overview > Scheduled downtimes# auf.
// TK: An dieser Stelle verlässt Du jetzt das Dashboard. Hier könnte man die Info unterbringen, dass ein Dashboard nie durch den Benutzer gesichert werden muss, da der aktuelle Zustand automatisch gesichert wird. Ist doch so, oder?

image::dashboard_example_10.png[width=60%]

Wenn Sie nun die Konfiguration des Dashlets aus dem Layout-Modus heraus aufrufen, stehen Ihnen die aus link:views.html[Ansichten] bekannten Einstellungen zur Verfügung, um das Dashlet beispielsweise ein wenig schlanker zu gestalten -- ein Klick auf den Dashlet-Titel führt Sie schließlich sowieso zur vollständigen Wartungszeitenansicht.
// TK: die Konfiguration des Dashlets aus dem Layout-Modus heraus aufrufen: Meint du hier Dashlet > Edit Properties = icon_dashlet_edit[]?
// TK: ein wenig schlanker zu gestalten: Meinst Du hier die Dashlet-Größe oder die angezeigten Daten?

Damit wäre Ihr Beispiel-Dashboard fertig, hier nochmal komplett im Layout-Modus:

image::dashboard_example_11.png[]

[#filter]
== Filter
Die Filterung von Dashboards und Dashlets ist ein mächtiges Feature, wurde bislang an recht vielen Stellen erwähnt und soll daher hier nochmal kurz zusammengefasst werden. Sie haben drei Möglichkeiten dies zu tun:

* Dashboard-Eigenschaften
** [.guihint]#Context / Search filters#
** [.guihint]#Required context filters#
* Dashlet-Eigenschaften: [.guihint]#Context / Search filters#
* Dashboard-Ansicht: [.guihint]#Context / Search filters#
// TK: Dashboard-Ansicht...: Meinst Du hier den grünen Filterknopf in der Menüleiste? Der heisst aber nur "Filter".

Der Eintrag [.guihint]#Context / Search filters# ist im Grunde an allen drei Orten identisch, aber: Wenn Sie ein Dashboard in den Eigenschaften auf einen Host filtern, können Sie in der Dashboard-Ansicht keine anderen Hosts anschauen, lediglich die vorhandenen Hosts noch weiter filtern. In den Dashlet-Eigenschaften können Sie aber sehr wohl den Filter der Dashboard-Eigenschaften übergehen und andere Hosts einbeziehen!

Die [.guihint]#Required context filters# sind ebenfalls in den Dashboard-Eigenschaften zu finden, filtern aber zunächst nichts. Sie werden lediglich als benötigte Filter gesetzt: Ein Dashboard mit solchen Vorgaben erscheint in der Dashboard-Ansicht ohne Informationen zu Hosts und Services, aber mit der geöffneten Filterfunktion und dem Hinweis auf diesen [.guihint]#Mandatory context,# den der Nutzer gewissermaßen zur Laufzeit setzen muss.
// TK: Sie werden lediglich als benötigte Filter gesetzt: > Sie werden stattdessen dem Benutzer beim Öffnen des Dashboards präsentiert, der dann den Filter setzen muss, um Daten im Dashboard sehen zu können.

image::dashboard_example_mandatory.png[width=60%]
// TK: Das Bild sieht auf den ersten Blick unvollständig aus. Vielleicht etwas mehr Luft nach unten?
	
== Dashlets und Builtin-Dashboards
// TK: H2: Eingebaute Dashboards und Dashlets, H3: Dashboards, H3: Dashlets

=== Eingebaute Dashboards
Eine Liste aller individuell angelegten sowie eingebauten Dashboards finden Sie über [.guihint]#Customize>Dashboards.# Für die eigenen Varianten können Sie über icon:icon_dashlet_edit[] die Eigenschaften aufrufen und über icon:icon_dashboard_edit[] den Layout-Modus. Die werksseitig vorgegebenen Dashboards können Sie nicht direkt bearbeiten, jedoch über icon:icon_clone[] klonen und dann anpassen.

[cols="21,~,<.>~", options="header"]
|===
|Name/ID |Ort |Funktion
| checkmk |Monitor>System>Checkmk dashboard |Übersicht von {CMK}-Servern und -Sites
| checkmk_host |????? |Systeminformationen des {CMK}-Servers
|main |Monitor>Overview>Main dashboard |Gesamtübersicht
|ntop_alerts |Monitor>Network statistics |Ntop-Alarme, sofern aktiviert ({CEE})
|ntop_flows |Monitor>Network statistics |Netzwerk-Flow durch Ntop ({CEE})
|ntop_top_talkers |Monitor>Network statistics  |Größte Traffic-Verursacher durch Ntop ({CEE})
|problems  |Monitor>Problems>Problems dashboard |Alle Host- und Service-Probleme und -Statistiken
|simple_problems |Monitor>Problems>Host & service problems |Reine Liste von Host- und Service-Problemen
|site |????? Monitor>Overview>Site dashboard|Sites-Übersicht
|===
// TK: Zu der Tabelle hab ich 1 ganzen Sack Kommentare, z.B. Spalte Ort umbenennen zu Monitor-Menüeintrag (dann werden auch die Einträge kürzer), auch hier die CRE Spalte einfügen, überall Site zu Instanz ändern, ntop-Einträge umformulieren. Das war dann so länglich, dass ich einfach eine neue Tabelle geschrieben hab. Schau es Dir an:
////
[cols="20,33,9,~", options="header"]
|===
|Name/ID |Monitor-Menüeintrag |CRE |Inhalt
|checkmk |System > Checkmk dashboard |Ja |{CMK}-Server und -Instanzen
|checkmk_host |- |Ja |Systeminformationen eines {CMK}-Servers
|main |Overview > Main dashboard  |Ja |Gesamtübersicht
|ntop_alerts |Network statistics > Alerts |Nein |Alarme in link:ntop.html[ntopng]
|ntop_flows |Network statistics > Flows |Nein |Datenflüsse in ntopng
|ntop_top_talkers |Network statistics > Top Talkers |Nein |Hosts in ntopng, die den meisten Netzwerkverkehr verursachen
|problems  |Problems > Problems dashboard |Nein |Probleme und Statistiken aller Hosts und Services. Das Problems dashboard ist in der {CRE} das Main dashboard.
|simple_problems |Problems > Host & service problems |Ja  |Probleme aller Hosts und Services
|site |- |Nein |Übersicht einer Instanz
|===
////

=== Dashlets
Hier sehen Sie zunächst alle 20 Dashlets in der Übersicht, anschließend zeigen wir Ihnen noch ein paar Besonderheiten, die im obigen Beispiel-Dashboard nicht mit abgehandelt wurden. 

[cols="12,33,9,~", options="header"]
|===
|Kategorie |Name |CRE |Funktion
|Views |View |ja |Reguläre Ansichten als Dashlets
|Graphs |Single metric graph |nein |Graph für einzelne Metriken über Zeitachse
|Graphs |Performance graph |nein |Vorgegebene Performance-Graphen für einzelne Hosts/Services
|Graphs |Custom graph |ja |Manuell erstellte Freiformgraphen
|Graphs |Combined graph |nein |Graphen mit mehreren Metriken
|Metrics |Average scatterplot |nein |Metriken diverser Hosts/Services als Streudiagramm
|Metrics |Barplot |nein |Balkendiagramm für einzelne Services
|Metrics |Gauge |nein |Einzelne Metrik als _Tachometer_
|Metrics |Single metric |nein |Einzelne Metrik als Zahl
|{CMK} |Site overview |nein |Hosts als Status-Hexagons
|{CMK} |Alert statistics |nein |Hosts als Alarmierungs-Hexagons
|{CMK} |Host statistics |ja |Gesamtstastik Host-Status
|{CMK} |Service statistics |ja |Gesamtstastik Service-Status
|{CMK} |Notification timeline |nein |Benachrichtigungen über Zeitleiste
|{CMK} |Alert timeline |nein |Alarmierungen über Zeitleiste
|{CMK} |Percentage of service Problems |nein |Prozentsatz Service-Probleme über Zeitleiste
|{CMK} |User notifications |ja |Nutzerbenachrichtigungen
|{CMK} |Sidebar element |ja |Beliebige Sidebar-Widgets
|Other |Custom URL |ja |Interne/externe URLs
|Other |Static text |ja |Statischer Text für Hinweise
|===
// TK: Hier kommt mal wieder der Schlaumeier: Das ist einerseits eine rechte Fleissarbeit (allerdings fehlen die 3 ntop-Dashlets ;-), aber andererseits: Braucht es die - und wie schnell ändert sich da was? Die ersten 3 Spalten kann jeder Benutzer selbst im Add-Menü sehen. In der 4. Spalte ist es zu mindestens 50% nur die deutsche Übersetzung. Vielleicht könnte man sich darauf beschränken, dem Benutzer zu sagen, wie er die Liste anzeigen kann, dass viele der Einträge nur in den EEs zur Verfügung stehen, und dann evtl. nur ein paar ausgewählte, nicht selbsterklärende Dashlets vorstellen, so wie Du es ja schon mit Custom URL unten angefangen hast: Custom graph, Combined graph, Average scatterplot, Gauge? Oder man sagt dem Benutzer, er soll am besten alles einmal ausprobieren. Lange Rede: Ich würd die Tabelle rauskicken.

Die vielleicht wichtigste Frage der meisten Dashlets: Sind die dargestellten Informationen auf einzelne Hosts oder Services beschränkt? Die Antwort finden Sie in allen Dashlet-Einstellungen im Kasten [.guihint]#General Settings# neben [.guihint]#Show information of single.# Steht an der Stelle [.guihint]#host, service,# müssen Sie einen Kontextfilter setzen. Wenn Sie stattdessen die Angabe [.guihint]#Not restricted to showing a specific object.# sehen, müssen Sie keinen Filter setzen -- können es teilweise aber.
// TK: können es teilweise aber: Warum nur teilweise? Ich dachte, Filtern geht für alle Dashlets?

Wie genau Sie die Graphen in den Graphing-Dashlets gestalten, ist etwas komplexer und wird im zugehörigen link:graphing.html[Graphing-Artikel] ausführlich erläutert.

////
Absatz vielleicht raus? Custom-URL-Dashlet scheint auf offiziellen Wegen nicht mehr sonderlich nützlich.
////
// TK: Hmm: eher drinlassen, vielleicht etwas kürzer + kombiniert mit ein paar anderen ausgewählten Dashlets, siehe Kommentar von oben
Eine besondere Rolle spielt das Dashlet [.guihint]#Custom URL.# Theoretisch können Sie über die simple Angabe einer Adresse externe Webseiten oder Ressourcen einbinden -- in der Praxis scheitert das oft an Sicherheitsmaßnahmen der Betreiber und Browser. Was Sie jedoch sehr gut einbinden können sind interne Ressourcen, beispielsweise jegliche Art von Webanwendungen, sei es ein Wiki, ein kleines Chat-Programm oder auch eine per PHP implementierte Shell, um etwa OMD-Operationen direkt aus einem Dashboard ausführen zu können. Freilich funktioniert das auch mit {CMK}-eigenen Ressourcen, beispielsweise anderen Dashboards. So ließen sich etwa mehrere Host-spezifische Dashboards zu einer großen Übersicht verknüpfen.
// TK: Ab "Freilich" bin ich ausgestiegen: Das klingt so, als ob es ein Standard-Dashboard mit Chat, Shell oder Wiki gibt. Und beim letzten Satz weiß ich nicht, worauf sich das "So" bezieht.

== Dashboard-Beispiele
=== Beispiel 1: Top-Down-Dashboard
// TK: Beispiel 1: würd ich streichen, insbesondere wenn es momentan nur ein Beispiel gibt.
Sie kennen nun also alle verfügbaren Dashlets und fertigen Dashboards, wissen, wo deren Konfigurationen und Layout-Optionen zu erreichen sind und wie man ein komplettes Dashboard zusammenbaut. Dashboards müssen aber nicht unbedingt ganz allein für sich stehen, sondern können auch aufeinander aufbauen -- beispielsweise, um von einer großen Übersicht bis ins kleinste Detail zu navigieren.

Im Grunde funktionieren viele Dashlets bereits genau so: Die [.guihint]#Host statistics# visualisieren die Host-Status und ein Klick auf einen der Status leitet zu einer Ansicht weiter, die die zugehörigen Hosts auflistet -- und von dort geht es wiederum weiter zu den einzelnen Services eines einzelnen Hosts.

Bei eigenen Dashboards können Sie natürlich auch Links auf andere Dashboards setzen. Mal als ganz konkretes Beispiel: Hier sehen Sie ein Dashboard, das Informationen zu CPU, RAM und Dateisystem aller Hosts zeigt, die mit _my_ beginnen.
// TK: können Sie natürlich: Echt "natürlich"? Würd ich streichen, denn wenn es so natürlich ist, brauchst Du das auch nicht zu erwähnen ;-) Stattdessen zumindest kurz erwähnen, wie es geht: über die Dashlet-Einstellungen kann für den Dashlet-Titel mit [.guihint]#Link of Title# eine URL gesetzt werden

image::dashboard_topdown1.png[]

Der Titel des CPU-Graphen verlinkt hier ein weiteres Dashboard, welches die CPU-Informationen für jeden Host einzeln visualisiert. In diesem Dashboard gibt es wiederum ganz oben einen Link zurück zur Übersicht, einfach realisiert über ein [.guihint]#Static text#-Dashlet.
// TK: Das finde wiederum ich erstaunlich: Static text klingt nach doofe Beschriftung und ohne Funktion: dass man auch dafür einen Link setzen kann, hätte ich nicht erwartet: da hätte ich auf das schon erwähnte Custom URL getippt. 

image::dashboard_topdown2.png[]

Mit solchen Querverlinkungen können Sie komplexe Recherchewerkzeuge über Dashboards realisieren. Denken Sie etwa an verteiltes Monitoring und Pfade wie _Gesamtübersicht > Instanzübersicht > Hostübersicht > Container-Übersicht > Services > Probleme._

////
=== Beispiel 2: Predictive Dashboard (für IT-Einkauf ...)
////
	
== Fehlerbehebung
=== Fehlende Filter
Es kann vorkommen, dass Sie bei einem Dashlet lediglich die folgende, gelb unterlegte Warnung sehen:

[.guihint]#Unable to render this element, because we miss some required context information (host, service). Please update the form on the right to make this element render.#

In diesem Fall soll das Dashlet Informationen für nur einen Host und/oder Service anzeigen -- für den oder die aber kein Filter gesetzt wurde. Um das zu beheben, können Sie wahlweise die Filter in der Dashboard-Ansicht nutzen oder in der Dashlet-Konfiguration. 

=== Leere Dashlets
Für gänzlich leere Dashlets bei ausbleibenden Fehlermeldungen kann es mehrere Gründe geben. In der Regel handelt es sich um eine Fehlkonfiguration des Dashlets. Beispiel: Sie erstellen ein Dashlet für die CPU-Auslastung mit der Metrik und dem gefilterten Service [.guihint]#CPU load.# Später ändern Sie den Filter der Service-Beschreibung auf etwa [.guihint]#Check_MK Discovery,# belassen die gewählte Metrik aber auf [.guihint]#CPU load.# Beim Anlegen eines Dashlets kann Ihnen das nicht passieren, da nach dem Filter auf die CPU-Auslastung gar keine Auswahl einer unpassenden Metrik möglich ist -- beim Umkonfigurieren von Dashlets wird die ursprünglich gewählte Metrik jedoch beibehalten.

Die Lösung ist trivial: Passen Sie Service-Filter und gewählte Metrik in der Dashlet-Konfiguration an. Das gilt natürlich auch für alle anderen Dashlet-Varianten.
