//encoding: utf-8
include::global_attr.adoc[]
= Weboberfläche mit HTTPS absichern
:revdate: :draft
:title: Weboberfläche mit HTTPS absichern
:description: Es gibt viele Gründe, Weboberflächen nur über HTTPS zu betreiben. In diesem Artikel erfahren Sie, wie Sie die Verschlüsselung für eine {CMK}-Instanz aktivieren.
// MFS: Ähem: Gründe? Sicherheit ist wohl am wichtigsten, oder? Evtl. sollten das hervorheben.

{related-start}
xref:web_api#[Konfiguration via HTTP-API]
xref:kerberos#[Single Sign-On mit Kerberos]
xref:ldap#[Benutzerverwaltung mit LDAP/Active Directory]
{related-end}
//SP: Umstellung auf xref-Verweise?
// TK: done
// TK: Aber Links überprüfen: Die 3 haben doch gar nix mit dem Thema zu tun.

//SP: Allgemein: extrem komplexes Thema, vieles musste ich mehrfach lesen (und etliches googlen), um es ohne ausgeprägtes Hintergrundwissen halbwegs verstehen zu können.
// TK: Meine generellen Kommentare stehen im Ticket


== Voraussetzungen

Wenn Sie die Weboberfläche von {CMK} über HTTPS einsetzen möchten, dann müssen Sie auf Ihrem Monitoring-Server -- unabhängig von Ihren Instanzen -- folgende Voraussetzungen schaffen:

* Sie besitzen ein gültiges Server-Zertifikat.
* Das Apache-Modul `mod_ssl` ist installiert und aktiviert.
* Der Server ist über HTTPS erreichbar.
* Das Rewrite- und das Headers-Modul für den Webserver sind vorhanden und geladen.

// Neu.
Was dafür zu tun ist, erklärt dieser Artikel.
// TK: Nur zum Teil: Wie man überprüft, dass `mod_ssl` und das Rewrite- und Headers-Modul für den Webserver da sind, wird nicht beschrieben.

== Apache-Module aktivieren

=== Geladene Module anzeigen

Verwenden Sie das Kommando `apachectl` (alte CentOS- und RHEL-Versionen benötigen möglicherweise stattdessen `httpd`), um eine Liste der geladenen Apache-Module anzuzeigen:

[{shell}]
----
{c-root} *apachectl -M*
Loaded Modules:
 core_module (static)
 so_module (static)
 watchdog_module (static)
 http_module (static)
 log_config_module (static)
 logio_module (static)
 version_module (static)
 unixd_module (static)
 access_compat_module (shared)
 alias_module (shared)
 [...]
----

Sind in der angezeigten Liste `headers_module`, `rewrite_module` und `ssl_module` bereits geladen, können Sie die nächsten beiden Schritte überspringen.

=== Module aktivieren

Die Aktivierung fehlender Module gelingt mit dem Script `a2enmod`. Es legt Softlinks im Ordner `/etc/apache2/mods-enabled` an. Die Datei mit Endung `.load` enthält dabei Anweisungen zum Laden des Moduls, `.conf` die eigentliche Konfiguration des Moduls:

[{shell}]
----
{c-root} *a2enmod ssl*
Enabling module ssl.
To activate the new configuration, you need to run:
  systemctl restart apache2
----

Schlägt `a2enmod` fehl (beispielsweise, weil Sie mit einem älteren RHEL arbeiten), ist die Konfigurationsdatei `/etc/httpd/conf/httpd.conf` dergestalt anzupassen, dass auskommentierte Zeilen `LoadModule` vom `#` befreit werden.

=== Apache neu starten

Nach der Aktivierung der Module muss der Apache-Webserver neu gestartet werden. Falls Ihre Distribution bereits bei der Apache-Installation ein selbst signiertes Zertifikat für Testzwecke erzeugt hat, werfen Sie bitte einen Blick in die Datei `/etc/apache2/mods-enabled/ssl.conf` und prüfen Sie. ob die hier angegebenen Zertifikatsdateien vorhanden sind. 

Ist dies der Fall, starten Sie mit einem der folgenden Befehle den Apache-Webserver neu, beim mittlerweile standardmäßig verwendeten `systemd` ist der erste Befehl zu verwenden:

[{shell}]
----
{c-root} systemctl restart apache2
{c-root} service apache2 restart
{c-root} /etc/init.d/apache2 restart
----

Ist kein automatisch erstelltes Zertifikat vorhanden, warten Sie mit dem Neustart des Apache-Webservers, bis Sie ein Zertifik erhalten oder erstellt haben.

== Zertifikate erhalten

Im Wesentlichen existieren die folgenden Methoden, um an ein Server-Zertifikat zu gelangen:
// TK: Ich würde die Reihenfolge umstellen, ist logischer und ausserdem kommt der Riemen dann am Schluss: 1. oldschoolcsr 2. letsencrypt 3. becomeca

* Sie bezahlen für die xref:oldschoolcsr[Zertifikatsausstellung mittels CSR] (_Certificate Signing Request_).
Je nach Stufe der Validierung wird nur geprüft, ob Sie Webmaster einer Domain sind oder es müssen Handelsregisterauszüge eingereicht werden.
Nachteil: es kostet Geld und verursacht Verwaltungsaufwand.
// TK: Registergericht problematisch: als Info für D kennzeichnen
// MFS: Das prinzipielle Vorgehen ist überall gleich, trade register, oder commercial register
* Sie nutzen xref:letsencrypt[kostenlose Zertifikate von _Letsencrypt_].
Nachteil: Sie müssen entweder Zugriff auf den Server haben, dessen Zertifikate Sie ausstellen wollen (und der muss von außen erreichbar sein), oder Sie müssen im Nameserver Ihrer Domain Einträge anlegen und ändern können.
// TK: "im DNS TXT-Einträge anlegen": ist mir nicht klar, was das bedeutet
* Sie werden Ihre xref:becomeca[eigene _Certificate Authority_ (CA)] und erzeugen Zertifikate selbst.
Nachteil: Sie müssen strikte Sicherheitsregeln einhalten und die CA in die Browser der Nutzer importieren, die {CMK} verwenden sollen.

[#oldschoolcsr]
=== Zertifikate per CSR erhalten

Zertifikate bei einer kommerziellen Certificate Authority signieren zu lassen, war lange Zeit der einzige Weg, von allen Browsern und Betriebssystemen akzeptierte Zertifikate zu erhalten. 
Dieses Verfahren ist heute insbesondere dann noch üblich, wenn lange Gültigkeitszeiträume oder Validierung auf Organisationsebene (Organization Validation, kurz OV) oder höher (Extended Validation, kurz EV) erwünscht ist.
// TK: "Organisationsebene oder höher": ?
//  MFS: bspw. Bestätigtung, dass die Domain checkmk-topsupport.com auch wirklich tribe29 GmbH gehört, ist OV

Die Kosten für dieses Verfahren liegen zwischen gratis (3 Monate Gültigkeit, ein Hostname), wenigen Euro (12 Monate, ein Hostname) und mehreren hundert Euro (24 Monate, mehrere Hostnamen, Validierung auf Organisationsebene).
//SP: Ich würde den ersten Satz teilen, da er sehr lang und unübersichtlich ist. Eine Frage am Rande: Wollen wir wirklich fixe Preise nennen? Preise können sich schnell ändern, es handelt sich um Preise die nicht im Einflussbereich unseres Unternehmens liegen, ist uns jede Änderung bekannt etc.
// TK: Ähnlicher Einwand zu den Preisen. Vielleicht so: von gratis über wenige Euro bis zu mehreren hundert Euro
// TK: Kann man hier nicht eine oder ein paar CA verlinken? Was ist damit? https://www.globalgap.org/de/what-we-do/the-gg-system/certification/Approved-CBs/index.html
// MFS: Die zertifizieren nicht im SSL-Bereich, sondern Zertifizierungsstellen für landwirtschaftliche Normen
// MFS: Zertifizierungsstellen zu verlinken, ist schwierig, weil viele der schnellen günstigen mit IM-Zertifikaten der "großen" als schnelle, günstige Quasi-Reseller auftreten, per Suchmaschine zu suchen oder die vom eigenen Webhoster empfohlene Zertifizierungsstelle zu untzen, ist daher der beste Weg

Der Standardweg ist, zunächst den privaten Server-Schlüssel zu erzeugen.
Diesen Schritt können Sie direkt auf dem Server durchführen können, auf dem Ihre {CMK}-Instanz läuft:
// TK: Zu meinem Verständnis: einen privaten Schlüssel erzeugen, der für das Zertifikat des Servers verwendet werden soll?
// TK: Ist es nicht umgekehrt? Durch CMK bekomme ich erst einen Webserver, für den ich jetzt HTTPS einrichten muss?
// MFS: Ich gehe davon aus, dass CMK bereits läuft, bislang unverschlüsselt. Zunächst muss dafür der private Serverschlüssel erzeugt werden, der auf dem Server verbleiben kann

[{shell}]
----
{c-root} *mkdir /etc/certs*
{c-root} *cd /etc/certs*
{c-root} *openssl genrsa -out checkmk.mydomain.com.key 2048*
----
// TK: Kommandoausgabe sagt, dass ich einen "RSA private key" erzeuge: siehe Frage von oben?
// MFS: Das ist korrekt, dieser Schlüssel dient später dazu, den TLS-Verkehr zu verschlüsseln

Im nächsten Schritt erstellrn Sie das "Certificate Signing Request":

[{shell}]
----
{c-root} *openssl req -new -key checkmk.mydomain.com.key -out checkmk.mydomain.com.csr*
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
---
Country Name (2 letter code) [AU]: *DE*
State or Province Name (full name) [Some-State]: *Bavaria*
Locality Name (eg, city) []: *Munich*
Organization Name (eg, company) [Internet Widgits Pty Ltd]: *Yoyodyne Inc.*
Organizational Unit Name (eg, section) []:
Common Name (e.g. server FQDN or YOUR name) []: *checkmk.mydomain.com*
Email Address []: *webmaster@mydomain.com*

Please enter the following 'extra' attributes
to be sent with your certificate request
A challenge password []:
An optional company name []:
----

// Achten Sie darauf, die Angaben zum Unternehmen korrekt anzugeben und als `Common Name` den Server-Namen einzutragen. Die eingetragene E-Mail-Adresse sollte in derselben Domain liegen und zu einem existierenden und gelesenen Postfach gehören.
// TK: im Bsp. als Common Name checkmk.mydomain.com?
//SP: Wo werden die Angaben eingetragen? Kann hier ein Screenshot oder ähnliches eingefügt werden?
// TK: Hier zumindest schreiben, dass mit diesem Kommando diverse Eingaben abgefragt werden (Location, Org, Server-Name, E-Mail...) + Verweis auf das becomeca Kapitel, in dem die beiden Kommandos genau vorgestellt werden.
// Die CSR-Datei wird nun per Webformular an den Zertifikatsdienstleister übertragen.
// TK: So schnell geht es doch wohl nicht, oder? Das klingt so, als ob per openssl genrsa Kommando ein Webformular geöffnet wird.
// TK: Die generierte Dateien checkmk.mydomain.com.csr und checkmk.mydomain.com.key müssen anschließend zur CA geschickt werden, idR per Webformular der CA
// Je nach Validierungsstufe kann es sein, dass zusätzliche Dokumente wie ein Handelsregistereintrag beigefügt werden müssen.
// TK: Handelsregistereintrag problematisch: als Info für D kennzeichnen
// MFS: englischsprachig commercial register oder trade register, Verfahren ist letztlich überall gleich
// Im einfachsten Fall der reinen Domain-Validierung besteht diese darin, dass das Zertifikat einfach an `webmaster@mydomain.com` oder `postmaster@mydomain.com` geschickt wird. 
// TK: Ist dieser einfachste Fall etwas, was ich ich im Webformular an die CA auswählen kann?
// TK: Und muss die EMail dann die sein, die ich in der CSR-Datei hinterlegt habe? 
// MFS: Wie tief Konsistenz der E-Mail-Adresse gegen anderen Quellen geprüft wird (auch Kontakte im Handle des Registrars), ist den Zertifizierungsstellen überlassen 

// MFS: Nochmal am Stück mit neuen Formulierungen:
Achten Sie darauf, die Angaben zum Unternehmen korrekt anzugeben und als `Common Name` den Server-Namen einzutragen. Die eingetragene E-Mail-Adresse sollte in derselben Domain liegen und zu einem existierenden und gelesenen Postfach gehören.

Die CSR-Datei wird anschließend per Webformular an den von Ihnen ausugewählten Zertifikatsdienstleister übertragen.
Je nach Validierungsstufe kann es sein, dass zusätzliche Dokumente wie ein Handelsregistereintrag beigefügt werden müssen.
Im einfachsten Fall der reinen Domain-Validierung besteht diese darin, dass eine E-Mail mit Bestätigungslink an `webmaster@mydomain.com` oder `postmaster@mydomain.com` geschickt wird. Das fertige Zertifikat kann dann aus dem Webfrontend des Dienstleisters heruntergeladen werden oder es wird ebenfalls per E-Mail zugestellt.

==== Upload des CSR

Die folgenden Screenshots zeigen beispielhaft die wesentlichen Schritte bei Verwendung der Online-Formulare des Dienstleisters link:https://www.zerossl.com/[ZeroSSL^]. Die Verlinkung stellt dabei keine Empfehlung dar, ZeroSSL eignet sich jedoch der wegen drei möglichen 90-Tage-Gratis-Zertifikate pro Nutzerkonto gut für Tests. Die folgenden Screenshots zeigen die für die Zertifikatsanforderung relevanten Schritte

Zunächst wird die Domain angegeben, für die das Zertifikat ausgestellt werden soll. Je nach Dienstleister sind auch Multidomain-Zertifikate mit unterschiedlicher Flexibilität (und Preisgestaltung) möglich:

image::omd_https_zerossl_step01.png[]

Es folgt der Upload des zuvor erzeugten CSR. Einige Zertifizierungsstellen bieten an, Schlüssel und CSR online zu erzeugen. Verzichten Sie aus Sicherheitsgründen darauf und laden Sie die selbst erzeugte Signierungsanfrage hoch:

image::omd_https_zerossl_step02.png[]

==== Erhalten des Zertifikates

Meist müssen Sie jetzt die Laufzeit angeben (und sich damit für ein Preismodell entscheiden) und daraufhin die E-Mail-Adresse wählen, an die ein Validierungslink oder ein Token (Zeichenkette) für die Eingabe in ein Formular verschickt wird.

image::omd_https_zerossl_step03.png[]

Befolgen Sie die Anweisungen in der E-Mail an die ausgewählte Adresse. So gelangen Sie zu einem Link zum Download des Zertifikates oder Sie bekommen das Zertifikat in einer weiteren E-Mail zugeschickt.

image::omd_https_zerossl_step04.png[]

In unserem Fall enthielt das heruntergeladene Zip-Archiv zwei Dateien: `certificate.crt` (das eigentliche Zertifikat) und `ca_bundle.crt`, die Verkettung ein oder mehrerer Intermediate-Zertifikate. Sie können mit diesen beiden Dateien nun die xref:configsample[Konfiguration des Apache-Servers] durchführen.

[#letsencrypt]
=== Letsencrypt

Ist ein Server von außen erreichbar oder haben Sie Zugriff auf den Nameserver, können Sie automatisiert Zertifikate über den mit der Electronic Frontier Foundation (EFF) verbandelten Non-Profit-Dienstleister Letsencrypt erstellen lassen.
// TK: Hier Letsencrypt nochmal verlinken
//SP: Bei der ersten Erwähnung einer Bezeichnung (hier: Electronic Frontier Foundation) sollte die Abkürzung in Klammern eingeführt werden. Danach kann dann die Abkürzung eigenständig verwendet werden.
Es entstehen keine Kosten.
Per DNS validierte Zertifikate erfordern alle 90 Tage etwas Aufmerksamkeit, per Server-Verzeichnis validierte Zertifikate können Jahre lang automatisch neu erzeugt werden. 

Für Letsencrypt-Zertifikate stellt die EFF das Python-Programm Certbot in vielen verschiedenen Paketformaten bereit.
Der Certbot übernimmt die Erstellung des Schlüssels und den Versand der CSR.
Er kommuniziert aber auch über das ACME-API mit den Letsencrypt-Servern und legt Dateien im Unterverzeichnis `.well-known` des Webroot an, mit denen die Inhaberschaft der Domain verifiziert wird.
//SP: Die Inhaberschaft wovon? Der Absatz ist insgesamt heftig, da gefühlt zu mehr als der Hälfte aus Fachbegriffen bestehend.
// MFS: Ich habe nun "Domain" eingetragen, der Begriff impliziert auch Subdomains bezw. Wildcard-Domains oder halt einzelne Hostnamen.

Bei einem frisch aufgesetzten Apache, der aus dem Internet erreichbar ist und nur {CMK} bereitstellt, können Sie der Anleitung für `certbot --apache` im link:https://certbot.eff.org/[Certbot-Handbuch^] folgen. 
Hier passt das Skript die Konfiguration selbsttätig an und fügt die richtigen Pfade zu den Zertifikatsdateien ein.
Ist der {CMK}-Server nicht aus dem Internet erreichbar, aber Sie verwenden einen DNS-Anbieter, für den ein link:https://certbot.eff.org/docs/using.html#dns-plugins[Certbot-Plugin^], folgen Sie bitte der Anleitung für Wildcard-Zertifikate.
//SP: erster Satz:Ist mit Apache ein Apache-Server gemeint? Ein Apache ist ein Indianer. letzter Satz: hinter "für den ein Certbot-Plugin" fehlt IMHO ein Verb, z.B. existiert oder vorliegt.
// TK: Warum benennst Du die Fälle unterschiedlich: "Bei einem frisch aufgesetzten Apache, der aus dem Internet erreichbar ist und nur {CMK} bereitstellt" und "Ist der {CMK}-Server nicht aus dem Internet erreichbar"?
// TK: Der 1. certbot Link geht nicht in die Doku, sondern auf die Website.
// TK: Entweder Du verlinkst direkt in die Anleitungen oder paraphrasierst die Überschriften, so dass man Sie wiederfinden kann. Zum Stichwort certbot --apache hab ich was gefunden, weiss aber nicht, ob es das ist, was Du meinst.

Existiert kein Plugin, können Sie alle 90 Tage eine manuelle DNS-Validierung vornehmen. Dafür genügt der minimale Certbot ohne Apache-Plugin. 

[{shell}]
----
{c-root} *certbot -d 'checkmk.mydomain.com' --manual \
   --preferred-challenges dns certonly*
----

Die erstellten Zertifikate werden dann im Ordner `/etc/letsencrypt/live` abgelegt. 




[#becomeca]
=== Selbst Certificate Authority werden

Sie können sich selbst in die Rolle einer CA versetzen und Zertifikate für beliebige Domains (auch Phantasie-Domains) ausstellen. 
Allerdings müssen Sie allen Clients, die auf Instanzen zugreifen sollen, die diese Zertifikate nutzen, beibringen, dass zu vertrauen ist.
//SP: Den vorherigen Satz finde ich zu verschachtelt. Wem ist hier zu vertrauen?
Diese Methode ist vor allem für Testumgebungen oder abgeschottete {CMK}-Server mit überschaubarer Nutzerzahl sinnvoll.
Sie ist zudem die einzige Möglichkeit, Zertifikate zu erhalten, wenn Sie intern eine der vier reservierten TLDs `.example`, `.invalid`, `.localhost`, oder `.test` verwenden.
// TK: Echt? Why?
In Umgebungen, in denen ein Samba 4 Active Directory Domain Controller Nutzer- und Maschinenkonten verwaltet, ist dies der Standardweg.
// TK: Hm, was soll mir dieser Satz sagen?

Selbst wenn eine Person auf einem Rechner alle Schritte durchführt:
Um die Rollenverteilung im Zertifizierungsprozess zu verdeutlichen, nutzen wir _Carla_ als Verwalterin der _Certificate Authority_, _Bob_ als Betreuer des _Intermediate Keys_ und schließlich _Alice_, die Administratorin, die _Server-Zertifikate_ signieren lässt.
// TK: Bob als Betreuer des Intermediate Keys: Warum nicht des Intermediate-Zertifikats?


==== Sicherheitshinweise 

* Diese Anleitung verzichtet auf die _Certificate Revocation List_. In Produktivumgebungen sollten Sie unbedingt eine verwenden, um kompromittierten Schlüsseln schnell das Vertrauen entziehen zu können!
//SP: Was meint "verzichtet darauf"? Nur auf die Beschreibung einer Zertifikatssperrliste oder auch auf deren Einsatz? 
* Auch in Testumgebungen gilt, dass starke Passwörter verwendet und private Schlüssel gut gesichert werden müssen, denn mit dem verwendeten CA-Schlüssel können Zertifikate für beliebige Domains erstellt werden.
Systeme, die dem Zertifikat eines "verlorenen" Schlüssels vertrauen, sind damit anfällig für Woman-in-the-Middle-Angriffe!
//SP: Trotz meiner Begeisterung für diesen Versuch der Geschlechter-Gleichstellung: Unter dem Begriff Woman-in-the-middle findet man im Internet keine Erklärung.
// TK: Ich find diesen Stolperstein trotzdem gut :-)


[#cakey]
==== Schlüssel für die CA und Root-Zertifikat erstellen

Carla nutzt ein Notebook ohne Internetverbindung, um den Root-Schlüssel der CA zu erzeugen und Zwischenzertifikate zu signieren.
// TK: Warum Notebook ohne Internetverbindung? Könnte das was mit Sicherheit zu tun haben?
Zunächst erstellt sie unter `/home/carla/ca` die Verzeichnisstruktur für die Zertifizierungsstelle:

[{shell}]
----
carla@nb:~$ *for d in certs newcerts crl private ; do mkdir -p ~/ca/$d ; done*
carla@nb:~$ *for f in index.txt serial ; do touch ~/ca/$f ; done*
----

Im Ordner `~/ca/`  legt sie eine Datei `ca.cnf` ab, von der wir ein Beispiel vorbereitet und am xref:appendix[Ende dieses Artikels angehängt] haben.
Anschließend erstellt sie den privaten Schlüssel der CA, der AES256-verschlüsselt abgelegt und mit einer langen Passphrase versehen wird:

[{shell}]
----
carla@nb:~$ *cd ca*
carla@nb:~/ca$ *openssl genrsa -aes256 -out private/ca.key.pem 4096*
Generating RSA private key, 4096 bit long modulus (2 primes)
.............pass:q[++++]
..........pass:q[++++]
e is 65537 (0x010001)
Enter pass phrase for private/ca.key.pem:
Verifying - Enter pass phrase for private/ca.key.pem:
----

Es folgt das Root-Zertifikat, hier mit einer Gültigkeit von zwölf Jahren und zwei Wochen – mehr zur Wahl der xref:timerange[Gültigkeitszeiträume weiter unten].
Die relevanten Parameter für Ort und Unternehmen werden aus der Konfigurationsdatei `ca.cnf` übernommen. _Common Name_ und _Email Address_ sind auf sinnvolle Werte zu setzen:

[{shell}]
----
carla@nb:~/ca$ *openssl req -config ca.cnf  -new \
    -key private/ca.key.pem -x509 -days 4398 \
    -sha256 -extensions v3_ca -out certs/ca.cert.pem*
Enter pass phrase for private/ca.key.pem:
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
---
Country Name (2 letter code) [DE]:
State or Province Name [Bavaria]:
Locality Name [Munich]:
Organization Name [Stark Industries Ltd.]:
Organizational Unit Name []:
Common Name []: *Stark Industries Root Certificate*
Email Address []: *carla@starkindustries.test*
----

Anschließend prüft Carla das Root-Zertifikat mit dem Befehl:

[{shell}]
----
carla@nb:~/ca$ *openssl x509 -noout -text -in certs/ca.cert.pem*
Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number:
            25:a0:77:02:e7:29:07:f7:b5:d5:ba:b5:a3:4e:2b:eb:b3:e7:a6:c0
        Signature Algorithm: sha256WithRSAEncryption
        Issuer: C = DE, ST = Bavaria, L = Munich, O = Stark Industries Ltd., CN = Stark Industries Root Certificate, emailAddress = carla@starkindustries.test
        Validity
            Not Before: Feb 15 14:52:12 2022 GMT
            Not After : Mar 2 14:52:12 2034 GMT
        Subject: C = DE, ST = Bavaria, L = Munich, O = Stark Industries Ltd., CN = Stark Industries Root Certificate, emailAddress = carla@starkindustries.test
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
                RSA Public-Key: (4096 bit)
                Modulus:
                    00:d7:a9:89:94:dd:02:66:bf:fd:8e:c2:70:4b:d0:
[...]
----

Carla kopiert die Konfigurationsdatei `ca.cnf` und stellt sie dem Kollegen Bob zur Verfügung, damit er eine Vorlage hat, die passende Parameter sowie Unternehmensnamen und -standort in korrekter Schreibweise enthält.


==== Das Intermediate-Zertifikat

Bob ist derjenige, der die tägliche Arbeit mit Zertifikaten für das lokale Netzwerk durchführt.
Seine Aufgabe ist es, mit einem Intermediate-Zertifikat die Server-Schlüssel zu signieren, die Administratorinnen und Administratoren an ihn herantragen.
// TK: Jetzt wird mit einem Zertifikat ein Schlüssel signiert?
Auch er erstellt zunächst eine Verzeichnisstruktur und verwendet dafür den Ordner `im` in seinem Heimatverzeichnis:


[{shell}]
----
bob@pc:~$ *for d in certs newcerts crl private ; do mkdir -p ~/im/$d ; done*
bob@pc:~$ *for f in index.txt serial ; do touch ~/im/$f ; done*
----

Im Ordner `im` legt er die von Carla erhaltene Konfigurationsdatei als `im.cnf` ab und passt darin die Standardpfade auf sein Heimatverzeichnis und seine Rolle an.
Anschließend erstellt auch er einen Private Key, mit dem er die nächsten Jahre arbeiten wird:

[{shell}]
----
bob@pc:~$ *cd im*
bob@pc:~/im$ *openssl genrsa -aes256 -out private/im.key.pem 4096*
----

Im nächsten Schritt erstellt er das Certificate Signing Request für diesen Schlüssel:

[{shell}]
----
bob@pc:~/im$ *openssl req -config im.cnf -new -sha256 \
    -key private/im.key.pem -out certs/imbob.csr*
[...]
Country Name (2 letter code) [DE]:
State or Province Name [Bavaria]:
Locality Name [Munich]:
Organization Name [Stark Industries Ltd.]:
Organizational Unit Name []:
Common Name []: *Bobs Intermediate Certificate*
Email Address []: *bob@starkindustries.test*
----

Mit der Datei `imbob.csr` geht Bob auf einen Kaffee zu Carla ins Büro.
Diese holt das Notebook mit der CA aus dem Tresor, kopiert Bobs CSR in ihren Ordner `certs` und signiert Bobs CSR – hier mit einer Laufzeit von vier Jahren und zwei Wochen:
// TK: ... und macht durch die Signatur aus dem CSR ein Zertifikat?

[{shell}]
----
carla@nb:~$ *cd ca*
carla@nb:~/ca$ *openssl ca -config ca.cnf \
    -extensions v3_intermediate_ca \
    -days 1476 -rand_serial -notext -md sha256 \
    -in certs/imbob.csr -out certs/imbob.pem*
----
// TK: Wenn schon keine Kommandoausgabe, dann zumindest, was abgefragt wird: Passphrase für ca.key.pem, Anzeige des Zertifikats und Bestätigung der Signatur 

Carla gibt Bob nun die beiden PEM-Dateien `ca.cert.pem` und `imbob.pem` mit, fährt das Notebook wieder herunter und packt es in den Tresor.
Zurück an seinem Rechner packt Bob beide Dateien in den Ordner `~/im/certs`. 


==== Schlüssel für die erste {CMK}-Instanz erstellen
// TK: Erste? Mehr kommen doch nicht.

Alice ist Administratorin der {CMK}-Server bei _Stark Industries Ltd_.
Für die Absicherung eines neuen {CMK}-Servers erstellt sie zunächst den Server-Schlüssel.
Hier ist es pragmatisch, keine Passphrase zu verwenden, also auf `-des3` oder `-aes256` zu verzichten.
Sonst müsste diese Passphrase bei jedem Start des Servers eingegeben werden.
Als Dateiname ist der Host-Name des Servers sinnvoll.

[{shell}]
----
alice@pc:~$ *openssl genrsa -out checkmk.starkindustries.test.key 2048*
Generating RSA private key, 2048 bit long modulus (2 primes)
.................................pass:q[++++]
.......pass:q[++++]
e is 65537 (0x010001)
----

Es folgt die Erstellung des CSR.
Wieder müssen die Fragen nach Firma und Abteilung beantwortet werden.
Wichtig ist hier der _Common Name_, welcher dem Host-Namen des Servers entsprechen muss.
Eine Konfigurationsdatei ist für Alice optional:

[{shell}]
----
alice@pc:~$ *openssl req -new -key checkmk.starkindustries.test.key \
    -out checkmk.starkindustries.test.csr*
[...]
Country Name (2 letter code) [DE]:
State or Province Name [Bavaria]:
Locality Name [Munich]:
Organization Name [Stark Industries Ltd.]:
Organizational Unit Name []:
Common Name (e.g. server FQDN or YOUR name) []: *checkmk.starkindustries.test*
Email Address []: *alice@starkindustries.test*

Please enter the following 'extra' attributes
to be sent with your certificate request
A challenge password []:          
An optional company name []:
----

Das Challenge-Passwort darf leer bleiben.
Da der {CMK}-Server unter verschiedenen Host-Namen erreichbar ist, erstellt Alice eine `X509 V3 certificate extension` Konfigurationsdatei `checkmk.starkindustries.test.ext`:

./home/alice/checkmk.starkindustries.test.ext
[source]
----
authorityKeyIdentifier=keyid,issuer
basicConstraints=CA:FALSE
keyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment
subjectAltName = @alt_names

[alt_names]
DNS.1 = checkmk.starkindustries.test
DNS.2 = monitoring.starkindustries.test
----
// TK: Wie wirkt sich denn diese Konfigdatei im folgenden aus?


==== Signieren der Zertifikate
// TK: Warum Plural? Es wird doch nur das Zertifikat für den Server signiert? Oder Plural, weil 2 Host-Namen in der Konfigdatei stecken?

Mit den beiden Dateien `checkmk.starkindustries.test.csr` und `checkmk.starkindustries.test.ext` im Gepäck lädt sich Alice bei Bob auf einen Kaffee in dessen Büro ein.
// TK: Zur Abwechslung auf einen Becher Tee?
Bob signiert nun mit seinem Intermediate-Zertifikat das mitgebrachte CSR mit einem Jahr Gültigkeit:

[{shell}]
----
bob@pc:~$ *cd im*
bob@pc:~/im$ *openssl x509 -CAcreateserial -req \
    -in certs/checkmk.starkindustries.test.csr \
    -CA certs/imbob.pem -CAkey private/im.key.pem \
    -out certs/checkmk.starkindustries.test.crt -days 365 \
    -sha256 -extfile certs/checkmk.starkindustries.test.ext*
----

Alice erhält von Bob drei Dateien: `ca.cert.pem` und `imbob.pem` stellen die Zertifikatskette dar und `checkmk.starkindustries.test.crt` ist das zum Serverschlüssel `checkmk.starkindustries.test.key` gehörende Zertifikat.
// TK: Aber ca.cert.pem braucht sie doch gar nicht? Jedenfalls wird das Root-Zertifikat nicht in die Konfigdatei geschrieben.
Diese Dateien kann sie bereits xref:configsample[auf dem Server ausrollen].


==== Importieren der CA
// TK: Ist das nicht ein Thema, *nachdem* der Webserver konfiguriert wurde?
// TK: Ich hab leider kein klares Bild, was ich wo und wann tun muss.

Die Wege, eine CA als vertrauenswürdig zu importieren, unterscheiden sich von Browser zu Browser.
// TK: oder: eine vertrauenswürdige CA hinzuzufügen durch Import eines von der CA ausgestellten Zertifikats?
Meist genügt es, das Zertifikat `ca.cert.pem` unter  [.guihint]#Einstellungen > Datenschutz und Sicherheit > Zertifikate > Importieren# hinzuzufügen. 

// MFS: Screenshot Import ? 
// MFS: Screenshot Sicherheitshinweis ?

Damit die Zertifikatsverwaltung kein Stolperstein beim automatischen Agenten-Update darstellt, haben wir in der Agentenbäckerei die Möglichkeit vorgesehen, ein eigenes CA-Zertifikat zu übergeben, das nur für Agenten-Updates benutzt wird.
// TK: Wie? Per Regel? Global Setting? Wo beschrieben?
Die Systemzertifikate werden hierbei nicht angetastet, Agenten-Updates sind dennoch möglich.
// TK: Was meinst Du hier mit Systemzertifikaten? Kommt auch nochmal etwas später für Windows.

Alternativ können Sie das Root-Zertifikat in der lokalen CA-Datenbank integrieren.
// TK: Alternativ wozu? Zum Import in den Browser?
Kopieren Sie dafür die Datei `ca.cert.pem` nach `/usr/local/share/ca-certificates/starkindustries.crt`.
Anschließend generieren Sie den Cache neu:

[{shell}]
----
{c-root} *update-ca-certificates*
----

Unter Windows ist es möglich, die Systemzertifikate über ein MMC-Snap-In zu verwalten.
//SP: Weiß (außer mir) jeder Leser was ein MMC-Snap-In ist?
// TK: Dann aber auch hinschreiben, dass das Snap-In Certificates heisst.
Dies ist beispielsweise nötig, wenn Sie einen Microsoft-Browser verwenden wollen, um auf ein mit eigener CA abgesichertes {CMK} zuzugreifen.
Das genaue Vorgehen können Sie im link:https://docs.microsoft.com/de-de/troubleshoot/windows-server/windows-security/import-third-party-ca-to-enterprise-ntauth-store#method-1---import-a-certificate-by-using-the-pki-health-tool[Microsofts Knowledge Base Artikel PKI^] nachlesen.
Alternativ können Sie Zertifikate per link:https://docs.microsoft.com/de-de/mem/intune/protect/certificates-configure[Intune^] verteilen.


[#timerange]
==== Zertifikatslaufzeit und -kaskaden

Die gesamte Zertifikatskaskade funktioniert nur, während alle Zertifikate gültig sind.
Daher sollte über Laufzeiten Buch geführt und an jeder Stelle der Kette rechtzeitig ein neues Zertifikat erstellt werden.
Wenn die Laufzeit von Carlas Root-Zertifikat zwölf Jahre beträgt und sie damit maximal vier Jahre gültige Intermediate-Zertifikate für Bob ausstellt, muss sie sich rechtzeitig vor Ablauf von acht Jahren ein neues Root-Zertifikat ausstellen und künftig dieses zum Signieren benutzen.
Bob wiederum, der maximal zwei Jahre gültige Zertifikate ausstellt, muss alle zwei Jahre auf einen Kaffee bei Carla vorbeischauen, um ein neues, vier Jahre gültiges Zertifikat zu erhalten. 

Alice weiss, dass Bob nur zwei Jahre gültige Server-Zertifikate ausstellen kann.
Sollte Alice im Zuge der Expansion von Stark Industries sehr viele Server-Zertifikate benötigen, kann Bob als Inhaber eines Intermediate-Zertifikats für Alice ein weiteres Intermediate-Zertifikat mit zwei Jahren Gültigkeit erstellen.
So kann Alice dann in die Rolle einer ihm untergeordneten CA schlüpfen, die Zertifikate mit einem Jahr Gültigkeit ausstellt.
// TK: Frage am Rande: Nennt man auch den Aussteller eines Intermediate-Zertifikats eine CA? Oder ist die CA der ganze Laden, der das Root-Zertifikat ausstellt?
In diesem Fall muss sie jährlich bei Bob vorbeischauen.

Im unten beschriebenen xref:configsample[Konfigurationsbeispiel] muss dann nicht Bobs Intermediate-Zertifikat auf dem Server platziert werden, sondern eine Konkatenation aus Bobs und Alice' Intermediate-Zertifikaten.

[#configsample]
== Konfiguration der HTTPS-Verbindung für eine Instanz
// TK: Hier den Zusammenhang zu den 3 Optionen von oben deutlicher machen, d.h. z.B. im Fall becomeca muss ich die folgenden Einträge machen...
// TK: Reihenfolge von oben auch hier beibehalten.

// New
Zunächst müssen Sie in der SSL-Konfigurationsdatei die korrekten Pfade zu Schlüssel, Zertifikat und Intermediate-Zertifikat angeben. Die Konfigurationsdatei ist in der Regel, `/etc/apache2/sites-enabled/default-ssl.conf`, der Pfad kann jedoch bei älteren Distributionen abweichen.
//SP: Was ist ein IM-Zertifikat?
// MFS: Wird weiter oben verwendet: Intermediate Certificate, nun ausgeschrieben, für alle, die direkt hier hin springen

=== Zertifikat wurde von kommerzieller Zertifizierungsstelle ausgestellt

Falls Sie Zertifikate von einem kommerziellen Anbieter signieren lassen haben, hat Ihnen dieser auch mitgeteilt, ob ein `SSLCertificateChainFile` benötigt wird und dieses gegebenenfalls mitgeschickt. Im oben gezeigten Beispiel mit ZeroSSL sähe die Konfiguration wie folgt aus:

./etc/apache2/sites-enabled/default-ssl.conf
[source,apache]
----
SSLEngine on
SSLCertificateKeyFile /etc/certs/checkmk.mydomain.com.key
SSLCertificateChainFile /etc/certs/ca_bundle.crt
SSLCertificateFile /etc/certs/certificate.crt
----

=== Zertifikat wurde mithilfe von Letsencrypt generiert

Der Letsencrypt-Certbot legt Zertifikate und automatisch erzeugte Schlüssel in `/etc/letsencrypt` ab:
// TK: nicht nur Zertifikate, sondern auch Schlüssel

./etc/apache2/sites-enabled/default-ssl.conf
[source,apache]
----
SSLEngine on
SSLCertificateKeyFile /etc/letsencrypt/live/checkmk.starkindustries.test/privkey.pem
SSLCertificateChainFile /etc/letsencrypt/live/checkmk.starkindustries.test/chain.pem
SSLCertificateFile /etc/letsencrypt/live/checkmk.starkindustries.test/cert.pem
----

=== Zertifikat wurden mit eigener CA ausgestellt

// TK: Im nächsten Kapitel steht: "Unter Debian/Ubuntu ist das standardmäßig die Datei `default-ssl.conf`". Heisst das, dass diese Datei in anderen Distributionen anders heissen kann? Dann sollte das schon hier erwähnt werden.
./etc/apache2/sites-enabled/default-ssl.conf
[source,apache]
----
SSLEngine on
SSLCertificateKeyFile /etc/certs/checkmk.starkindustries.test.key
SSLCertificateChainFile /etc/certs/imbob.pem
SSLCertificateFile /etc/certs/checkmk.starkindustries.test.crt
----
// End new

=== Konfiguration der Apache Default Site 

// Small change in wording
Die `VirtualHost`-Konfiguration befindet sich -- je nach eingesetzter Distribution -- in einer dieser Dateien:

[cols=2]
|===

|Debian, Ubuntu |/etc/apache2/sites-enabled/000-default(.conf)
|RHEL, CentOS |/etc/httpd/conf.d/ssl.conf
|SLES |/etc/apache2/httpd.conf
|===

Ergänzen Sie im Abschnitt für den `VirtualHost` folgende Zeilen:
// TK: Umstellen: Zuerst beschreiben, dass die Datei in den Distros unterschiedlich ist und dann das Bsp. für Debian/Ubuntu
// Lines and comments added.
// MFS: Für eine bessere Lösung sollte der Block  <IfModule headers_module>
// mit unserer Konfiguration ausgeliefert werden. Siehe auch:
// https://forum.checkmk.com/t/include-apache-config-for-x-forwarded-proto/29869

./etc/apache2/sites-enabled/000-default
[source,apache]
----
RewriteEngine On
# No forwarding for .well-known when using LetsEncrypt
RewriteCond %{REQUEST_URI} !^/.well-known
RewriteCond %{SERVER_PORT} !^443$
RewriteRule (.*) https://%{HTTP_HOST}$1 [L]
# This section passes the system Apaches connection mode to the 
# instance Apache. Make sure mod_headers is enabled, otherwise it
# will be ignored and "Analyze configuration" will issue "WARN".
<IfModule headers_module>
    RequestHeader set X-Forwarded-Proto expr=%{REQUEST_SCHEME}
    RequestHeader set X-Forwarded-SSL expr=%{HTTPS}
</IfModule>
----

Nach der Konfigurationsänderung muss der Webserver neu gestartet werden.
Je nach eingesetzter Distribution sind die Befehle dafür unterschiedlich:

[{shell}]
----
{c-root} service httpd restart
{c-root} service apache2 restart
{c-root} systemctl restart httpd
{c-root} systemctl restart apache2
----
// TK: Welcher Befehl für welche Distribution?

== Zusätzliche Optionen

// Das da muss Mattias alles nochmal durchspielen, das ganze Perfect Forward Security Kapitel braucht Aufmerksamkeit
// TK: Dieses Kapitel ist merkwürdig aufgebaut: Warum der Titel "Zusätzliche Optionen", wenn wir nur eine (HSTS) beschreiben? 
// TK: Die Besonderheiten sollten nach vorne, damit man zuerst die möglichen Auswirkungen anschauen kann, bevor man die Konfig durchzieht.

=== HSTS einrichten

Den {CMK}-Server nur noch mittels HTTPS erreichbar zu machen, ist der erste und wichtigste Schritt, um Verbindungen zum Monitoring abzusichern.
Erhöhen kann man die Sicherheit aber mit zusätzlichen, optionalen Einstellungen.
So kann der Webserver dem Browser mitteilen, dass er in Zukunft bitte nur noch über HTTPS angesprochen werden soll und eine ungesicherte Verbindung über HTTP immer abgelehnt wird.

Diese Technik nennt sich HTTP Strict Transport Security (HSTS) und wird für einen bestimmten Zeitraum in Sekunden gesetzt.
Ist dieser Zeitraum abgelaufen, prüft der Browser erneut, ob die Limitierung über HSTS weiterhin gültig ist.
Um die Option zu setzen, fügen Sie den folgenden Eintrag der HTTPS-Konfiguration hinzu.
Unter Debian/Ubuntu ist das standardmäßig die Datei `default-ssl.conf`:

./etc/apache2/sites-enabled/default-ssl.conf
[source,apache]
----
Header always set Strict-Transport-Security "max-age=31536000"
----

*Wichtig*: Setzen Sie zunächst einen kurzen Zeitraum -- z.B. 3600 Sekunden --, um die Einstellung zu testen, da es sein kann, dass ansonsten die Verbindung im Fehlerfall dauerhaft abgelehnt wird!
Mehr dazu auch bei den xref:hsts_specifics[Besonderheiten].

Um zu sehen, ob die neue Einstellung funktioniert, können Sie mit Hilfe des Programms `curl` den Server abrufen.
Hier in der Ausgabe nur die ersten 4 Zeilen:

[{shell}]
----
{c-root} curl -I \https://myHost/mySite/check_mk/login.py
HTTP/1.1 200 OK
pass:q[*Date*]: Tue, 01 Jun 2021 09:30:20 GMT
pass:q[*Server*]: Apache
pass:q[*Strict-Transport-Security*]: max-age=3600
----


[#hsts_specifics]
==== Besonderheiten

Die Einrichtung von HSTS hat nicht nur den Vorteil der Sicherstellung, dass nur sichere Verbindungen genutzt werden.
Der Einsatz bringt auch bestimmte Besonderheiten mit sich, derer man sich _vor_ der Umstellung bewusst sein muss:

* Ist der Eintrag zu dem HSTS einmal vom Browser des Benutzers angelegt, kann er -- zumindest vor Ablauf der Zeit -- nur mit entsprechendem Detailwissen zu dem jeweiligen Browser entfernt werden. Beachten Sie, dass das auf viele Benutzer nicht zutrifft.
//SP: eventuell: Beachten Sie, dass viele Benutzer dieses Wissen nicht haben.
* Die Verbindung wird u.a. dann abgelehnt, wenn das Zertifikat abgelaufen ist oder durch ein selbst-signiertes ausgetauscht wurde.
Solche Seiten können auch nicht mit einer Ausnahme umgangen werden.
//SP: Was heißt "die Seite kann nicht umgangen werden"? Was ist hier mit Ausnahmen gemeint?
* HSTS wird umgekehrt nur dann berücksichtigt, wenn dem Zertifikat beim ersten Verbindungsaufbau *vertraut* wird.
Ansonsten legt der Browser keinen Eintrag zum HSTS an, so dass der zusätzliche Schutzmechanismus nicht benutzt wird.

[#appendix]
== Appendix 
// (Blinddarm)

Die Konfigurationsdatei `/home/carla/ca/ca.cnf` kopiert (und überschreibt damit) viele Abschnitte der systemweiten `openssl.cnf`.
Kopieren Sie diese Datei als Basis für die eigene CA-Konfiguration (xref:cakey[zurück zur Schlüsselerzeugung]):
// TK: Hier erwähnen, dass man erstmal nur eine Zeile (dir) anpassen muss.

./home/carla/ca/ca.cnf
[source]
----
# OpenSSL root CA configuration file.
# Copy to `/home/username/ca/ca.cnf`.

[ ca ]
# `man ca`
default_ca = CA_default

[ CA_default ]
# Directory and file locations.
dir               = /home/carla/ca
certs             = $dir/certs
crl_dir           = $dir/crl
new_certs_dir     = $dir/newcerts
database          = $dir/index.txt
serial            = $dir/serial
RANDFILE          = $dir/private/.rand

# The root key and root certificate.
private_key       = $dir/private/ca.key.pem
certificate       = $dir/certs/ca.cert.pem

# For certificate revocation lists.
crlnumber         = $dir/crlnumber
crl               = $dir/crl/ca.crl.pem
crl_extensions    = crl_ext
default_crl_days  = 30

# SHA-1 is deprecated, so use SHA-2 instead.
default_md        = sha256

name_opt          = ca_default
cert_opt          = ca_default
default_days      = 375
preserve          = no
policy            = policy_strict

[ policy_strict ]
# The root CA should only sign intermediate certificates that match.
# See the POLICY FORMAT section of `man ca`.
countryName             = match
stateOrProvinceName     = match
organizationName        = match
organizationalUnitName  = optional
commonName              = supplied
emailAddress            = optional

[ policy_loose ]
# Allow the intermediate CA to sign a more diverse range of certificates.
# See the POLICY FORMAT section of the `ca` man page.
countryName             = optional
stateOrProvinceName     = optional
localityName            = optional
organizationName        = optional
organizationalUnitName  = optional
commonName              = supplied
emailAddress            = optional

[ req ]
# Options for the `req` tool (`man req`).
default_bits        = 2048
distinguished_name  = req_distinguished_name
string_mask         = utf8only

# SHA-1 is deprecated, so use SHA-2 instead.
default_md          = sha256

# Extension to add when the -x509 option is used.
x509_extensions     = v3_ca

[ req_distinguished_name ]
# See <https://en.wikipedia.org/wiki/Certificate_signing_request>.
countryName                     = Country Name (2 letter code)
stateOrProvinceName             = State or Province Name
localityName                    = Locality Name
0.organizationName              = Organization Name
organizationalUnitName          = Organizational Unit Name
commonName                      = Common Name
emailAddress                    = Email Address

# Optionally, specify some defaults.
countryName_default             = DE
stateOrProvinceName_default     = Bavaria
localityName_default            = Munich
0.organizationName_default      = Stark Industries Ltd.
organizationalUnitName_default  =
emailAddress_default            =

[ v3_ca ]
# Extensions for a typical CA (`man x509v3_config`).
subjectKeyIdentifier = hash
authorityKeyIdentifier = keyid:always,issuer
basicConstraints = critical, CA:true
keyUsage = critical, digitalSignature, cRLSign, keyCertSign

[ v3_intermediate_ca ]
# Extensions for a typical intermediate CA (`man x509v3_config`).
subjectKeyIdentifier = hash
authorityKeyIdentifier = keyid:always,issuer
basicConstraints = critical, CA:true, pathlen:0
keyUsage = critical, digitalSignature, cRLSign, keyCertSign

[ usr_cert ]
# Extensions for client certificates (`man x509v3_config`).
basicConstraints = CA:FALSE
nsCertType = client, email
nsComment = "OpenSSL Generated Client Certificate"
subjectKeyIdentifier = hash
authorityKeyIdentifier = keyid,issuer
keyUsage = critical, nonRepudiation, digitalSignature, keyEncipherment
extendedKeyUsage = clientAuth, emailProtection

[ server_cert ]
# Extensions for server certificates (`man x509v3_config`).
basicConstraints = CA:FALSE
nsCertType = server
nsComment = "OpenSSL Generated Server Certificate"
subjectKeyIdentifier = hash
authorityKeyIdentifier = keyid,issuer:always
keyUsage = critical, digitalSignature, keyEncipherment
extendedKeyUsage = serverAuth

[ crl_ext ]
# Extension for CRLs (`man x509v3_config`).
authorityKeyIdentifier=keyid:always

[ ocsp ]
# Extension for OCSP signing certificates (`man ocsp`).
basicConstraints = CA:FALSE
subjectKeyIdentifier = hash
authorityKeyIdentifier = keyid,issuer
keyUsage = critical, digitalSignature
extendedKeyUsage = critical, OCSPSigning
----

xref:cakey[zurück zur Schlüsselerzeugung]
