include::global_attr.adoc[]
= Der Leitfaden für {CMK} Einsteiger
:revdate: draft
:title: Der Leitfaden für Checkmk Einsteiger
:description: Checkmk ist eine komplexe Komplettlösung für Ihr Monitoring. Dieser Einsteigerleitfaden führt kompakt durch die ersten Schritte, um eine optimale Überwachung zu meistern.




*Liebe Leserinnen und Leser,*

wir freuen uns, dass Sie den Weg zu {CMK} gefunden haben -- und dabei auch im {CMK} Handbuch vorbeischauen.

Der reibungslose Betrieb von IT-Systemen war schon immer eine Herausforderung.
Sowohl die Komplexität der Hardware- und Software-Stacks als auch die Ansprüche
der Anwender nehmen immer weiter zu -- egal, ob sie mit echter Hardware oder
mit Cloud-Lösungen arbeiten. So kommt einem detaillierten und umfassenden
IT-Monitoring heute eine zentrale Rolle zu.

So komplex wie die IT-Welt sind natürlich auch die Anforderungen, die
Anwender an ihr Monitoring stellen. {CMK} wurde von Anfang an für große
und heterogene IT-Landschaften entwickelt. Deswegen bietet es eine Fülle
von Funktionen und Möglichkeiten, um all den Problemstellungen gerecht zu
werden, die daraus in der Praxis folgen. Daher ist der Umfang von {CMK} für
einen Einsteiger erst mal überwältigend.

Damit Sie trotzdem schnell und bequem zu Ihrem ersten {CMK}-Monitoring kommen,
haben wir das {CMK} Handbuch für Sie in zwei Teile untergliedert:

. einen Leitfaden für Einsteiger, den Sie gleich im Anschluss in diesem Artikel finden
. einen umfassenden link:index.html#installation[Referenzteil für Experten], der den Rest des Handbuchs umfasst

Der Leitfaden für Einsteiger führt Sie Schritt für Schritt in {CMK}
ein und ist so aufgebaut, dass Sie ihn zügig von Anfang bis Ende lesen und
dabei gleich mitmachen können. Deswegen ist er auch kurz und knapp und hält
sich nicht mit unnötigen Details auf. Am Ende des Leitfadens haben Sie ein
praxisgerechtes {CMK}-System. Im link:intro.html#best_practices[letzten Kapitel]
zeigen wir Ihnen dann noch ein paar sehr nützliche Tipps und Tricks unserer
erfahrenen Consultants, die sich in verschiedenen {CMK}-Installationen bewährt haben.

Natürlich lässt der Leitfaden für Einsteiger noch viele Fragen offen. Diese
werden im ausführlichen link:index.html#installation[Referenzteil] des Handbuchs beantwortet. Dort finden Sie zu Themen, die wir im Leitfaden nur anreißen können, alle Hintergründe und Details um tiefer einzusteigen -- auf Ihrem Weg vom Einsteiger zum {CMK}-Experten.


== {CMK} aufsetzen


[#editions]
=== Edition auswählen

Bevor Sie beginnen, {CMK} zu installieren, müssen Sie sich zuerst entscheiden, welche der vier verfügbaren Editionen Sie einsetzen möchten:

Die {CRE} (*CRE*) ist kostenlos, zu 100{nbsp}%
Open Source und enthält Nagios als Kern. Sie können damit komplexe
Umgebungen umfassend überwachen. Support erhalten Sie in unserem
link:https://forum.checkmk.com[Forum] von der {CMK}-Community.

Die {CFE} (*CFE*) ist für Sie die richtige, wenn Sie die {SE} unverbindlich testen wollen oder {CMK} im kleinen Rahmen mit bis zu zwei Instanzen mit je zehn überwachten Hosts einsetzen möchten. Die {FE} enthält alle Features der {SE} und ist kostenlos. Sowohl die {FE} als auch die {RE} können Sie später ohne Umwege direkt auf die {SE} upgraden.

Die {CSE} (*CEE*) richtet sich vor allem an professionelle
Anwender und bietet über den Umfang der {RE} hinaus eine Reihe
von interessanten Features, wie z.B. statt Nagios mit dem link:cmc.html[{CMK} Micro Core (CMC)] einen sehr performanten eigenen Kern, ein Reporting, ein ausgefeiltes System für die Visualisierung von Messwerten, eine flexible Agentenverteilung und vieles mehr. Für die {SE} können Sie optional von uns oder einem unserer link:https://checkmk.de/find-a-partner.html[Partner] professionellen Support erhalten.

Die {CME} (*CME*) ist eine mandantenfähige Erweiterung der {SE} und verfügt über alle notwendigen Funktionen, um mit {CMK} über das link:distributed_monitoring.html[verteilte Monitoring] voneinander abgeschottete Instanzen für mehrere Kunden zu betreiben. Falls Sie für Ihre Kunden diese Dienste anbieten wollen, ist diese Ihre Edition. Genaueres zum Konzept der Managed Services finden Sie in der Einführung link:managed.html[dieses Artikels].

Eine Aufstellung der Unterschiede zwischen den Editionen finden Sie auf unserer link:https://checkmk.de/editions.html[Homepage].

{cee-only}
Wann immer wir in diesem Handbuch Funktionen besprechen, die nur für eine
der {EE} gelten -- also für die CEE, CFE oder CME -- kennzeichnen wir dies
mit dem Symbol wie in diesem Absatz.


=== Version auswählen

Wir entwickeln alle Editionen von {CMK} ständig weiter, und daher gibt es von jeder Edition verschiedene Versionen. Für den Einstieg empfehlen wir Ihnen grundsätzlich die jeweils neueste stabile Version. Einen detaillierten Überblick, welche Arten von anderen Versionen es außerdem gibt, zeigt link:cmk_versionen.html[dieser Artikel].


=== Die Software installieren

Der {CMK}-Server benötigt grundsätzlich ein Linux-System, auf dem er laufen
kann. (Sie können natürlich trotzdem auch Windows und andere Betriebssysteme überwachen.) Wenn Sie keinen eigenen Linux-Server aufsetzen
möchten, können Sie {CMK} auch mithilfe von Docker oder einer Appliance
betreiben. Insgesamt gibt es vier Möglichkeiten, die wir im folgenden kurz vorstellen und die auf unterschiedliche Weise zu installieren sind. Wenn Sie die Installation Ihrer Variante abgeschlossen haben, lesen Sie im nächsten Kapitel weiter, in der es um die Erstellung einer Instanz geht.


==== Möglichkeit 1: Linux-Server

Die Installation von {CMK} auf einem Linux-Server, egal, ob auf einer „echten“ oder auf einer virtuellen Maschine, ist der Standardfall. Wenn
Sie über Linux-Grundkenntnisse verfügen, ist die Installation sehr einfach. Die komplette Software, die Sie benötigen, ist entweder in Ihrer Linux-Distribution oder in unserem {CMK}-Paket enthalten.

{CMK} unterstützt die Distributionen von Red Hat/CentOS, SLES, Debian
und Ubuntu. Für jede {CMK}-Edition, {CMK}-Version und Linux-Distribution gibt es ein eigenes angepasstes Paket von uns, das Sie mit dem Paketmanager Ihrer Linux-Distribution installieren können. Wie dies genau geht, erfahren Sie im Artikel zur link:install_packages.html[Installation auf Linux-Systemen].


==== Möglichkeit 2: Virtuelle Appliance

Mit der virtuellen Appliance *{CMK} virt1* erhalten Sie eine komplett
eingerichtete virtuelle Maschine im Dateiformat OVA (Open Virtualization Archive), die Sie in einem Hypervisor wie zum Beispiel VirtualBox oder VMware vSphere ESXi verwenden können.

Die virtuelle Appliance enthält neben {CMK} auch das Linux-Betriebssystem Debian 9 (Stretch). Der Vorteil der Appliance ist, neben einem vorinstalliertem System, dass Sie Betriebssystem und {CMK} komplett über eine grafische Oberfläche konfigurieren können, ohne die Linux-Kommandozeile bemühen zu müssen. Dies umfasst auch den Update von Betriebssystem und {CMK}.

{cee-only}
Die virtuelle Appliance ist für alle {EE} verfügbar, für die {FE} als kostenlose Demo-Version. Wie Sie bei der Installation vorgehen müssen, erfahren Sie in der link:cma_virt1_quick_start.html[Schnellstart-Anleitung].


==== Möglichkeit 3: Physische Appliance

Einen Schritt weiter können Sie mit der physischen Appliance (auch Hardware Appliance genannt) gehen, in der {CMK} fertig vorinstalliert und sofort einsetzbar auf einem Gerät geliefert wird, um es zum Beispiel direkt in Ihrem Rechenzentrum einzubauen. Zwei physische Appliances können Sie mit wenigen Handgriffen zu einem Hochverfügbarkeits-Cluster (HA-Cluster) zusammenschalten.

{cee-only}
Die physische Appliance gibt für die {SE} und {ME}. Sie können  zwischen mehreren link:https://checkmk.de/appliance.html#physical_appliance[Modellen] mit verschiedenen Wartungsstufen wählen. Die Anleitung zur Inbetriebnahme finden Sie
in der link:cma_rack1_quick_start.html[Schnellstart-Anleitung].


==== Möglichkeit 4: Docker-Container

Wenn Sie {CMK} mithilfe eines Docker-Containers bereitstellen wollen, haben Sie auch diese Möglichkeit. Dabei unterstützen wir sowohl die {RE} als auch die {EE}
mit fertigen Container-Images, die mit wenigen Kommandos eingerichtet sind.

Die Anleitung dazu finden Sie im Artikel zur link:introduction_docker.html[Installation als Docker-Container].


=== Eine Instanz erstellen

{CMK} hat eine Besonderheit, die Ihnen zu Beginn vielleicht unwichtig erscheint, die sich in der Praxis aber als sehr nützlich herausgestellt hat: Sie können auf einem Server mehrere unabhängige Instanzen (_sites_) von {CMK} parallel betreiben. Dabei kann sogar jede Instanz mit einer anderen Version von {CMK} laufen.

Hier sind zwei häufige Anwendungen für dieses gut durchdachte Feature:

* unkompliziertes Ausprobieren einer neuen {CMK}-Version
* Parallelbetrieb einer Testinstanz zum Überwachen von Hosts, die noch nicht operativ sind

Wenn Sie {CMK} gerade auf einem Linux-Server installiert haben, kommt es noch komplett ohne Instanzen daher. Wir zeigen Ihnen in diesem Kapitel, wie Sie nach einer Software-Installation von {CMK} auf einer Linux-Distribution eine Instanz anlegen.

*Hinweis:* {CMK}-Appliances werden über eine Web-Oberfläche
administriert, die auch das Anlegen von Instanzen abdeckt. Dies wird
im link:appliance_usage.html#site_management[Artikel über die Appliance] erklärt. Falls Sie {CMK} in einem Docker-Container betreiben, wird für Sie automatisch während der Installation eine Instanz angelegt.

Wählen Sie zunächst einen Namen für Ihre Instanz. Diese darf nur aus Buchstaben und Ziffern bestehen. Konvention sind dabei Kleinbuchstaben. Im Handbuch verwenden wir in allen Beispielen den Namen `mysite`. Ersetzen Sie diesen Namen mit Ihren eigenen Instanznamen.

Das Anlegen selbst geht sehr einfach. Geben Sie einfach als `root`
den Befehl `omd create`, gefolgt vom Namen der Instanz ein:

[{shell}]
----
{c-root} omd create mysite
Adding /opt//omd/sites/mysite/tmp to /etc/fstab.
Creating temporary filesystem /omd/sites/mysite/tmp...[green]#OK#
Updating core configuration...
Generating configuration for core (type cmc)...Creating helper config...[green]#OK#
[green]#OK#
Restarting Apache...[green]#OK#
Created new site mysite with version 2.0.0i1.cee.

  The site can be started with *omd start mysite*.
  The default web UI is available at *http://linux/mysite/*

  The admin user for the web applications is *cmkadmin* with password: [hilite]#ZBdHdkl2*
  For command line administration of the site, log in with *'omd su mysite'*.
  After logging in, you can change the password for cmkadmin with *'htpasswd etc/htpasswd cmkadmin'*.
----

Beim Anlegen einer neuen Instanz passieren die folgenden Dinge:

* Es werden ein Linux-Benutzer (ohne Passwort) und eine Linux-Gruppe angelegt, die den Namen der Instanz tragen. Der Benutzer wird Instanzbenutzer (_site user_) genannt.
* Für die Instanz wird ein Home-Verzeichnis unterhalb von `/omd/sites` angelegt, z.B.  `/omd/sites/mysite`.
* Eine sinnvolle Defaultkonfiguration wird in das neue Verzeichnis kopiert.
* Für die Web-Oberfläche von {CMK} wird ein Benutzer mit dem Namen `cmkadmin` und einem zufälligen Passwort angelegt.

*Hinweis:* Wenn Sie beim Versuch, die Instanz zu erstellen, diese oder eine ähnliche Fehlermeldung erhalten:

[{shell}]
----
{c-root} omd create mysite
Group 'mysite' already existing.
----

dann existiert bereits ein Linux-Benutzer oder eine Gruppe mit dem von Ihnen angegebenen Instanznamen. Wählen Sie dann einfach einen anderen Namen.

Sobald Sie die neue Instanz erzeugt haben, erfolgt die weitere Administration
nicht mehr als `root`, sondern als Instanzbenutzer. Zu diesem werden
Sie am einfachsten mit dem folgenden Kommando:

[{shell}]
----
{c-root} su - mysite
{c-omd} 
----

Am geänderten Prompt sehen Sie, dass Sie in der Instanz eingeloggt sind. Wie der Befehl `pwd` zeigt, befinden Sie sich danach automatisch im Home-Verzeichnis der Instanz:

[{shell}]
----
{c-omd} pwd
/omd/sites/mysite
----

Wie Sie in der Ausgabe von `omd create` gesehen haben, wird beim Erzeugen der Instanz automatisch ein administrativer {CMK}-Benutzer mit dem Namen `cmkadmin` erzeugt. Dieser Benutzer ist für die Anmeldung an der Web-Oberfläche von {CMK} gedacht und hat ein zufälliges Passwort erhalten. Dieses Passwort können Sie als Instanzbenutzer leicht ändern:

[{shell}]
----
{c-omd} htpasswd -m etc/htpasswd cmkadmin
New password: *******
Re-type new password: *******
Updating password for user cmkadmin
----

Übrigens: Immer wenn wir im Handbuch Pfadnamen angeben, die *nicht* mit einem Schrägstrich beginnen, beziehen sich diese auf das Home-Verzeichnis der Instanz. Wenn Sie sich in diesem Verzeichnis befinden, können Sie solche Pfade daher direkt so verwenden. Das gilt z.B. auch für die Datei `etc/htpasswd`, deren absoluter Pfad hier `/omd/sites/mysite/etc/htpasswd` ist. Diese Datei  enthält die Passwörter der {CMK}-Benutzer dieser Instanz. Verwechseln Sie diese Datei nicht mit `/etc/htpasswd`.


=== Die Instanz starten

Eine Instanz kann gestartet oder gestoppt sein. Die Startart ist dabei automatisch, was bedeutet, dass eine gestartete Instanz auch nach einem Reboot des Rechners wieder gestartet wird. Frisch angelegte Instanzen beginnen ihr Leben dennoch gestoppt. Das können Sie leicht mit dem Befehl `omd status` überprüfen, der den Status aller Einzelprozesse zeigt, die zum Betrieb der Instanz nötig sind:

[{shell}]
----
{c-omd} omd status
mkeventd:       [red]#stopped#
liveproxyd:     [red]#stopped#
mknotifyd:      [red]#stopped#
rrdcached:      [red]#stopped#
cmc:            [red]#stopped#
apache:         [red]#stopped#
dcd:            [red]#stopped#
crontab:        [red]#stopped#
-----------------------
Overall state:  [red]#stopped#
----

Mit einem einfachen `omd start` können Sie die Instanz starten:

[{shell}]
----
{c-omd} omd start
Creating temporary filesystem /omd/sites/mysite/tmp...OK
Starting mkeventd...OK
Starting liveproxyd...OK
Starting mknotifyd...OK
Starting rrdcached...OK
Starting cmc...OK
Starting apache...OK
Starting dcd...OK
Initializing Crontab...OK
----

Wie erwartet, zeigt der Status danach alle Dienste als `running`:

[{shell}]
----
{c-omd} omd status
mkeventd:       [green]#running#
liveproxyd:     [green]#running#
mknotifyd:      [green]#running#
rrdcached:      [green]#running#
cmc:            [green]#running#
apache:         [green]#running#
dcd:            [green]#running#
crontab:        [green]#running#
-----------------------
Overall state:  [green]#running#
----

{cre-only}
Da die {RE} nicht über alle Features der {EE} verfügt, sehen Sie dort weniger Dienste. Außerdem finden Sie für den Kern `nagios` statt  `cmc`:

[{shell}]
----
{c-omd} omd status
mkeventd:       [green]#started#
rrdcached:      [green]#started#
npcd:           [green]#started#
nagios:         [green]#started#
apache:         [green]#started#
crontab:        [green]#started#
-----------------------
Overall state:  [green]#started#
----

Der Befehl `omd` bietet noch viele weitere Möglichkeiten zur Steuerung und Konfiguration von Instanzen, die im link:omd_basics.html[Artikel über Instanzen] beschrieben sind. Für noch tiefergehende Informationen unter anderem zur Verzeichnisstruktur der Instanz gibt es den link:cmk_commandline.html[Artikel zu {CMK} auf der Kommandozeile].


=== Anmelden

Nachdem die Instanz läuft, kann es auch schon losgehen. Jede Instanz hat eine eigene URL, die Sie in Ihrem Browser öffnen können. Diese setzt sich zusammen aus der IP-Adresse oder dem Host-Namen des {CMK}-Servers, einem Schrägstrich und dem Namen der Instanz, z.B. `http://mycmkserver/mysite`. Unter dieser Adresse finden Sie diesen Anmeldedialog:

image::login.png[width=60%]

Melden Sie sich nun mit dem Benutzernamen `cmkadmin` und dem anfangs ausgewürfelten bzw. von Ihnen geänderten Passwort an. Dadurch landen Sie auf der Startseite von {CMK}, die wir uns im nächsten Kapitel genauer ansehen werden.

Falls Ihre Instanz nicht gestartet ist, sehen Sie statt des Anmeldedialogs folgende Fehlermeldung:

[{image-border}]
image::omd_site_not_started.png[]

Falls es überhaupt keine Instanz mit diesem Namen gibt (oder Sie auf einem Server ohne {CMK} gelandet sind), sieht das eher so aus:

[{image-border}]
image::omd_site_not_found.png[]

*Wichtig:* Sobald Sie {CMK} produktiv betreiben, empfehlen wir Ihnen aus Sicherheitsgründen den Zugriff auf die Oberfläche ausschließlich gesichert zuzulassen. Was Sie dafür tun müssen, erfahren Sie im link:omd_https.html[Artikel über die Absicherung der Web-Oberfläche mit HTTPS].


[#guioverview]
== Die {CMK}-Oberfläche


=== Die Startseite

[{image-border}]
image::empty_dashboard.png[]

In der Benutzeroberfläche (_graphical user interface_, GUI) von {CMK} sehen Sie einige Elemente, die wir zum jetzigen Zeitpunkt noch nicht benötigen. Viele davon sind leer oder zeigen lauter Nullen, was daran liegt, dass wir noch keine Objekte ins Monitoring aufgenommen haben.

Trotzdem sollten Sie sich mit den Grundelementen der Oberfläche
vertraut machen. Am wichtigsten ist die Aufteilung in die *Navigationsleiste* links, die *Hauptseite* in der Mitte und die *Seitenleiste* rechts.


[#navigationbar]
=== Navigationsleiste

[{image-left}]
image::navbar.png[width=55]

Mit der Navigationsleiste (_navigation bar_) auf der linken Seite und der sich darin befindlichen Symbole treffen Sie die Grundsatzentscheidung, worum sich {CMK} für Sie kümmern soll:

[.guihint]#Setup# -- die Einrichtung der zu überwachenden Objekte (wie Hosts und Services)

[.guihint]#Monitor# -- die Überwachung selbst

[.guihint]#Customize# -- die Anpassung von Einstellungen, die für die Überwachung nützlich sind

Hinter den drei Symbolen verbergen sich mehr oder weniger umfangreiche Menüs, die sogenannten „Mega-Menüs“, deren Einträge in mehrere Themen gegliedert sind: Zum Beispiel finden Sie im Symbolmenü [.guihint]#Setup# zum Thema [.guihint]#Host# Einträge zum Konfigurieren von Hosts, Host-Gruppen, Host-Merkmalen und Host-spezifischen Regeln. Wir werden einen dieser Einträge im nächsten Kapitel beim Einrichten des ersten Hosts verwenden.

Im unteren Bereich der Navigationsleiste finden Sie hinter [.guihint]#User# Einträge, die Ihr {CMK}-Benutzerkonto betreffen -- zurzeit also das Konto des Benutzers `cmkadmin`. Hier können Sie das Passwort ändern, persönliche Einstellungen Ihres Profils anpassen und sich von der {CMK}-Oberfläche abmelden. Für wichtige bzw. häufig verwendete Einstellungen gibt es in diesem Symbolmenü einen Schnellzugriff, mit dem Sie zum Beispiel durch einfaches Anklicken von [.guihint]#Interface Theme# das Aussehen der Oberfläche ändern können: von [.guihint]#Dark# nach [.guihint]#Light# bzw. umgekehrt, je nachdem welches [.guihint]#Theme# aktuell ausgewählt ist.

Im Symbolmenü [.guihint]#Help# finden Sie einige Einträge, mit der Sie Hilfe und weitere Information aufrufen können -- innerhalb von {CMK} oder außerhalb. Unter anderem können Sie auch dieses Handbuch öffnen.

Komplettiert wird die Navigationsleiste unten durch [.guihint]#Sidebar# (mit der Sie durch einfaches Anklicken die Seitenleiste aus- oder einblenden können), ganz unten durch die Information über die aktuell installierte Edition und Version von {CMK} (durch Anklicken öffnen Sie die zugehörigen Release Notes) und ganz oben durch das {CMK}-Logo. Ein Klick auf das Logo bringt Sie immer zurück zum Standard-Dashboard, das auf der Hauptseite angezeigt wird.


=== Hauptseite

image::mainpage_default.png[]

Was Sie auf der Hauptseite sehen, hängt davon ab, wo Sie in {CMK} gerade unterwegs sind. Nach der Anmeldung sehen Sie zunächst das Standard-Dashboard, das einen  Überblick über den aktuellen Zustand und die kürzlichen Ereignisse der überwachten Objekte zeigt.

Der Inhalt der Hauptseite ändert sich abhängig von Ihrer Auswahl in der
Navigationsleiste oder auch der Seitenleiste. Wenn Sie zum Beispiel im Symbolmenü [.guihint]#User# die Änderung Ihres Profils auswählen, werden Ihnen alle Profileinstellungen auf der Hauptseite angezeigt.

Unterhalb des Seitentitels sehen Sie den Pfad zur aktuellen Seite, stets beginnend mit dem Namen des Menüs aus der Navigationsleiste. Mithilfe dieser „Breadcrumb-Navigation“ wissen Sie auch nach komplexen Aktionen, wo Sie sich in {CMK} gerade befinden: auf der Startseite [.guihint]#Main Overview# also im Monitoring.


[#sidebar]
=== Seitenleiste

[{image-left}]
image::sidebar_default.png[width=280]

Die Seitenleiste (_sidebar_) ist Ihr {CMK}-Cockpit. Es ist der Ort, an dem Sie ständig die wichtigsten Informationen im Blick und den schnellen Zugriff auf die Funktionen haben, die Sie in {CMK} immer wieder benötigen.

In der obersten Reihe der Seitenleiste sehen Sie eine Auswahl von 5 Symbolen mit wichtigen Aktionen, die viele {CMK}-Benutzer besonders nützlich finden. Klicken Sie ruhig der Reihe nach diese Symbole durch -- auch wenn mangels überwachter Objekte die dargestellten Informationen noch nicht aussagekräftiger sind als auf der Startseite [.guihint]#Main Overview#, zu der Sie übrigens durch Klick auf das erste Symbol [.guihint]#Main# wieder zurückkehren.

Unterhalb der 5 Symbole beginnt der Bereich, den Sie sich nach Ihren Vorlieben zusammenstellen können. Dazu dienen die Seitenleistenelemente, auch „Snapins“ genannt. Snapins sind kompakte GUI-Container mit vordefinierter Funktion. Da die Seitenleiste für *Ihre* Präferenzen da sein soll, enthält sie in der Standardeinstellung nur einige wenige Snapins:

[.guihint]#Tactical overview# -- Übersicht aller überwachten Objekte mit aktuellen Statusinformationen

[.guihint]#Quicksearch# -- Suchfeld

[.guihint]#Bookmarks# -- Ihre persönlichen Lesezeichen innerhalb von {CMK}

[.guihint]#Master Control# -- Verschiedene Hauptschalter für das Monitoring

Übrigens erhalten Sie genauere Informationen zu den genannten und anderen wichtigen Snapins link:intro.html#snapins[im Kapitel zu Snapins] weiter unten.

Wenn Sie ganz unten in der Seitenleiste auf icon:button_sidebar_add_snapin[] klicken, werden Ihnen in der Hauptseite alle Snapins angezeigt, die aktuell *nicht* in Ihrer Seitenleiste sind und die Sie durch einen einfachen Klick hinzufügen können. Probieren Sie es aus und füllen Sie testweise die Seitenleiste.

Je nach Größe Ihres Bildschirms werden nun eventuell nicht alle Snapins sichtbar sein. Am schnellsten bewegen Sie sich vertikal durch die Seitenleiste mit dem Mausrad, während der Mauszeiger über der Seitenleiste ist. Bei Touchpads ist diese Funktion oft mit der Geste „zwei Finger nebeneinander hoch- und runterschieben“ möglich.

In der Seitenleiste können Sie die Snapins so manipulieren:

*  Auf- und zuklappen: Klicken Sie *in* den angezeigten Titel des Snapins.
*  Verschieben: Drücken Sie mit der linken Maustaste *rechts neben* den Titel, ziehen Sie das Snapin auf- oder abwärts an eine andere Position in der Seitenleiste und lassen Sie die Maustaste los.
*  Entfernen: Zeigen Sie mit der Maus auf die Titelleiste und klicken Sie auf icon:button_sidebar_close_snapin[].

Soweit zu den Möglichkeiten, den Inhalt der Seitenleiste anzupassen. Als Ganzes können Sie die Seitenleiste aus- und wieder einblenden (mit dem Symbol [.guihint]#Sidebar# in der Navigationsleiste) und Sie können Ihre Position von rechts nach links verschieben, so dass sie an die Navigationsleiste andockt (in der Navigationsleiste mit dem Symbolmenü [.guihint]#User# und dem Eintrag [.guihint]#Sidebar position#).

Nach dieser Einführung sollten Sie mit den wichtigsten Elementen der {CMK}-Oberfläche vertraut sein (ausführlichere Informationen finden Sie im link:user_interface.html[Artikel zur Benutzeroberfläche]). Wir können also im nächsten Kapitel damit beginnen, {CMK} für das Monitoring einzurichten.


== Das Monitoring einrichten

[#hosts]
=== Hosts, Services und Agenten

So, {CMK} steht bereit. Doch bevor wir mit dem eigentlichen Monitoring beginnen, werden wir kurz einige wichtige Begriffe erläutern. Das beginnt mit dem *Host*: Ein Host ist in {CMK} ein Server, eine virtuelle Maschine (VM), ein Netzwerkgerät, eine Appliance -- oder generell ein Ding mit einer IP-Adresse, das von {CMK} überwacht wird. Allerdings gibt es auch Hosts ohne IP-Adresse, z.B. Docker-Container. Jeder Host hat immer einen der Zustände {UP}, {DOWN} oder {UNREACH}.

Auf jedem Host wird eine Anzahl von *Services* überwacht. Ein Service kann dabei alles Mögliche sein, zum Beispiel ein Dateisystem, ein Prozess, ein Hardware-Sensor, ein Switchport -- aber auch einfach nur eine bestimmte Metrik wie die CPU-Auslastung oder der RAM-Verbrauch. Jeder Service hat einen der Zustände {OK}, {WARN}, {CRIT} oder {UNKNOWN}.

Damit {CMK} von einem Host Daten abfragen kann, ist in der Regel ein *Agent* notwendig. Das ist ein kleines Programm, das auf dem Host installiert wird, und auf Anfrage Daten über den Zustand (oder die „Gesundheit“) des Hosts liefert. Server, auf denen Windows, Linux oder Unix läuft, können von {CMK} nur dann sinnvoll überwacht werden, wenn Sie dort einen von uns gelieferten {CMK}-Agenten installieren. Bei Netzwerkgeräten und vielen Appliances hat meist der Hersteller bereits einen Agenten eingebaut, den {CMK} ohne Weiteres mit dem standardisierten Protokoll SNMP abfragen kann. Cloud-Dienste wie Amazon Web Services (AWS) oder Azure stellen stattdessen eine Schnittstelle („API“) bereit, die von {CMK} per HTTP abgefragt werden kann.


=== Vorüberlegungen zu DNS

Auch wenn {CMK} keine Namensauflösung von Hosts voraussetzt, erleichtert ein gut gepflegtes Domain Name System (DNS) die Konfiguration erheblich und vermeidet Fehler, denn {CMK} kann dann die Namen der Hosts selbständig auflösen, ohne dass Sie IP-Adressen in {CMK} eintragen müssen.

Der Aufbau des Monitoring ist daher ein guter Anlass, zu überprüfen, ob Ihr DNS auf dem neuesten Stand ist und gegebenenfalls dort fehlende Einträge zu ergänzen.


[#folders]
=== Ordnerstruktur für Hosts

{CMK} verwaltet Ihre Hosts in einem hierarchischen Baum von Ordnern -- ganz analog
zu dem, was Sie von Dateien in Ihrem Betriebssystem kennen. Wenn Sie nur eine Handvoll
Hosts überwachen, mag das für Sie weniger wichtig sein. Aber erinnern
Sie sich: {CMK} ist für das Überwachen von Tausenden und Zigtausenden Hosts
geschaffen -- und dabei ist Ordnung die halbe Miete.

Bevor Sie die ersten Hosts in {CMK} aufnehmen, ist es daher von Vorteil,
wenn Sie sich Gedanken über die Struktur dieser Ordner machen. Die Ordnerstruktur ist nicht nur für Ihre eigene Übersicht nützlich, sie kann zusätzlich auch für die Konfiguration von {CMK} verwendet werden: Alle
Konfigurationsparameter von Hosts können in einem Ordner definiert werden, die dann automatisch an die dort enthaltenen Unterordner und Hosts
*vererbt* werden.

Eine einmal erstellte Ordnerstruktur können Sie jederzeit verändern -- müssen dabei allerdings sehr gewissenhaft vorgehen. Das Verschieben eines Hosts
in einen anderen Ordner kann nämlich zur Folge haben, dass sich dessen Parameter
ändern, ohne dass Sie sich dessen vielleicht bewusst sind.

Die eigentliche Frage beim Aufbau einer für Sie sinnvollen Ordnerstruktur ist,
nach welchen Kriterien Sie die Ordner organisieren möchten. Die Kriterien können in jeder Ebene des Baums andere sein. So können Sie z.B. in der ersten
Ebene nach Standorten unterscheiden und in der zweiten Ebene nach
Technologie.

Folgende Ordnungskriterien haben sich in der Praxis bewährt:

* Standort/Geographie
* Organisation
* Technologie

Eine Sortierung nach Standort ist vor allem in größeren
Unternehmen sehr naheliegend, insbesondere dann, wenn Sie das Monitoring über
mehrere {CMK}-Server verteilen. Jeder Server überwacht dann z.B. eine Region
oder ein Land. Wenn Ihre Ordner diese Aufteilung abbilden, dann können
Sie z.B. im Ordner „München“ definieren, dass alle Hosts in diesem
Ordner von der {CMK}-Instanz „muc“ aus überwacht werden sollen.

Alternativ dazu kann die Organisation (d.h. die Antwort auf die Frage "Wer ist für einen Host zuständig?“) ein sinnvolleres Kriterium sein, denn nicht
immer ist Standort und Verantwortung das Gleiche. So mag es sein, dass eine
Gruppe Ihrer Kollegen für die Administration von Oracle zuständig ist,
und zwar unabhängig davon, an welchem Standort die entsprechenden Hosts stehen.
Ist also z.B. der Ordner „Oracle“ für die Hosts der Oracle-Kollegen
vorgesehen, so ist es in {CMK} einfach zu konfigurieren, dass alle Hosts
unterhalb dieses Ordners nur für diese Kollegen sichtbar sind oder, dass
diese ihre Hosts dort sogar selbst pflegen können.

Eine Strukturierung nach Technologie könnte z.B. einen Ordner
für Windows-Server und einen für Linux-Server vorsehen. Das würde die Umsetzung des Schemas „Auf allen Linux-Servern muss der Prozess `sshd` laufen.“ vereinfachen. Ein anderes Beispiel ist die Überwachung von Geräten via SNMP,
wie beispielsweise Switches oder Router. Hier kommt kein {CMK}-Agent zum Einsatz, sondern die Geräte werden über das Protokoll SNMP abgefragt. Sind diese Hosts in
eigenen Ordnern zusammengefasst, so können Sie direkt am Ordner die für
SNMP notwendigen Einstellungen wie etwa die „Community“ vornehmen.

Da eine Ordnerstruktur nur in seltenen Fällen die Komplexität der Wirklichkeit abbilden kann, bietet {CMK} mit den Host-Merkmalen (_host tags_) eine weitere ergänzende Möglichkeit zur Strukturierung: doch dazu link:intro.html#hosttags[später] mehr. Weiterführende Informationen unter anderem zur Ordnerstruktur finden Sie im link:wato_hosts.html[Artikel über Hosts].


=== Ordner erstellen

Den Einstieg in die Verwaltung von Ordnern und Hosts finden Sie über die Navigationsleiste, das Symbolmenü [.guihint]#Setup#, das Thema [.guihint]#Hosts# und den Eintrag [.guihint]#Hosts#. Dann wird die Seite [.guihint]#Main directory# angezeigt:

[{image-border}]
image::empty_main_directory.png[]

Bevor wir den ersten Ordner erstellen, werden wir kurz auf den Aufbau dieser Seite eingehen, da Sie die verschiedenen Elemente auf den meisten {CMK}-Seiten so oder so ähnlich wiederfinden werden. Unterhalb des Seitentitels [.guihint]#Main directory# finden Sie den Breadcrumb-Pfad, der Ihnen zeigt, wo Sie sich innerhalb der {CMK}-Oberfläche gerade befinden. Darunter wird die Menüleiste angezeigt, die die möglichen Aktionen auf dieser Seite in Menüs und Menüeinträgen zusammenfasst. Die Menüs sind in {CMK} stets kontext-spezifisch, d.h. sie finden nur Menüeinträge für Aktionen, die auf der aktuellen Seite Sinn machen.

Unter der Menüleiste finden Sie die Toolbar, in der die wichtigsten Aktionen aus den Menüs als Knöpfe zum direkten Anklicken angeboten werden. Die Toolbar können Sie mit dem Knopf icon:button_hide_toolbar[] rechts neben dem [.guihint]#Help#-Menü ausblenden und mit icon:button_show_toolbar[] wieder einblenden. Bei ausgeblendeter Toolbar werden die Symbole der Toolbar in der Menüleiste rechts neben dem [.guihint]#Help#-Menü angezeigt.

Da wir uns zurzeit auf einer leeren Seite befinden (ohne Ordner und ohne Hosts), werden die wichtigen Aktionen zum Erstellen des ersten Objekts zusätzlich über noch größere Knöpfe angeboten -- damit die Möglichkeiten auch nicht übersehen werden, die die Seite bietet. Diese Knöpfe werden nach dem Erstellen des ersten Objekts verschwinden.

Nun aber zurück zum Thema, weswegen wir uns eigentlich auf dieser Seite befinden: dem Anlegen von Ordnern. _Einen_ Ordner -- den Hauptordner -- gibt es in jedem frisch aufgesetzten {CMK}-System. Er heißt [.guihint]#Main directory#, wie Sie im Titel der Seite sehen können. Unterhalb des Hauptordners werden wir nun für ein einfaches Beispiel die drei Ordner [.guihint]#Windows#, [.guihint]#Linux# und [.guihint]#Network# erstellen.

Legen Sie diese drei Ordner nacheinander an, indem Sie eine der angebotenen Aktionen zum Erstellen eines Ordners auswählen (z.B. den Toolbar-Knopf icon:icon_newfolder[] [.guihint]#Add subfolder#) und auf der neuen Seite [.guihint]#Create new folder# im ersten Kasten [.guihint]#Basic Settings# den jeweiligen
Namen eintragen:

[{image-border}]
image::folder_basic_settings.png[]

*Tipp:* Vielleicht sind Ihnen die drei Punkte rechts oben im Bild schon an anderer Stelle der {CMK}-Oberfläche aufgefallen -- z.B. im geöffneten Symbolmenü [.guihint]#Setup#: Immer, wenn Sie diese Auslassungspunkte sehen, bietet {CMK} zwei Ansichten an: Es werden entweder nur die wichtigsten Einträge angezeigt (gedacht für den Einsteiger) oder alle Einträge (für den Experten). Sie können durch Klick auf die Auslassungspunkte zwischen beiden Ansichten wechseln und Sie können das generelle Verhalten in den Einstellungen Ihres Benutzerprofils unter [.guihint]#Show more / Show less# ändern.

Im obigen Bild ist der [.guihint]#Show less#-Modus aktiv und es wird nur derjenige Eintrag angezeigt, der zum Erstellen eines Ordners unbedingt notwendig ist.
Bestätigen Sie die Eingabe mit dem Toolbar-Knopf [.guihint]#Save#.

Erstellen Sie analog zum Ordner [.guihint]#Windows# die anderen beiden Ordner [.guihint]#Linux# und [.guihint]#Network#. Danach sieht die Situation so aus:

[{image-border}]
image::three_empty_folders.png[]

*Tipp:* Wenn Sie mit der Maus auf den oberen Bereich eines der drei Ordner-Symbole zeigen, werden Ihnen Symbole angezeigt um schnell Aktionen mit dem Ordner auszuführen (die Eigenschaften ändern, den Ordner verschieben oder ihn löschen).

*Noch ein Tipp:* Rechts oben auf jeder Seite finden Sie die Information, ob -- und wenn ja, wie viele -- Änderungen inzwischen bereits aufgelaufen sind. Da wir drei Ordner erstellt haben, gibt es drei Änderungen, die jetzt aber noch nicht aktiviert werden müssen. Wir werden uns mit dem Aktivieren von Änderungen link:intro.html#activatechanges[weiter unten] genauer beschäftigen.


[#linux]
=== Den ersten Host aufnehmen

Jetzt ist alles dafür vorbereitet, um den ersten Host in das Monitoring
aufzunehmen -- und was wäre naheliegender, als den {CMK}-Server selbst
zu überwachen? Natürlich wird dieser nicht seinen eigenen Totalausfall
melden können, aber nützlich ist das trotzdem, denn Sie erhalten so nicht
nur eine Übersicht über die CPU- und RAM-Nutzung, sondern auch etliche
Metriken und Checks, die das {CMK}-System selbst betreffen.

Das Vorgehen zum Aufnehmen eines Linux-Hosts (wie übrigens auch eines Windows-Hosts) ist im Prinzip stets das Folgende:

. Agent herunterladen
. Agent installieren
. Host erstellen

Nach der Erstellung des Hosts wird die Einrichtung komplettiert durch die link:intro.html#services[Konfiguration der Services] und die link:intro.html#activatechanges[Aktivierung der Änderungen].


==== Agent herunterladen

Da der {CMK}-Server ein Linux-Rechner ist, benötigen Sie den {CMK}-Agenten für Linux. Diesen finden Sie unter [.guihint]#Setup# > [.guihint]#Agents# > [.guihint]#Windows, Linux, Solaris, AIX#:

[{image-border}]
image::agent_download_cee.png[]



//[CEE] In den {EE} gelangen Sie hier zur link:wato_monitoringagents.html#bakery[Agent Bakery]. Diese ermöglicht das „Backen“ von individuell konfigurierten Agentenpaketen. Aber es wird auch immer ein generischer Agent angeboten, den Sie sofort herunterladen können.

Laden Sie die Datei herunter: Wählen Sie das RPM-Dateiformat für Red Hat, CentOS und SLES oder das DEB-Dateiformat für Debian und Ubuntu .

//[[CRE] Die {RE} verfügt über keine Agentenbäckerei. Hier gelanden Sie nach einem Klick auf [.guihint]#WATO => Monitoring Agents# direkt auf eine Downloadseite, auf der Sie vorkonfigurierte Agenten und Agenten-Plugins finden. (Diese Seite finden Sie in den {EE} unter [.guihint]#Agent files.#)

//BI:agent_download_page.png border hilite:48,68,92,12

//Wählen Sie aus dem ersten Kasten [.guihint]#Packaged Agents# eines der beiden Linux-Pakete (RPM/DEB) und kopieren Sie es auf den {CMK}-Server.

*Hinweis:* Da der {CMK}-Server, von dem Sie die Datei geladen haben, identisch mit dem Host ist, auf dem der Agent installiert werden soll, brauchen Sie die Datei nicht auf einen anderen Rechner zu kopieren.


==== Agent installieren

Für folgendes Beispiel nehmen wir an, dass Sie die Datei in das Verzeichnis `/root` kopiert haben, also in das Home-Verzeichnis des `root`-Benutzers. Diese Datei wird nur während der Installation benötigt. Sie können sie nach der Installation löschen.

Die Installation erfolgt als `root` auf der Kommandozeile, für die RPM-Datei mit `rpm`, am besten mit der Option `-U`:

[{shell}]
----
{c-root} rpm -U check-mk-agent-2.0.0i1-21eb305b265abc60.noarch.rpm
----

... oder für die DEB-Datei mit dem Befehl `dpkg -i`:

[{shell}]
----
{c-root} dpkg -i check-mk-agent_2.0.0i1-21eb305b265abc60_all.deb
----

*Wichtig:* Der Agent benötigt zum Funktionieren entweder das Hintergrundprogramm (_daemon_) `systemd`, das bei neueren Linux-Distributionen Standard ist, oder den Hilfs-Daemon *xinetd.*
Welcher Daemon auf Ihrem Rechner läuft, können Sie an der Ausgabe beim Installieren des Agenten sehen:

[cols="20,~"]
|===
|Agent läuft ... |Ausgabe 

|mit `xinetd` |Reloading xinetd ...
|mit `systemd` |Enable Checkmk agent in systemd...
|überhaupt nicht |Keine der beiden anderen Meldungen, dafür: `This package needs xinetd to be installed for full functionality.`
|===


Falls bei Ihnen weder `systemd` noch `xinetd` vorhanden
ist, installieren Sie `xinetd` einfach nach. Das geht auf RedHat/CentOS mit:

[{shell}]
----
{c-root} yum install xinetd
----

auf SLES mit:

[{shell}]
----
{c-root} zypper install xinetd
----

und auf Debian/Ubuntu mit:

[{shell}]
----
{c-root} apt install xinetd
----

Damit ist die Installation des Agenten abgeschlossen.

Der {CMK}-Agent für Linux ist ein ausführbares Programm (Shell-Skript), das
Sie sehr leicht testen können, indem Sie den Befehl `check_mk_agent` aufrufen:

[{shell}]
----
RPM:check_mk_agent
<<<check_mk>>>
Version: 2.0.0i1
AgentOS: linux
Hostname: linux
AgentDirectory: /etc/check_mk
DataDirectory: /var/lib/check_mk_agent
SpoolDirectory: /var/lib/check_mk_agent/spool
PluginsDirectory: /usr/lib/check_mk_agent/plugins
LocalDirectory: /usr/lib/check_mk_agent/local
...
----

Die Ausgabe des `check_mk_agent`-Kommandos ist sehr lang, daher haben wir nur die ersten Zeilen aufgelistet.

Um die Erreichbarkeit des Agenten von außen zu testen, können Sie von
einem anderen Rechner aus mit `telnet` eine Verbindung auf Port
6556 versuchen. Hier sollte der Agent mit der gleichen Ausgabe antworten:

[{shell}]
----
{c-root} telnet linux 6556
Trying 192.168.178.34...
Connected to linux.
Escape character is '^]'.
<<<check_mk>>>
Version: 2.0.0i1
AgentOS: linux
Hostname: linux
...
----

*Hinweis:* Der Agent ist standardmäßig aus dem ganzen Netz erreichbar und ohne Passwort abfragbar. Da der Agent aber grundsätzlich keine Befehle aus dem Netz annimmt, kann sich ein möglicher Angreifer keinen Zugriff verschaffen. Allerdings sind Informationen wie die Liste der aktuellen Prozesse sichtbar. Wie Sie den Agenten absichern, erfahren sie im link:agent_linux.html[Artikel über den Linux-Agenten].


[#createhost]
==== Host erstellen

Nachdem der Agent auf dem Host installiert ist, können Sie den Host ins Monitoring aufnehmen -- und zwar in den  vorbereiteten Ordner [.guihint]#Linux#. Nur zur Erinnerung: In diesem Beispiel sind der {CMK}-Server und der zu überwachende Host identisch.

Öffnen Sie in der {CMK}-Oberfläche die gleiche Seite [.guihint]#Main directory#, auf der Sie bereits die drei Ordner erstellt haben: [.guihint]#Setup# > [.guihint]#Hosts# > [.guihint]#Hosts#. Wechseln Sie dort in den Ordner [.guihint]#Linux#, indem Sie den Ordner anklicken.

Klicken Sie den Toolbar-Knopf icon:icon_new[] [.guihint]#Add host# und die Seite [.guihint]#Create new host# wird geöffnet:

image::host_allsettings_less.png[]

Wie schon beim Anlegen der drei Ordner weiter oben ist bei uns immer noch der Einsteiger-Modus (oder _Show less_-Modus) von {CMK} aktiv. Daher zeigt {CMK} im Formular nur die wichtigsten und zum Erstellen eines Hosts notwendigen Host-Parameter an. Falls es sie interessiert, können Sie sich den Rest ansehen, indem Sie bei jedem der geöffneten Kästen die drei Auslassungszeichen
icon:button_showmore[] anklicken und die beiden zugeklappten Kästen am Ende der Seite öffnen. Wie am Anfang erwähnt, ist {CMK} ein komplexes System,
das auf jede Frage eine Antwort hat. Deswegen kann man bei einem Host (aber nicht nur dort) auch sehr viel konfigurieren.

*Tipp:* Auf vielen Seiten -- auch auf dieser -- können Sie sich zusätzlich Hilfetexte zu den Parametern anzeigen lassen. Wählen Sie dazu im [.guihint]#Help#-Menü den Eintrag [.guihint]#Toggle inline help#. Die gewählte Einstellung bleibt auch auf anderen Seiten aktiv, bis Sie die Hilfe wieder abschalten.

Aber nun zu den Eingaben, um den ersten Host zu erstellen. Sie müssen nur ein einziges Feld ausfüllen, nämlich [.guihint]#Hostname# bei den [.guihint]#Basic Settings#. Diesen Namen können Sie frei vergeben. Er dient im Monitoring an allen Stellen als Schlüssel und eindeutige Bezeichnung für den Host.

Falls der Host unter seinem Namen im DNS auflösbar ist, sind Sie mit diesem Formular bereits fertig. Falls nicht, oder falls Sie kein DNS verwenden möchten, können Sie die IP-Adresse aber auch von Hand im Feld [.guihint]#IPv4 Address# eintragen.

*Hinweis:* Damit {CMK} immer stabil und performant laufen kann, unterhält
es einen eigenen Cache für die Auflösung der Host-Namen. Daher führt der
Ausfall des DNS-Dienstes nicht zum Ausfall des Monitorings. Die DNS-Abfrage
geschieht nur einmalig, wenn der Host ins Monitoring aufgenommen wird.

Der Cache wird automatisch jeden Tag um 00:05 Uhr erneuert. Falls Sie den DNS-Cache neu aufbauen wollen, damit eine Änderung in Ihrem DNS sofort wirksam wird, bietet Ihnen {CMK} auch diese Möglichkeit, und zwar in den Eigenschaften eines Hosts mit dem Toolbar-Knopf icon:icon_update[] [.guihint]#Update site DNS cache#. Genauere Informationen dazu finden Sie im link:wato_hosts.html#dns[Artikel über die Host-Verwaltung].

Um aber die Eigenschaften eines Hosts aufrufen zu können, muss der erste Host zuerst einmal komplett erstellt werden -- und soweit sind wir noch nicht, auch wenn wir kurz davor stehen.


==== Diagnose

Murphys Gesetz („Alles, was schiefgehen kann, wird auch schiefgehen.“) kann leider auch von {CMK} nicht außer Kraft gesetzt werden. Schiefgehen kann vor allem dann etwas, wenn man es zum ersten Mal probiert. Daher sind gute Möglichkeiten zur Fehlerdiagnose wichtig.

Bereits bei der Erstellung eines Hosts bietet {CMK} an, nicht nur die Eingaben (Host-Name und IP-Adresse) auf der Seite [.guihint]#Create new host# zu sichern, sondern zusätzlich die Verbindung zum Host zu testen. In der Toolbar der Seite [.guihint]#Create new host# finden Sie unter anderem den Knopf [.guihint]#Save & go to connection tests#. Klicken Sie auf diesen Knopf.

Die Seite [.guihint]#Test connection to host# wird angezeigt und {CMK} versucht, den Host auf den verschiedensten Wegen zu erreichen. Für Linux- und Windows-Hosts sind dabei nur die beiden oberen Kästen interessant:

[{image-border}]
image::host_diagnostics.png[]

Durch die Ausgabe im Kasten "Agent" erhalten Sie die Gewissheit, dass der neu erstellte Host in {CMK} erfolgreich mit dem Agent kommunizieren kann, den Sie zuvor auf dem Host manuell installiert hatten.

In weiteren Kästen versucht {CMK} per SNMP Kontakt aufzunehmen. Das führt in diesem Beispiel erwartbar zu SNMP-Fehlern, ist aber sehr nützlich für Netzwerkgeräte, die wir link:intro.html#snmp[weiter unten] besprechen werden.

Auf dieser Seite können Sie im Kasten [.guihint]#Host Properties# bei Bedarf
eine andere IP-Adresse ausprobieren, den Test erneut durchführen und die geänderte IP-Adresse mit [.guihint]#Save & go to host properties# sogar direkt in die Host-Eigenschaften übernehmen.

Klicken Sie diesen Knopf (ob Sie die IP-Adresse geändert haben oder nicht) und Sie landen auf der Seite [.guihint]#Properties of host#.


[#services]
=== Die Services konfigurieren

Nachdem der Host selbst aufgenommen wurde, kommt das eigentlich Interessante:
die Konfiguration seiner Services. Auf der oben genannten Seite der Host-Eigenschaften klicken Sie [.guihint]#Save & go to service configuration# und die Seite [.guihint]#Services of host# wird angezeigt.

Auf dieser Seite legen Sie fest, welche Services Sie auf dem Host überwachen
möchten. Wenn der Agent auf dem Host erreichbar ist und korrekt läuft,
findet {CMK} automatisch eine Reihe von Services und schlägt diese für das
Monitoring vor (hier gekürzt dargestellt):

[{image-border}]
image::new_host_services.png[]

Für jeden dieser Services gibt es prinzipiell drei Möglichkeiten:

* [.guihint]#Undecided# : Sie haben sich noch nicht entschieden, ob dieser Service überwacht werden soll.
* [.guihint]#Monitored# : Der Service wird überwacht.
* [.guihint]#Disabled# : Sie haben sich dafür entschieden, den Service grundsätzlich nicht zu überwachen.

Die Seite zeigt alle Services nach diesen Möglichkeiten in drei Tabellen an. Da Sie noch keinen Service konfiguriert haben, sehen Sie nur die Tabelle [.guihint]#Undecided#. Für den Anfang ist es am einfachsten, wenn Sie jetzt auf [.guihint]#Monitor undecided services# klicken. Dann werden alle Services direkt in das Monitoring übernommen und alle [.guihint]#Undecided# zu [.guihint]#Monitored# Services.

//TK: Die bisher beschriebenen 2 Alternativ-Wege zu dieser Seite gibt es nicht mehr (sind aber an dieser Stelle auch nicht notwendig):
//Zu dieser gelangen Sie auf verschiedenen Wegen:
//wenn Sie in der Ordneransicht bei einem Host auf das Symbol klicken,
//wenn Sie in den Host-Eigenschaften oder auf einer anderen Seite des Hosts oben auf den Knopf Services klicken.

Sie können diese Seite jederzeit später aufrufen, um die Konfiguration
der Services anzupassen. Manchmal entstehen durch Änderungen an einem Host
neue Services, z.B. wenn Sie eine Logical Unit Number (LUN) als Dateisystem einbinden oder eine neue Oracle Datenbankinstanz konfigurieren. Diese Services erscheinen dann wieder als [.guihint]#Undecided#, und Sie können sie einzeln oder alle auf einmal in das Monitoring aufnehmen.

Umgekehrt können Services auch verschwinden, z.B. weil ein Dateisystem entfernt wurde. Diese erscheinen dann im Monitoring als {UNKNOWN} und auf dieser Seite als [.guihint]#Vanished# und können mit [.guihint]#Remove vanished services# aus dem Monitoring entfernt werden.

Der Knopf [.guihint]#Add missing, remove vanished# macht alles auf einmal: fehlende Services hinzufügen und überflüssige entfernen.


[#activatechanges]
=== Änderungen aktivieren

{CMK} speichert alle Änderungen, die Sie vornehmen, zunächst nur in einer vorläufigen „Konfigurationsumgebung“, die das aktuell laufende Monitoring noch nicht beeinflusst. Erst durch das „Aktivieren der aufgelaufenen Änderungen“ werden diese in Monitoring übernommen. Mehr über die Hintergründe dazu erfahren Sie im link:wato.html[Artikel über die Konfiguration von {CMK}].

Wie wir schon oben erwähnt hatten, finden Sie auf jeder Seite rechts oben die Information, wie viele Änderungen sich bisher angesammelt haben, die noch nicht aktiviert sind. Klicken Sie auf den Link [.guihint]#View changes#. Dies bringt Sie auf die Seite [.guihint]#Activate pending changes#, die unter anderem bei [.guihint]#Pending changes# die noch nicht aktivierten Änderungen auflistet:

[{image-border}]
image::activate_changes.png[]

Klicken Sie jetzt auf den Knopf [.guihint]#Activate on affected sites#, um die Änderungen anzuwenden.

Kurz danach können Sie das Resultat in der Seitenleiste im [.guihint]#Tactical overview# sehen, das nunmehr die Zahl der Hosts (1) und die Zahl der zuvor von Ihnen ausgewählten Services anzeigt. Auch im Standard-Dashboard,
das Sie mit einem Klick auf das {CMK}-Logo links oben in der Navigationsleiste erreichen, können Sie jetzt sehen, dass sich das System mit Leben gefüllt hat.

Damit haben Sie den ersten Host mit seinen Services erfolgreich ins Monitoring übernommen: Gratulation!


=== Windows überwachen

Ebenso wie für Linux hat {CMK} auch für Windows einen eigenen Agenten. Dieser ist als MSI-Paket verpackt. Sie finden ihn an der gleichen Stelle wie auch den link:intro.html#linux[Linux-Agenten]. Sobald Sie das MSI-Paket heruntergeladen und auf Ihren Windows-Rechner kopiert haben, können Sie es wie bei Windows üblich per Doppelklick installieren.

*Hinweis:* Es kann sein, dass Sie die link:agent_windows.html#firewall[Firewall-Einstellungen unter Windows] anpassen müssen, damit {CMK} über das Netzwerk zugreifen kann.

Sobald der Agent installiert ist, können Sie den Host ins Monitoring
aufnehmen. Dabei gehen Sie nach dem gleichen Ablauf vor, wie oben für den Linux-Host beschrieben, allerdings sollten Sie den Host im dafür vorgesehenen Ordner [.guihint]#Windows# erstellen. Da Windows anders aufgebaut ist als Linux, findet der Agent natürlich andere Services. Die detaillierte Einführung ins Thema finden Sie im link:agent_windows.html[Artikel zur Überwachung von Windows].


[#snmp]
=== Mit SNMP überwachen

Professionelle Switches, Router, Drucker und viele andere Geräte und Appliances
haben bereits vom Hersteller eine eingebaute Schnittstelle für das Monitoring:
das Simple Network Management Protocol (SNMP). Solche Geräte lassen
sich sehr einfach mit {CMK} überwachen -- und Sie müssen noch nicht einmal
einen Agenten installieren.

Das grundsätzliche Vorgehen ist dabei immer gleich:

. In der Management-Oberfläche des Geräts schalten Sie SNMP frei für *lesende* Zugriffe von der IP-Adresse des {CMK}-Servers.

. Vergeben Sie dabei eine *Community*. Das ist nichts anderes als ein Passwort für den Zugriff. Da dieses im Netzwerk in der Regel im Klartext übertragen wird, ist es nur begrenzt sinnvoll, das Kennwort sehr kompliziert zu wählen. Die meisten Anwender verwenden für alle Geräte innerhalb eines Unternehmens einfach diegleiche Community. Das vereinfacht auch die Konfiguration in {CMK} sehr.

. Erstellen Sie in {CMK} den Host für das SNMP-Gerät wie link:intro.html#createhost[oben beschrieben], diesmal im dafür vorgesehenen Ordner [.guihint]#Network#.

. In den Eigenschaften des Hosts, im Kasten [.guihint]#Data sources# aktivieren Sie  [.guihint]#Checkmk Agent# und wählen Sie [.guihint]#No agent# aus.

. Im gleichen Kasten [.guihint]#Data sources# aktivieren Sie [.guihint]#SNMP# und wählen Sie [.guihint]#SNMP v2 or v3# aus.

. Falls die Community nicht `public` lautet, aktivieren Sie wieder unter [.guihint]#Data sources# den Eintrag [.guihint]#SNMP credentials#, wählen Sie [.guihint]#SNMP community (SNMP Versions 1 and 2c)# aus und tragen Sie im Eingabefeld darunter  die Community ein.

Für die letzten 3 Punkte sollte das Ergebnis so aussehen wie im folgenden Bild:

[{image-border}]
image::host_snmp_configuration.png[]

*Tipp:* Wenn Sie alle SNMP-Geräte in einem eigenen Ordner angelegt haben, führen Sie die Konfiguration der [.guihint]#Data sources# einfach für den Ordner aus. Damit gelten die Einstellungen automatisch für alle Hosts in diesem Ordner.

Der Rest läuft wie gehabt. Wenn Sie möchten, können Sie noch mit dem  Knopf [.guihint]#Save & go to connection tests# einen Blick auf die Seite [.guihint]#Test connection to host# werfen. Dort sehen Sie auch sofort, ob der Zugriff via SNMP funktioniert, hier z.B. für einen Switch vom Typ CISCO Catalyst 4500:

image::snmp_diagnostics.png[]

Klicken Sie anschließend auf [.guihint]#Save & go to service configuration#, um die Liste aller Services angezeigt zu bekommen. Diese sieht natürlich komplett anders aus als bei Linux oder Windows. Auf allen Geräten überwacht {CMK} per
Default alle Ports, die aktuell in Benutzung sind. Dies können Sie später nach Belieben anpassen. Auch zeigt es Ihnen in je einem Service,
der immer {OK} ist, die allgemeinen Informationen zu dem Gerät sowie
seine Uptime an.

Die ausführliche Beschreibung finden Sie im link:snmp.html[Artikel zur Überwachung via SNMP].


=== Cloud, Container und virtuelle Maschinen

Auch Cloud-Dienste, Container und  virtuelle Maschinen (VM) können Sie mit {CMK}  überwachen, selbst wenn Sie keinen Zugriff auf die eigentlichen Server haben. {CMK} nutzt dafür die von den Herstellern vorgesehenen Anwendungsprogrammierschnittstellen (API). Diese verwenden für den Zugriff durchgehend HTTP bzw. HTTPS.

Das Grundprinzip ist immer das Folgende:

. In der Management-Oberfläche des Herstellers richten Sie einen Account für {CMK} ein.
. Erstellen Sie in {CMK} einen Host für den Zugriff auf die API.
. Richten Sie für diesen Host eine Konfiguration zum Zugriff auf die API ein.
. Für die überwachten Objekte wie VMs, EC2-Instanzen, Container usw. legen Sie weitere Hosts in {CMK} an bzw. automatisieren die Erstellung.

Sie finden im Handbuch Schritt-für-Schritt-Anleitungen zur Einrichtung der Überwachung von link:monitoring_aws.html[Amazon Web Services (AWS)], link:monitoring_azure.html[Microsoft Azure], link:monitoring_docker.html[Docker], link:monitoring_kubernetes.html[Kubernetes] und link:monitoring_vmware.html[VMWare ESXi].




















[#snapins]
== Die Benutzeroberfläche

=== Die Statusoberfläche

Jetzt, da wir unserem Monitoring-System endlich etwas zu tun gegeben haben, ist
es sinnvoll, dass wir uns näher mit der Oberfläche befassen. Uns interessieren
hier vor allem die Dinge, die mit dem _Operating_ zu tun haben, also
mit dem täglichen Leben der Überwachung. In {CMK} wird dieser Teil auch
manchmal als _Statusoberfläche_ bezeichnet, weil es meist darum geht,
den aktuellen Status von allen Hosts und Services zu sehen.

[#tactical_overview]
=== Tactical Overview

Werfen wir zunächst einen näheren Blick auf die [.guihint]#Tactical Overview:#

image::tactical_overview.png[width=42%]

In der linken Spalte dieser kleinen Tabelle sehen Sie zunächst die
Anzahl Ihrer überwachten Hosts und Services. Die dritte Zeile zeigt
[.guihint]#Events.# Diese werden für Sie erst dann relevant, wenn Sie eine
Überwachung von Meldungen konfiguriert haben. Damit sind z.B. Messages
aus Syslog, SNMP-Traps und Logdateien gemeint. Dafür hat {CMK} ein
eigenes sehr mächtiges Modul: die link:ec.html[Event Console], die im Einsteigerhandbuch
nicht besprochen wird.

Die zweite Spalte zeigt die _Probleme._ Das sind die Objekte, die gerade
den Status {WARN}/{CRIT}/{UNKNOWN}, bzw. {DOWN}/{UNREACH} haben. Sie können
auf die Zahl in der Zelle klicken und kommen dann direkt zu den Objekten,
die hier gezählt wurden.

Die dritte Spalte kann nie größer werden als die zweite. Denn sie zeigt
diejenigen Probleme, die noch _nicht quittiert_ wurden. Eine link:intro.html#ack[Quittierung]
(Acknowledgment) ist eine Art „zur Kenntnisnahme“ von Problemen, die wir
weiter unten besprechen werden.

Die letzte Spalte zeigt Objekte, die gerade _stale (veraltet)_ sind.
Das sind Hosts oder Services, über die zur Zeit keine aktuellen Monitoring-Daten
vorliegen. Wenn z.B. ein Host aktuell gar nicht erreichbar ist, kann {CMK} natürlich
auch keine Neuigkeiten über dessen Services ermitteln. Das bedeutet dann nicht
automatisch, dass diese ein Problem haben. Deswegen nimmt {CMK} nicht einfach einen
neuen Status für diese Services an, sondern setzt sie auf den Pseudostatus _stale._
Die Spalte [.guihint]#Stale# fehlt, wenn sie überall 0 zeigen würde.

[#bookmarks_snapin]
=== Lesezeichen (Bookmarks)

Für Seiten, die Sie immer wieder aufsuchen, können Sie mit dem Snapin [.guihint]#Bookmarks#
Lesezeichen anlegen:

image::bookmarks.png[width=42%]

Aber wozu braucht man das? Immerhin gibt's ja auch Lesezeichen im
Browser! Nun, die {CMK}-Lesezeichen haben ein paar Vorteile:

* Sie ändern nur den Inhalt auf der rechten Seite, ohne die Sidebar neu zu laden.
* Sie können Lesezeichen mit anderen Benutzern teilen.
* Beim Setzen von Lesezeichen wird automatisch das Wiederausführen von Aktionen verhindert.

Die Lesezeichen sind in _Listen_ organisiert. So eine Liste ist eine
Sammlung von Lesezeichen, die Sie als Ganzes verwalten können. So können Sie
pro Liste entscheiden, ob diese anderen Benutzern bereitgestellt wird oder
für Sie privat bleibt.

Daneben hat jedes Lesezeichen ein [.guihint]#Topic#. Dies ist der Ordner, unter dem
es sich in der Seitenleiste einordnet.

*Wichtig:* Eine Liste kann Lesezeichen
in unteschiedliche Topics einsortieren! Umgekehrt kann ein Topic auch
Lesezeichen oder unterschiedliche Listen beinhalten.

Am Anfang ist das Snapin für die Bookmarks noch leer:

image::empty_bookmarks.png[width=42%]

Wenn Sie nun auf [.guihint]#Add Bookmark# klicken, wird zu dem, was gerade im Hauptbereich
angezeigt wird, ein neues Lesezeichen erzeugt und automatisch im Ordner (Topic)
[.guihint]#My bookmarks# abgelegt.

Wenn Sie tiefer in das Thema der Lesezeichen einsteigen wollen, können Sie mehr
Details im link:user_interface.html#bookmarks[Referenzartikel zur GUI] nachlesen.

[#quicksearch]
=== Quicksearch

Das Element [.guihint]#Quicksearch# sucht für Sie Hosts und Services in der Statusoberfläche
(nicht in WATO!). Es ist sehr interaktiv. Sobald Sie etwas getippt haben, sehen
Sie sofort Vorschläge für eine Vervollständigung. Hier dazu ein paar Tipps:

* Groß- und Kleinschreibung ist bei der Suche nicht relevant.
* Sie müssen keinen Eintrag aus der Vorschlagsliste auswählen. Drücken Sie einfach die *Eingabetaste,* so finden Sie eine Ansicht mit allen Hosts bzw. Services, auf die der Suchausdruck passt.
* Das Ergebnis der Suche können Sie in einem link:intro.html#bookmarks[Lesezeichen] speichern.
* Wenn Sie nach Host- _und_ Servicemuster suchen möchten, können Sie mit `h:` und `s:` arbeiten. Eine Suche nach `h:win s:cpu` zeigt Ihnen alle Services an, die `cpu` enthalten, auf  Hosts, die ihrerseits `win` enthalten.

image::quicksearch_h_s.png[width=42%]

[#master_control_snapin]
=== Master Control

Im Element [.guihint]#Master control# können Sie verschiedene Funktionen des
Monitorings einzeln aus- und wieder einschalten, wie z.B. die Alarmierung
[.guihint]#(Notifications).# Letzteres ist sehr nützlich, wenn Sie am System
größere Umbauarbeiten vornehmen und Ihre Kollegen nicht mit sinnlosen
Meldungen ärgern möchten.

image::master_control.png[width=42%]

Bitte achten Sie darauf, dass im Normalbetrieb alle Schalter auf [.guihint]#on# stehen.
Sonst können wichtige Funktionen des Monitorings abgeschaltet sein!

[#sidebar_customizing]
=== Anpassen der Seitenleiste

Jedes der Elemente können Sie aus der Seitenleiste entfernen und
zusammenklappen. Dazu haben Sie oben rechts in der Ecke jedes Elements zwei
Symbole. Ein Klick auf das Kreuz entfernt das Element. Ein Klick auf den
kleinen Strich klappt das Element zusammen. Ist ein Element zusammengeklappt,
ändert sich der kleine Strich in ein Quadrat. Klicken Sie auf das Quadrat,
wird das Element wieder aufgeklappt.

Am unteren Rand der Seitenleiste finden Sie ganz links das Symbol
icon:button_sidebar_add_snapin[]. Mit diesem können Sie die Seitenleiste
um weitere Snapins erweitern. Ein Klick auf das Symbol zeigt Ihnen alle
verfügbaren Elemente, die Sie dann mit einem einfachen Klick hinzufügen können.
Beachten Sie, dass diese am Ende erscheinen und Sie eventuell die Leiste
nach unten scrollen müssen, damit Sie sie sehen.

Die Reihenfolge der Snapins in der Sidebar können Sie ganz einfach mit der
Maus verändern. Klicken Sie mit der linken Maustaste an den oberen Rand
des Snapins, halten Sie die Maustaste gedrückt und verschieben Sie das Snapin
an die gewünschte Position.

Wenn Sie einmal die Seitenleiste ausblenden wollen, um die Ansicht der anderen
Fenster zu vergrößern, brauchen Sie lediglich mit der Maus ganz links an den
Rand der Seitenleiste zu klicken und schon wird die Seitenleiste zugeklappt. Sie
sehen dann nur noch eine schwarze senkrechte Linie. Wenn Sie später auf diese
klicken, können Sie damit die Sidebar wieder aufklappen.

=== Statusansichten (Views)

[#views_snapin]
==== Das Views-Snapin

Das wichtigste Snapin für das Operating ist neben der [.guihint]#Tactical Overview#
jenes mit dem Titel [.guihint]#Views.# Eine View ist eine Statusansicht, die Ihnen
den aktuellen Zustand von Hosts oder Services (oder teilweise auch anderen
Objekten) anzeigt.

So eine Ansicht kann einen Kontext haben, z.B. wenn sie alle Services
des Hosts `myhost012` zeigt. Andere Ansichten funktionieren global, z.B.
diejenige, die Ihnen alle Services anzeigt, die gerade ein Problem haben.

Alle diese globalen Ansichten sind über das [.guihint]#Views#-Snapin erreichbar.
Die Ansichten sind dort zu [.guihint]#Topics# (Ordnern) zusammengefasst, die
einzel auf- und zuklappbar sind:

image::snapin_views.png[width=42%]

==== Navigation in den Views

In den Statusansichten haben Sie zahlreiche Bedienmöglichkeiten:

* Sie können zu anderen Ansichten navigieren, indem Sie bestimmte Zellen anklicken (hier im Bespiel den Hostnamen oder die Anzahl seiner Services im Zustand {WARN}).
* Durch einen Klick auf einen Spaltentitel können Sie nach dieser Spalte sortieren.
* Durch einen Klick auf icon:context_button_dots[] sehen Sie eine ganze Reihe weiterer Knöpfe, die Sie zu verwandten Ansichten bringen.
* Der Knopf icon:view_button_filters[] öffnet eine Reihe von Suchfeldern, über die Sie die gezeigten Objekte filtern können.
* Mit icon:view_button_columns[] können Sie die Anzahl der angezeigten Spalten ändern (um Ihren breiten Bildschirm voll auszunutzen). Dies können Sie auch mit dem Mausrad umstellen, wenn sich der Zeiger über diesem Knopf befindet.
* Mit icon:view_button_refresh[] stellen Sie die Anzahl an Sekunden ein, nach denen die Ansicht automatisch neu geladen wird (schließlich können sich Statusdaten jederzeit ändern).

Die Views haben noch viele weitere Möglichkeiten, und Sie können sie auch anpassen und sogar
ganz eigene Ansichten selbst bauen. Wie das geht, erfahren Sie in einem eigenen link:views.html[Artikel.]


[#metrics]
=== Messwerte (Metriken)

Die große Mehrheit der Services liefert nicht nur einen Zustand, sondern
zusätzlich auch Messwerte. Nehmen wir als Beispiel den Service, der auf
einem Windows-Server das Dateisystem `C:` prüft:

image::filesystem_c.png[]

Neben dem Status {OK} stehen wir noch, dass 68,67{nbsp}GByte von insgesamt
135,78{nbsp}GByte des Dateisystems belegt sind, was 50,57{nbsp}% ausmacht. Die Angaben
sehen Sie im Textteil der Statusausgabe. Der wichtigste Wert davon -- die Prozentangabe --
wird außerdem auf der rechte Seite in der Spalte [.guihint]#Perf-O-Meter# visualisiert.

Das ist aber nur eine grobe Übersicht. Eine detaillierte Tabelle aller Messwerte
eines Services finden Sie in dessen Detailansicht in der Zeile [.guihint]#Service Metrics:#

image::service_metrics.png[]

Noch interessanter ist aber, dass {CMK} automatisch den _Zeitverlauf_ aller solcher
Messwerte für (natürlich einstellbar) bis zu vier Jahren aufbewahrt. Innerhalb der ersten
48 Stunden werden die Werte minutengenau gespeichert. Dargestellt werden die
Zeitverläufe in Graphen wie diesem, wie er in den {CEE} dargestellt wird:

image::example_graph.png[]

Hier ein paar Tipps, was Sie mit diesen Graphen anstellen können:

* Fahren Sie mit der Maus über einen Messwert, so öffnet sich ein kleines Pop-up mit den genauen Werten für diesen Zeitpunkt.
* „Packen“ Sie den Graphen an einer beliebigen Stelle im Datenbereich an. Schieben Sie die Maus nach links oder rechts, um den Zeitbereich anzupassen.
* Schieben Sie die Maus, wieder mit "gepackten" Graphen, nach oben und unten, um sie vertikal zu skalieren.
* Mit dem Mausrad können Sie in die Zeitachse rein- und rauszoomen.
* Mit der icon:resize_graph[] Ecke rechts unten können Sie den Graphen in seiner Größe ändern.

Auch in der {CRE} gibt es ein System zum Anzeigen von Graphen. Es basiert
auf PNP4Nagios und ist nicht interaktiv.

Das System für die Aufzeichnung, Auswertung und Darstellung von Messdaten
in {CMK} kann noch viel mehr -- vor allem in den {CEE}. Details dazu
finden Sie in einem link:graphing.html[eigenen Artikel.]


== {CMK} im Operating

=== Wichtige Funktionen im Operating

Sie haben Hosts ins Monitoring aufgenommen, und wir haben uns die Bedienung der
Statusoberfläche angesehen. Jetzt können wir loslegen mit dem eigentlichen
Monitoring. Denn der Sinn von {CMK} ist ja nicht, sich ständig mit der
Konfiguration zu befassen, sondern eine Unterstützung beim IT-Betrieb
zu bekommen.

Nun zeigen Ihnen die verschiedenen Statusansichten ja sehr genau, wie viele
und welche Probleme es gerade gibt. Aber für die Abbildung von Workflows
und ein richtiges „Arbeiten“ mit dem Monitoring benötigen wir noch etwas
mehr:

* link:intro.html#ack[Quittieren von Problemen]
* link:intro.html#downtimes[Setzen von Wartungszeiten]
* link:intro.html#notification[Senden von Alarmen im Falle von Problemen]

In diesem Kapitel befassen wir uns zunächst nur mit den ersten beiden Punkten. Die
Alarmierung behandeln wird später separat -- aus guten Gründen, wie Sie
noch sehen werden.

[#ack]
=== Quittieren von Problemen

Im Kapitel [.guihint]#Tactical Overview# haben wir schon gesehen, dass Probleme
entweder _unhandled_ oder _handled_ sein können. Das
Quittieren ist genau die Aktion, die aus einem unbehandelten
Problem ein behandeltes macht. Das muss nicht unbedingt heißen,
dass sich wirklich jemand darum kümmert. Manche Probleme verschwinden
ja auch von selbst wieder. Aber das Quittieren hilft, einen
Überblick zu behalten und Workflows zu etablieren.

Was passiert also beim Quittieren eines Problems genau?

* Der Host/Service wird in der [.guihint]#Tactical Overview# in der dritten Spalte nicht mehr gelistet.
* Das Standard-Dashboard listet das Problem ebenfalls nicht mehr auf.
* Das Objekt wird in Statusansichten mit dem Symbol icon:icon_ack[] markiert.
* Beim Quittieren wird ein Eintrag in der Objekt-History gemacht, so dass man das später nachvollziehen kann.
* Wiederholte Alarmierungen (falls konfiguriert) werden durch Quittierungen gestoppt.

==== Quittieren von einzelnen Problemen

Wie können Sie also ein Problem quittieren? Nun, rufen Sie es zunächst in einer
Statusansicht auf. Hier gibt es zwei Wege. Der erste Weg ist dann der beste, wenn
Sie nur ein einziges Problem quittieren möchten. Dazu klicken Sie sich bis zu
den Details des Hosts/Services durch -- also der Ansicht mit dem Titel

* [.guihint]#Status of Host myhost123# im Falle eines Hosts und
* [.guihint]#Service myhost123, FOO Service# im Falle eines Services.

Klicken Sie jetzt oben auf das Symbol icon:view_button_commands[].
Dieses öffnet eine Reihe von Eingabefeldern, über die Sie zahlreiche Aktionen
auf dem dargestellten Host/Service ausführen können. Gleich das oberste
Feld ist das gesuchte:

image::command_acknowledge.png[]

Tragen Sie hier einen Kommentar ein und klicken Sie auf [.guihint]#Acknowledge# -- und nach
der obligatorischen „Sind Sie sicher?“-Frage{nbsp}...

image::really_acknowledge.png[]

... gilt das Problem als quittiert. Dazu noch einige Hinweise:

* Mit dem Knopf [.guihint]#Remove acknowledgement# können Sie eine Quittierung auch wieder entfernen.
* Quittierungen können automatisch ablaufen. Dazu dient die Option [.guihint]#Expire Acknowledgement after ...#


==== Quittieren von mehreren Problemen auf einmal

Es ist gar nicht so selten, dass Sie eine Reihe (zusammengehöriger) Probleme auf einmal
quittieren werden wollen. Das geht fast genauso einfach. Rufen Sie dafür eine Statusansicht
auf, die alle diese Probleme anzeigt. Manchmal geht das mit [.guihint]#Quicksearch#. Etwas
flexibler ist die Ansicht [.guihint]#Services => Service Search.#

Wenn Sie es schaffen, dass die Ansicht _genau_ die zu quittierenden Services zeigt,
gehen Sie einfach wie oben beschrieben vor. Das Kommando wird dann automatisch für alle
gezeigten Services ausgeführt.

Brauchen Sie jedoch eine gezielte Auswahl, dann können Sie mit einem Klick auf
icon:view_button_checkboxes[] vor jeder Zeile eine Checkbox herbeirufen. Kreuzen
Sie die gewünschten Hosts oder Services an und führen Sie dann das Kommando aus.

*Achtung:* Vergessen Sie nie, dass Kommandos immer automatisch auf allen
angezeigten Objekten ausgeführt werden, falls Sie keine Checkboxen aktiviert haben!


[#downtimes]
=== Wartungszeiten

Manchmal gehen Dinge nicht aus Versehen kaputt, sondern mit Absicht. Oder
sagen wir eher, es wird absichtlich in Kauf genommen. Denn jedes Stück
Hard- oder Software muss gelegentlich gewartet werden, und während der dazu
notwendigen Umbauarbeiten wird der betroffene Host oder Service im Monitoring
natürlich auch mal auf {WARN} oder {CRIT} gehen.

Für diejenigen, die auf Probleme in {CMK} reagieren sollen, ist es dabei natürlich
sehr wichtig, dass sie darüber Bescheid wissen und nicht wertvolle Zeit mit „Fehlalarmen“
verlieren. Und um dies zu gewährleisten, kennt {CMK} das Konzept von _Wartungszeiten._
Diese heißen auf Englisch _Scheduled Downtimes_ (allerdings trifft man
an vielen Stellen schlicht auf das verkürzte _Downtimes,_ was ja eigentlich
nur bedeutet, dass ein Host {DOWN} bzw. ein Service {CRIT} ist).

Wenn also für ein Objekt eine Wartung ansteht, können Sie dieses in den Wartungszustand
versetzen -- entweder sofort oder aber auch für einen Zeitraum in der Zukunft. Dies
geschieht genauso wie das Quittieren, allerdings hier nun im Feld
[.guihint]#Downtimes:#

image::command_downtime.png[]

Bei den Wartungszeiten gibt es einen ganzen Haufen von Optionen. Einen Kommentar
müssen Sie in jedem Fall eingeben. Durch die Auswahl des passenden Knopfs
können Sie Beginn und Ende der Wartungszeit festlegen. So wird z.B. die
Schaltfläche [.guihint]#2 hours# das Objekt vom aktuellen Zeitpunkt an für zwei Stunden
als „in Wartung“ deklarieren. Im Gegensatz zu den Quittungen haben Wartungszeiten
grundsätzlich ein Ende, das vorher festgelegt wird.

Hier noch ein paar Hinweise:

* Wenn Sie einen Host in Wartung setzen, gelten alle seine Services automatisch als in Wartung. Sparen Sie sich daher die Arbeit, dies doppelt zu machen.
* Wenn Sie die {CEE} nutzen, können Sie auch _regelmäßige_ Wartungszeiten definieren (z.B. wegen eines obligatorischen Reboots einmal in der Woche).
* Die _flexiblen Downtimes_ beginnen automatisch erst dann, wenn das Objekt tatsächlich einen nicht-{OK}-Zustand annimmt.

Und hier sind die Auswirkungen einer Wartungszeit:

* In den Ansichten erscheint ein icon:icon_downtime[] Symbol bei den betroffenen Hosts/Services.
* Die Alarmierung über Probleme ist während der Wartung abgeschaltet.
* Die betroffenen Hosts/Services tauchen in der [.guihint]#Tactical Overview# nicht mehr als Probleme auf.
* In der link:availability.html[Verfügbarkeitsanalyse] werden geplante Wartungszeiten gesondert berücksichtigt.
* Zu Beginn und Ende einer Wartungszeit wird eine spezielle Alarmierung ausgelöst, die darüber informiert.

Weitere Hinweise zu den Wartungszeiten finden Sie wie immer in einem link:basics_downtimes.html[eigenen Artikel.]

[#finetuning]
== Finetuning des Monitorings

=== Fehlalarme -- der Tod jedes Monitorings

Ein Monitoring ist nur dann wirklich nützlich, wenn es _präzise_
ist. Das größte Hindernis für die Akzeptanz bei Kollegen (und wohl auch
bei Ihnen selbst) sind dabei _false positives,_ oder auf gut deutsch
_Fehlalarme._

Bei einigen {CMK}-Einsteigern haben wir erlebt, wie diese in kurzer Zeit sehr
viele Systeme in die Überwachung aufgenommen haben -- vielleicht deswegen,
weil das in {CMK} so einfach geht. Als sie dann kurz danach die Alarmierung für
alle aktiviert haben, wurden die Kollegen mit Hunderten von E-Mails pro
Tag überflutet, und bereits nach wenigen Tagen war die Begeisterung für
Monitoring nachhaltig zerstört.

Auch wenn {CMK} sich wirklich Mühe gibt, für alles vernünftige Voreinstellungen
zu haben, kann es einfach nicht präzise genug wissen, wie es in Ihrer
IT-Umgebung unter Normalzuständen zugehen soll. Und deswegen ist von Ihrer
Seite ein bisschen Handarbeit erforderlich, um das Monitoring fein zu justieren
und die letzten Fehlalarme wegzubekommen. Abgesehen davon
wird {CMK} natürlich auch etliches an _wirklichen_ Problemen finden, von
denen Sie und Ihre Kollegen noch nichts geahnt haben. Und auch die gilt es
erstmal zu beheben -- und zwar in der Realität, nicht im Monitoring!

Bewährt hat sich daher folgender Grundsatz: _erst Qualität, dann Quantität_. Oder anders
ausgedrückt:

* Nehmen Sie nicht zu viele Hosts auf einmal ins Monitoring auf.
* Sorgen Sie dafür, dass alle Services, bei denen nicht wirklich ein Problem besteht, zuverlässig auf {OK} sind.
* Aktivieren Sie die Alarmierung per E-Mail oder SMS erst, wenn {CMK} eine Zeit lang zuverlässig ohne oder mit sehr wenigen Fehlalarmen läuft.

Welche Möglichkeiten zum Feintuning Sie haben (damit alles grün wird)
und wie Sie gelegentlicht Aussetzer in den Griff bekommen,
zeigen wir Ihnen in diesem Kapitel.


[#rules]
=== Die regelbasierte Konfiguration

Bevor wir ans Konfigurieren gehen, müssen wir uns zuerst kurz mit den
Einstellungen von Hosts und Services in {CMK} auseinandersetzen.
Da {CMK} für große und komplexe Umgebungen entwickelt wurde, geschieht
das anhand von _Regeln._ Dieses Konzept ist sehr leistungsfähig
und bringt auch in kleineren Umgebungen viele Vorteile.

Die Grundidee ist, dass Sie nicht für jeden Service jeden einzelnen
Parameter explizit festlegen, sondern so etwas schreiben wie:
„_Auf allen produktiven Oracle-Servern werden Dateisysteme mit dem Präfix
`/var/ora` bei 90{nbsp}% Füllgrad _{WARN}_ und bei 95{nbsp}% _{CRIT}.“

So eine Regel kann mit einem Schlag Schwellwerte für Tausende von Dateisystemen
festlegen. Gleichzeitig dokumentiert sie auch sehr übersichtlich, welche Überwachungspolicies
in Ihrem Unternehmen gelten.

Natürlich können Sie auch Einzelfälle gesondert festlegen. Eine passende Regel könnte
so aussehen: „_Auf dem Server `srvora123` wird das Dateisystem
`/var/ora/db01` bei 96{nbsp}% Füllgrad_ {WARN} _und bei 98{nbsp}% _{CRIT}.“
Dieses Beispiel kann man als _Ausnahme_ bezeichnen -- es ist aber
trotzdem eine ganz normale Regel.

Jede Regel hat den gleichen Aufbau. Sie besteht immer aus einer
_Bedingung_ und einem _Wert._ Zusätzlich können Sie noch
einen Titel und einen Kommentar hinterlegen, um den Sinn der
Regel zu dokumentieren.

Die Regeln sind in _Regelketten_ organisiert. Für jede Art von
Parameter in {CMK} gibt es eine eigene Regelkette. So gibt es etwa eine mit dem
Namen [.guihint]#Filesystems (used space and growth),# welche die Schwellwerte für
alle Services festlegt, die Dateisysteme überwachen.  Wenn {CMK} also
feststellen möchte, welche Schwellwerte ein bestimmter Dateisystemcheck
bekommt, geht es alle Regeln dieser Kette der Reihe nach durch.
Die _erste_ Regel, bei der die Bedingung zutrifft, legt den Wert
fest -- also in diesem Fall die genauen Voraussetzungen, wann der Dateisystemcheck
{WARN} oder {CRIT} wird.

=== Regeln konfigurieren

Wie sieht das nun in der Praxis aus? Der normale Weg geht über das WATO-Modul
[.guihint]#Host & Service Parameters,# das Ihnen alle bekannten Regelketten anbietet:

[{image-border}]
image::rules_main_menu.png[]

Hier kommen Sie am einfachsten mit dem Suchfeld weiter. Tippen Sie hier z.B. `tablespace`,
so finden Sie alle Regelketten, die diesen Text im Namen oder in der (hier unsichtbaren) Beschreibung haben:

[{image-border}]
image::ruleset_search_tablespace.png[]

Die Zahl dahinter (hier überall `0`) zeigt die Anzahl der Regeln in der jeweiligen Kette.
Klicken Sie auf den Namen der Regelkette, so landen Sie in der Detailansicht:

[{image-border}]
image::ruleset_oracle_tablespaces.png[]

Die hier abgebildete Regelkette enthält noch keine Regeln. Aber mit dem Knopf
[.guihint]#Create rule in folder# können Sie
eine Regel anlegen. Dabei können Sie bereits den ersten Teil der Bedingung der Regel festlegen, nämlich
in welchem WATO-Ordner diese gelten soll. Wenn Sie die Einstellung [.guihint]#Main directory# z.B.
auf [.guihint]#Windows# ändern, so gilt die neue Regel nur für Hosts die direkt im oder unterhalb
vom Ordner [.guihint]#Windows# liegen.

Das Anlegen (und natürlich auch das spätere Bearbeiten) bringt Sie zu einer Eingabemaske
mit drei Feldern: Allgemeines, Wert und Bedingung. Im Kasten [.guihint]#Rule properties# sind
alle Angaben optional. Neben den informativen Texten haben Sie hier auch die Möglichkeit,
eine Regel vorübergehend zu deaktivieren. Das ist praktisch, denn so vermeiden Sie manchmal
ein Löschen und Neuanlegen, wenn Sie eine Regel vorübergehend nicht benötigen.

image::rule_ora_properties.png[]

Was Sie unter [.guihint]#Value# einer Regel finden, ist natürlich total individuell. Wie Sie hier
im Beispiel sehen, kann das schon eine ganze Menge an Parametern sein. Ein typischer
Fall ist wie hier: Jeder Einzelparameter wird per Checkbox aktiviert, und die Regel
legt dann auch nur diesen fest. Sie können z.B. einen anderen Parameter von einer anderen
Regel bestimmen lassen, wenn das Ihre Konfiguration vereinfacht.
Im Beispiel werden nur die Schwellwerte für prozentualen freien
Platz im Tablespace definiert:

image::rule_ora_value.png[]

Das Feld mit der Bedingung sieht erstmal etwas unübersichtlicher aus:

image::rule_ora_condition.png[]

[.guihint]#Condition type# erlaubt das Verwenden von vordefinierten Bedingungen, die
über die Option [.guihint]#Predef. Conditions# verwaltet werden. Das ist ein Feature für
„Poweruser“, die sehr viele Regeln mit den immer gleichen Bedingungen verwenden.
Lassen Sie das zunächst einfach auf [.guihint]#Explicit conditions# stehen.

Den [.guihint]#Folder# haben Sie ja gerade beim Anlegen bereits definiert, aber hier können
Sie ihn nochmal ändern.

Die [.guihint]#Host tags# (_Host-Merkmale_) sind ein ganz wichtiges Feature von {CMK}:
Hiermit können Sie eben z.B. sagen, dass eine Regel nur für _Produktivsysteme_
gelten soll. Weil die Host-Tags so wichtig sind, widmen wir ihnen gleich im Anschluss
einen eigenen Abschnitt. Um eine Tag-Bedingung hinzuzufügen, wählen Sie zunächst
in der Auswahlliste eine Tag-Gruppe aus und drücken _danach_ auf [.guihint]#Add tag condition.#

Mit den [.guihint]#Explicit hosts# können Sie die Regel auf einige ganz bestimmte Hosts beschränken.

Sehr wichtig sind die [.guihint]#Explicit Tablespaces#, welche die Regel auf ganz bestimmte
Services einschränken. Dazu sind zwei Anmerkungen wichtig:

* Der Name dieser Bedingung passt sich dem Regeltyp an. Wenn hier [.guihint]#Explicit Services# steht, geben Sie die _Namen_ der betroffenen Services an. Ein solcher könnte z.B. `Tablespace DW20` lauten -- also inklusive des Worts `Tablespace`. Im gezeigten Beispiel hingegen möchte man von Ihnen lediglich den Namen des Tablespaces selbst, also z.B. `DW20`.
* Die Texte werden immer *gegen den Anfang* gematcht! Die Beispielregel greift also auch auf den fiktiven Tablespace `DW20A`. Wenn Sie das nicht möchten, hängen Sie ein `$` ans Ende -- z.B. `DW20$`. Denn es handelt sich hier um sogenannte link:regexes.html[reguläre Ausdrücke.]

Die Labels, die Sie im Screenshot ebenfalls sehen, behandelt das Handbuch in einem
link:labels.html[eigenen Kapitel.]

Nach dem Speichern findet sich in der Regelkette genau eine Regel:

[{image-border}]
image::ruleset_ora_one_rule.png[]

[#hosttags]
=== Host-Merkmale (Host-Tags)

==== So funktionieren Host-Tags

Oben haben wir ein Beispiel für eine Regel gesehen, die nur für
„produktive“ Systeme gelten soll. Genauer gesagt haben wir in der Regel
eine Bedingung über das _Host-Tag_ [.guihint]#Productive system# definiert. Warum
macht man das nicht stattdessen einfach über Ordner? Nun, Sie können ja leider nur
eine einzige Ordnerstruktur definieren, und jeder Host kann nur in einem
Ordner sein. Es gibt aber viele ganz unterschiedliche Merkmale, die ein Host
haben kann. Dafür sind die Ordner einfach nicht flexibel genug.

Tags hingegen können Sie den Hosts völlig frei und beliebig zuordnen -- egal,
in welchem Ordner die Hosts sind. Und danach können sich Regeln
auf diese Tags beziehen. Das macht die Konfiguration nicht nur einfacher, sondern
auch leichter verständlich und weniger fehleranfällig, als wenn Sie für jeden
Host alles explizit festlegen würden.

Aber wie und wo legt man nun fest, welche Hosts welche Merkmale haben
sollen? Und wie können Sie eigene Merkmale definieren?

==== Tag-Gruppen und Tags definieren

Beginnen wir mit der zweiten Frage: eigene Merkmale. Zunächst müssen Sie
wissen, dass Merkmale in _Gruppen_ organisiert sind: _Tag-Gruppen_ (Merkmalsgruppen).
Nehmen wir als Beispiel den _Standort._ Eine Merkmalsgruppe könnte
also _Standort_ heißen. Und diese Gruppe könnte die Merkmale _München_,
_Austin_ und _Singapur_ enthalten. Grundsätzlich gilt dabei, dass
jeder Host in jeder Gruppe _genau ein Merkmal_ hat. Sobald Sie also eine
eigene Tag-Gruppe definieren, hat jeder Host immer ohne Ausnahme eines der Merkmale
aus dieser. Hosts, bei denen Sie kein Merkmal aus der Gruppe gewählt haben, bekommen
einfach per Default das erste zugewiesen.

Die Definition der Tag-Gruppen finden Sie im WATO-Modul icon:icon_tag[] [.guihint]#WATO => Tags#.

[{image-border}]
image::wato_tag_groups.png[]

Wie Sie sehen, sind einige Tag-Gruppen bereits vordefiniert. Die meisten davon können Sie
nicht ändern. Wir empfehlen Ihnen außerdem, die beiden vordefinierten Beispiele [.guihint]#Criticality#
und [.guihint]#Networking Segment# einfach in Ruhe zu lassen. Definieren Sie lieber Ihre eigenen Gruppen.
Das ist sehr einfach.

Klicken Sie auf [.guihint]#New tag group.# Das bringt Sie wie erwartet
zu einer Maske mit mehreren Feldern.
Im ersten vergeben Sie wie so oft in {CMK} eine interne ID -- die als Schlüssel
gilt und später nicht mehr geändert werden kann -- und einen sprechenden
Titel, den Sie später jederzeit anpassen können. Das [.guihint]#Topic# dient nur
der Übersicht. Wenn Sie hier ein Topic vergeben, wird das Merkmal bei den Host-Eigenschaften
in einem eigenen Feld angezeigt.

image::new_taggroup_basic.png[]


Im zweiten Feld kommen die eigentlichen Tags, also die Auswahlmöglichkeiten
der Gruppe. Auch hier vergeben Sie pro Tag eine interne ID und einen Titel:

image::new_taggroup_choices.png[]

Hinweise:

* Die IDs müssen über alle Gruppen hinweg eindeutig sein.
* Auch Gruppen mit nur einer einzigen Auswahl sind erlaubt und sogar sinnvoll. Diese erscheinen dann als Checkboxen. Jeder Host hat das Merkmal dann entweder oder eben nicht.
* Ignorieren Sie die [.guihint]#Auxiliary Tags# am besten.

Sobald Sie gespeichert haben, können Sie die neue Tag-Gruppe nutzen.

==== Tags den Hosts zuordnen

Wie Sie einem Host Tags zuordnen, haben Sie eigentlich schon gesehen: in den
Host-Eigenschaften beim Anlegen oder Bearbeiten eines Hosts. Im Feld
[.guihint]#Custom attributes# (oder in einem eigenen, falls Sie ein Topic vergeben haben)
taucht nun die neue Tag-Gruppe auf, und Sie können für den Host eine Auswahl treffen:

image::host_custom_attributes.png[]

Wie immer können Sie das Tag auch beim Ordner festlegen und bei einzelnen Hosts
nach Bedarf überschreiben.


=== Regelketten einfacher finden

Es gibt sehr viele Regelketten, und mit der Suche die richtigen zu finden,
ist nicht immer einfach. Es gibt aber noch einen anderen Weg: Wenn Sie einen
bestimmten Service haben und dessen Check-Parameter anpassen möchten, klicken
Sie auf das icon:icon_menu[] Menü und wählen den Eintrag
[.guihint]#Parameters for this services:#

[{image-border}]
image::service_rule_icon.png[]

Sie gelangen zu einer Seite, von der aus Sie Zugriff auf alle Regelketten
dieses Services haben:

[{image-border}]
image::parameters_of_this_service.png[]

Im ersten Feld mit dem Titel [.guihint]#Check origin and parameters# führt Sie
der zweite Eintrag (hier [.guihint]#CPU utilization on Linux/UNIX#) direkt zur
Regelkette, welche die Schwellwerte für diesen Service festlegt.

[#filesystems]
=== Schwellwerte für Dateisysteme

Nachdem Sie jetzt das Grundprinzip der Konfiguration von Services kennengelernt haben,
möchten wir Ihnen im Rest des Kapitels einige wichtige Dinge zeigen, die Sie in einem
neuen {CMK}-System konfigurieren sollten, um Fehlalarme zu reduzieren.

Das Erste sind angepasste Schwellwerte für die Überwachung von Dateisystemen. Per
Default nimmt {CMK} für _belegten Plattenplatz_ die Schwellen 80{nbsp}% für {WARN} und 90{nbsp}% für {CRIT}.
Nun sind 80{nbsp}% bei einer 2{nbsp}TByte großen Platte immerhin 400{nbsp}GByte -- vielleicht ein bisschen viel
Puffer. Deswegen hier ein paar Tipps dazu:

* Legen Sie Ihre eigenen Regeln in der Kette [.guihint]#Filesystem (used space and growth)# an.
* Die Parameter erlauben Schwellwerte, die von der Größe des Dateisystems abhängen. Wählen Sie dazu [.guihint]#Levels for filesystems => Levels for filesystem used space => Dynamic levels#. Mit dem Knopf [.guihint]#Add new element# definieren Sie jetzt pro Plattengröße eigene Schwellwerte.
* Noch einfacher geht's mit dem [.guihint]#Magic factor#, den wir im Kapitel link:intro.html#magicfactor[Best practices] vorstellen.

=== Hosts, die DOWN gehen dürfen

Nicht immer ist es ein Problem, wenn ein Rechner abgeschaltet wird. Der Klassiker ist das bei Druckern. Diese
mit {CMK} zu überwachen ist durchaus sinnvoll. Manche Anwender managen sogar die Nachbestellung von Toner
mit {CMK}. Aber das Ausschalten eines Druckers vor Feierabend ist ja kein Problem, sondern eher positiv. Dumm nur,
wenn {CMK} hier alarmiert, weil der entsprechende Host {DOWN} ist.

Sie können {CMK} sagen, dass es völlig in Ordnung ist, wenn ein Host ausgeschaltet ist. Dazu suchen
Sie in [.guihint]#WATO => Host & Service parameters# nach dem Regelsatz [.guihint]#Host check command.# Legen Sie
dort eine Regel für alle Drucker an (je nach Ihrer Struktur z.B. über einen Ordner oder über
ein passendes Host-Merkmal) und setzen Sie den Wert auf [.guihint]#Always assume host to be up:#

image::host_check_command.png[]

Jetzt werden alle Drucker grundsätzlich als {UP} angezeigt -- egal, wie der Status wirklich
ist.

Die Services des Druckers werden jetzt noch weiterhin geprüft und würden ein Timeout
und damit ein {CRIT} erhalten. Um dies zu vermeiden, konfigurieren Sie im Regelsatz
[.guihint]#Access to Agents => Check_MK Agent => Status of the Check_MK services#
eine Regel, in der Sie Timeouts und Verbindungsprobleme jeweils auf {OK} setzen:

image::rule_status_of_cmk_services.png[]

[#switchports]
=== Switchports

Wenn Sie mit {CMK} einen Switch überwachen, dann werden Sie feststellen, dass bei der Service-Konfiguration
automatisch für jeden Port, der zu dem Zeitpunkt {UP} ist, ein Service angelegt wird. Dies ist eine
sinnvolle Defaulteinstellung für Core- und Distribution-Switches -- also solche, wo nur Infrastrukturgeräte
oder Server angeschlossen sind. Bei Switches, an denen Endgeräte wie Arbeitsplätze oder Drucker angeschlossen
sind, führt das aber einerseits zu ständigen Alarmen, weil wiedermal ein Port auf {DOWN} geht, und andererseits zu
ständig neu gefundenen Services, weil ein bisher nicht überwachter Port umgekehrt {UP} geht.

Hier haben sich zwei Herangehensweisen etabliert. So können Sie die Überwachung auf die Uplink-ports beschränken.
Dazu legen Sie eine Regel bei den link:intro.html#disabled[disabled Services] an, welche die anderen Ports von
der Überwachung ausschließt.

Viel interessanter ist jedoch die zweite Methode: Hier überwachen Sie zwar alle Ports, erlauben aber
den Zustand {DOWN} als gültigen Zustand. Der Vorteil: Auch für Ports, an denen Drucker oder Arbeitsplätze
hängen, haben Sie eine Überwachung der Übertragungsfehler und erkennen so sehr schnell schlechte Patchkabel
oder Fehler in der Autonegotiation.

Um das umzusetzen, benötigen Sie zwei Regeln. Die erste ist in der Kette
[.guihint]#Parameters for discovered services => Discovery -- automatic service detection => Network Interface and Switch Port Discovery.#
Diese legt fest, unter welchen Bedingungen Switchports überwacht werden sollen. Legen Sie eine Regel für
die gewünschten Switches an und aktivieren Sie unter [.guihint]#Network interface port states to discover#
neben [.guihint]#1 - up# auch [.guihint]#2 - down:#

image::port_discovery.png[]

In der Service-Konfiguration der Switches werden die Ports mit dem Zustand {DOWN} nun auch angeboten,
und Sie können sie zur Serviceliste hinzufügen. Bevor Sie das Ganze aktivieren, benötigen Sie jetzt
natürlich noch die zweite Regel, die dafür sorgt, dass dieser Zustand als {OK} gewertet wird.
Die Regelkette heißt [.guihint]#Network interfaces and switch ports.# Aktivieren Sie die Option [.guihint]#Operational state,#
deaktivieren Sie hier [.guihint]#Ignore the operational state# und aktivieren Sie bei den [.guihint]#Allowed states#
die Zustände [.guihint]#1 - up# und [.guihint]#2 - down# (und eventuell weitere Zustände).

[#reboothosts]
=== Hosts, die regelmäßig gebootet werden

Manche Server werden turnusmäßig neu gestartet -- sei es, um Patches einzupielen oder einfach, weil das
so vorgesehen ist. Sie können Fehlalarme zu diesen Zeiten auf zwei Arten vermeiden:

{cre-only}
In der {CRE} definieren Sie zunächst eine [.guihint]#Timeperiod,#
welche die Zeiten des Reboots abdeckt. Wie das geht, erfahren Sie im Artikel über die
link:timeperiods.html[Timeperiods.] Danach legen Sie jeweils eine Regel in den
Ketten [.guihint]#Notification period for hosts# und [.guihint]#Notification period for services# für
die betroffenen Hosts an und wählen dort die zuvor definierte Timeperiod aus. Die zweite
Regel ist notwendig, damit auch Services, die in dieser Zeit auf {CRIT} gehen, keinen
Alarm auslösen. Falls nun während dieser Zeiten Probleme auftreten (und rechtzeitig wieder
verschwinden), wird keine Alarmierung ausgelöst.

{cee-only}
In den {CEE} gibt es Wartungszeiten, die sich automatisch regelmäßig wiederholen
können, die Sie für die betroffenen Hosts einfach setzen können.

*Tipp:* Neben dem Weg über Kommandos,
die wir bei den link:intro.html#downtimes[Wartungszeiten] gezeigt haben, gibt es auch noch den Weg
über den Regelsatz  [.guihint]#Recurring downtimes for hosts.# Dieser hat den großen Vorteil, dass auch Hosts,
die erster später in die Überwachung aufgenommen werden, automatisch diese Wartungszeiten bekommen.

[#disabled]
=== Services dauerhaft ignorieren

Bei manchen Services, die einfach nicht zuverlässig auf {OK} zu bekommen sind, ist es
am Ende besser, sie gar nicht zu überwachen. Hier könnten Sie nun einfach bei den
betroffenen Hosts in WATO die Services manuell aus der Überwachung herausnehmen,
indem Sie sie wieder auf [.guihint]#Undecided# setzen bzw. dort lassen. Dies ist aber umständlich
und fehleranfällig.

Viel besser ist es, wenn Sie Regeln definieren, nach denen bestimmte Services _systematisch_
nicht überwacht werden sollen. Dafür gibt es den Regelsatz [.guihint]#Disabled services.# Hier können
Sie z.B. sehr einfach eine Regel anlegen, nach der Dateisysteme mit dem Mountpunkt `/var/test`
grundsätzlich nicht überwacht werden sollen.

*Tipp:* Wenn Sie in der Service-Konfiguration eines Hosts einen einzelnen Service durch
Klick auf icon:icon_service_to_disabled[] deaktivieren, wird für den Host automatisch
eine Regel in eben dieser Regelkette angelegt. Diese Regel können Sie von Hand bearbeiten
und z.B. den expliziten Hostnamen entfernen. Dann wird der betroffene Service auf allen
Hosts abgeschaltet.

Weitere Informationen zur Konfiguration von Services lesen Sie in einem
link:wato_services.html[eigenen Artikel im Referenzteil.]

[#avgvalues]
=== Mittelwerte

Ein Grund für sporadische Alarmierungen sind Schwellwerte auf Auslastungsmetriken,
wie z.B. die CPU-Auslastung, die nur kurzfristig überschritten werden. In der
Regel sind solche kurzen Spitzen kein Problem und sollten vom Monitoring auch nicht
bemängelt werden.

Aus diesem Grund haben eine ganze Reihe von Check-Plugins in Ihrer Konfiguration
die Möglichkeit, dass die Messwerte vor der Anwendung der Schwellen über einen
längeren Zeitraum gemittelt werden. Ein Beispiel dafür ist die Regelkette für
die CPU-Auslastung für nicht-Unix-Systeme mit dem Namen [.guihint]#CPU utilization for simple devices.#
Hier gibt es die Option [.guihint]#Averaging for total CPU utilization:#

image::cpu_util_average.png[]

Wenn Sie diese aktivieren und `15` eintragen, so wird die CPU-Auslastung zunächst
über einen Zeitraum von 15 Minuten gemittelt und die Schwellwerte erst danach auf diesen Mittelwert
angewendet.

[#sporadic]
=== Sporadische Fehler in den Griff bekommen

Wenn alles nichts hilft und manche Services einfach gelegentlich für einen
einzelnen Check (also für eine Minute) auf einen Problemstatus gehen, gibt
es eine letzte Methode, die Fehlalarme verhindert. Dazu gibt es die Regelkette
[.guihint]#Maximum number of check attempts for service.#

Legen Sie dort eine Regel an und setzen Sie den Wert z.B. auf `3`, so
wird ein Service, der z.B. von {OK} auf {WARN} geht, zunächst noch keine Alarmierung
auslösen und auch in der [.guihint]#Tactical overview# noch nicht als Problem angezeigt werden.
Erst wenn der Status in drei aufeinanderfolgenden Checks (was insgesamt dann knapp
über zwei Minuten dauert) nicht {OK} ist, gilt das Problem als „hart“ und wird gemeldet.

Das ist zugegeben keine schöne Lösung, und Sie sollten immer versuchen, das Problem
an der Wurzel zu bekämpfen, aber manchmal sind die Dinge einfach wie sie sind, und
mit den [.guihint]#Check attempts# haben Sie für solche Fälle zumindest einen gangbaren Workaround.

[#discovery]
=== Neue und weggefallene Services

In einem Rechenzentrum wird ständig gearbeitet, und so wird die Liste der zu überwachenden
Services nie konstant bleiben. Damit Sie dabei möglichst nichts übersehen, richtet {CMK}
für Sie automatisch einen besonderen Service auf jedem Host ein. Dieser heißt [.guihint]#Check_MK Discovery:#

image::discovery_service.png[]

Dieser prüft in der Voreinstellung alle zwei Stunden, ob neue (noch nicht überwachte) Services gefunden
oder bestehende weggefallen sind. Ist dies der Fall, so geht der Service auf {WARN}. Sie können
dann in WATO die Service-Konfiguration aufrufen und diese wieder auf den aktuellsten Stand bringen.

*Tipp:* Manche Anwender speichern ein Lesezeichen für eine Ansicht, die alle Discovery-Services
auf allen Hosts zeigt, die nicht im Zustand {OK} sind. Diese können Sie dann regelmäßig -- z.B.
einmal pro Tag -- abarbeiten.


== Arbeit mit mehreren Benutzern

=== Benutzer in {CMK}

Sobald Sie Ihr Monitoring in einem Zustand haben, wo es beginnt, für andere
nützlich zu werden, ist es an der Zeit, sich mit der Benutzerverwaltung von
{CMK} zu befassen. Falls Sie das System lediglich alleine betreiben, ist
das Arbeiten mit `cmkadmin` völlig ausreichend, und Sie können einfach
beim nächsten Kapitel über die link:intro.html#notification[Alarmierung] weiterlesen.

Gehen wir also davon aus, dass Sie Kollegen haben, die gemeinsam mit
Ihnen {CMK} nutzen sollen. Warum arbeiten dann nicht einfach alle als
`cmkadmin`?  Nun, theoretisch geht das schon, aber es entsteht dabei
eine Reihe von Schwierigkeiten. Wenn Sie pro Person einen Account anlegen,
haben Sie etliche Vorteile:

* Benutzer können eigene Lesezeichen anlegen, ihre Seitenleiste individuell einrichten und auch andere Dinge für sich anpassen.
* Unterschiedliche Benutzer können unterschiedliche _Berechtigungen_ haben.
* Benutzer können nur für bestimmte Hosts und Services _zuständig_ sein und dann auch nur diese im Monitoring sehen.
* Sie können einen Benutzeraccount löschen, wenn ein Mitarbeiter die Firma verlässt, ohne dass das die anderen Zugänge beeinflusst.

Wie immer finden Sie alle Details zum Thema Benutzer, Rechte und Rollen in einem
link:wato_user.html[eigenen Artikel.]

[#roles]
=== Rechte und Rollen

Vor allem die letzten beiden Punkte sind erklärungsbedürftig. Beginnen wir
mit den Berechtigungen -- also mit der Frage, welcher Benutzer welche
Dinge tun darf. Dafür verwendet {CMK} das übliche Konzept der _Rollen._
Eine Rolle ist dabei nichts anderes als eine Sammlung von _Berechtigungen._
Jede der Berechtigungen erlaubt eine ganz bestimmte Handlung. So gibt es etwa eine
Berechtigung für das Ändern der globalen Einstellungen.

{CMK} wird mit drei Basisrollen ausgeliefert. Diese lauten:

[cols="25,10,~"]
|===
|Rolle |Kürzel |Bedeutung 

|Administrator |admin |Ein Benutzer mit dieser Rolle darf alles. Seine Hauptaufgabe ist das generelle Konfigurieren von {CMK}, nicht das Operating. Dies schließt natürlich auch das Anlegen von Benutzern und Anpassen von Rollen ein.
|Normal monitoring user |user |Diese Rolle ist für einen „normalen“ Benutzer im _Operating._ Der darf grundsätzlich nur solche Hosts und Services sehen, für die er zuständig ist. Zudem besteht die Möglichkeit, dass Sie ihm das Recht geben, seine Hosts in WATO selbst zu verwalten.
|Guest user |guest |Ein Gastbenutzer darf alles sehen, aber nichts ändern. Diese Rolle ist z.B. nützlich, wenn Sie einen Statusmonitor an die Wand hängen möchten, der immer eine Gesamtübersicht des Monitorings zeigt. Da ein Gastbenutzer nichts ändern kann, ist es auch möglich, dass mehrere Kollegen diesen Account gleichzeitig verwenden.
|===


Wie Sie Rollen anpassen können, erfahren Sie im
link:wato_user.html#roles[ausführlichen Artikel zur Benutzerverwaltung.]


[#contacts]
=== Kontakte und Zuständigkeiten

Der zweite wichtige Aspekt von Benutzern ist das Definieren von
_Zuständigkeiten._ Wer ist für den Host `mysrv024` oder für
den Service `Tablespace FOO` auf dem Host `ora012` zuständig?
Wer soll diesen in der Statusoberfläche sehen und eventuell alarmiert
werden, wenn es ein Problem gibt?

Dies geschieht in {CMK} nicht über Rollen, sondern über _Kontaktgruppen._
Das Wort „Kontakt“ ist im Sinne einer Alarmierung gemeint: Wen soll das Monitoring
kontaktieren, wenn es ein Problem gibt?

Das Grundprinzip ist wie folgt:

* Jeder Benutzer kann Mitglied von beliebig vielen Kontaktgruppen sein.
* Jeder Host und jeder Service ist Mitglied von _mindestens_ einer oder mehreren Kontaktgruppen.

Hier ist ein Beispiel für so eine Zuordnung:

image::contactgroup_example.png[width=50%]

Wie Sie sehen, kann sowohl eine Person als auch ein Host (oder Service) Mitglied
mehrerer Gruppen sein. Die Mitgliedschaft in den Gruppen hat folgende Auswirkungen:

* Ein Benutzer der Rolle `user` sieht im Monitoring genau die Objekte, die in einer seiner Kontakgruppen sind.
* Gibt es ein Problem mit einem Host oder Service, werden (per Default) alle Benutzer alarmiert, die in mindestens einer seiner Kontaktgruppen sind.

*Wichtig:* Es gibt in {CMK} _keine_ Möglichkeit, einen Host oder Service
_direkt_ einem Benutzer zuzuordnen.  Das ist absichtlich nicht gewollt,
da es in der Praxis zu Problemen führt -- z.B. dann, wenn ein Kollege Ihr
Unternehmen verlässt.

=== Anlegen von Kontaktgruppen

Das Erzeugen von neuen Kontaktgruppen ist sehr einfach und geschieht im WATO-Modul
icon:icon_contactgroups[] [.guihint]#Contact groups.# Eine Kontaktgruppe mit dem
Namen [.guihint]#Everything# ist bereits vordefiniert. Dieser sind automatisch alle Hosts
und Services zugewiesen. Der Sinn davon sind einfache Setups, in denen es noch
keine Aufgabenteilung unter den Administratoren gibt (oder Sie sowieso alles alleine
übernehmen).

Mit icon:icon_new[] [.guihint]#New contact group# legen Sie eine neue Gruppe
an. Hier brauchen Sie wie immer eine ID, die intern als Schlüssel verwendet
wird, sowie einen Titel, den Sie später auch ändern können. Hier im Beispiel
sehen Sie eine Kontaktgruppe mit der ID `servers` und dem Titel
`Windows & Linux Servers:`

image::wato_new_contact_group.png[]

[#hostcontacts]
=== Hosts zuordnen

Nachdem Sie die Kontaktgruppen angelegt haben, müssen Sie einerseits Hosts und
Services zuordnen und andererseits natürlich Benutzer. Letzteres machen Sie
in den Eigenschaften der Benutzer selbst, was wir gleich im Anschluss sehen
werden.

Für die Zuordnung von Hosts zu Kontaktgruppen gibt es zwei Wege, die Sie
auch gleichzeitig wählen können:

. Zuweisung über Regeln mit dem Regelsatz [.guihint]#Assignment of hosts to contact groups#
. Zuweisung über die Eigenschaften der Hosts oder Ordner in WATO

==== Zuordnung über Regeln

Den Regelsatz, den Sie für die erste Methode bennötigen, finden Sie am einfachsten über den
Knopf icon:icon_rulesets[] [.guihint]#Rules# im Modul [.guihint]#Contact groups.# Aber
wie immer hilft auch die Suchfunktion unter [.guihint]#Host & service parameters,# wenn Sie einfach
nach `contactgroups` suchen:

[{image-border}]
image::rulesets_contactgroups.png[]

Auch bei einer frischen {CMK}-Installation ist der Regelsatz übrigens nicht
leer. Sie finden hier eine Regel, die alle Hosts der oben erwähnten Gruppe
[.guihint]#Everything# zuweist. Legen Sie hier also selbst neue Regeln an und wählen Sie
die jeweilige Gruppe, die Sie den per Regel gewählten Hosts zuweisen wollen:

image::host_group_assignment_rule.png[]

*Wichtig:* Greifen für einen Host _mehrere_ Regeln, so werden _alle_
ausgewertet und der Host bekommt auf diese Art mehrere Kontaktgruppen.

==== Zuordnung über WATO-Eigenschaften

Die zweite Methode der Zuordnung geht über die Eigenschaften eines Hosts
in WATO. Das Vorgehen ist wie folgt:

. Rufen Sie die Eigenschaften des Hosts in WATO auf.
. Aktivieren Sie im Kasten [.guihint]#Basic settings# die Checkbox [.guihint]#Permissions.#
. Wählen Sie im Kasten [.guihint]#Available# eine oder mehrere Gruppen aus und verschieben Sie diese mit dem Pfeil nach rechts in das Feld [.guihint]#Selected.#
. Aktivieren Sie [.guihint]#Add these contact groups to the Hosts.#

[{image-border}]
image::host_permissions.png[]

Die Checkbox [.guihint]#Always add host contact groups also to its services# benötigen
Sie in der Regel nicht, denn Services erben automatisch die Kontaktgruppen
ihrer Hosts. Mehr dazu erfahren Sie gleich im Anschluss.

Natürlich können Sie wie immer diese Host-Eigenschaft auch im Ordner
festlegen. Das Verfahren ist ähnlich, nur dass diesmal ein paar zusätzliche
Checkboxen auftauchen, die Sie einfach in ihrem Defaultzustand belassen.

=== Services zuordnen

Services müssen Sie nur dann zu Kontaktgruppen zuordnen, wenn diese von
denen ihrer Hosts abweichen sollen.  Dabei gilt allerdings ein wichtiger
Grundsatz: Hat ein Service mindestens eine Kontaktgruppe explizit zugewiesen,
erbt er _keine_ Kontaktgruppen vom Host mehr.

Das ermöglicht Ihnen z.B. eine Trennung von Serverbetrieb und
Anwendung. Stecken Sie z.B. den Host `srvwin123` in die Kontaktgruppe
`windows`, aber alle Services, die mit dem Präfix `Oracle`
beginnen, in die Kontaktgruppe `oracle`, so werden die Windows-Admins
die Oracle-Services nicht sehen, und die Oracle-Admins bekommen umgekehrt
keine Details zu den Services des Betriebssystems -- eine oft sehr sinnvolle
Aufteilung.

Sollten Sie diese Trennng nicht benötigen, dann legen Sie einfach Zuordnungen
für die Hosts fest -- fertig!

Benötigen Sie dennoch eine explizite Zuordnung, so geschieht das über den Regelsatz
[.guihint]#Assignment of services to contact groups.# Das Verfahren ist analog zu dem
oben beschriebenen, allerdings geben Sie hier wie gewohnt noch Bedingungen für die
Service-Namen an.

[#users]
=== Anlegen von Benutzern

Die Verwaltung der Benutzer finden Sie im WATO-Modul icon:icon_users[] [.guihint]#Users:#

[{image-border}]
image::wato_module_users.png[]

Wundern Sie sich nicht, wenn es dort nebem dem Eintrag `cmkadmin`
auch einen Benutzer `automation` gibt! Dieser ist für Zugriffe von
Prozessen und Skripten auf die HTTP-API gedacht und wird vom {CMK}-System
selbst genutzt. Näheres dazu finden Sie im link:wato_user.html#automation[Referenzteil.]

Und falls Sie über den Knopf icon:icon_ldap[] [.guihint]#LDAP Connections#
gestolpert sind: Wenn Sie in Ihrer Firma _Active Directory_ oder einen
anderen LDAP-Dienst einsetzen, haben Sie auch die Möglichkeit, Benutzer
und Gruppen aus diesen Diensten einzubinden. Dies wird in einem
link:ldap.html[eigenen Artikel beschrieben.]

Einen neuen Benutzer legen Sie mit dem Knopf icon:icon_new[] [.guihint]#New user# an. Diese Maske
ist natürlich fast identisch mit derjenigen, die Sie sehen, wenn Sie einen bestehenden
Benutzer bearbeiten (das Symbol icon:icon_edit[] neben dem Benutzer), nur dass dort keine
Änderung des Benutzernamens möglich ist:

image::wato_new_user_identity.png[]

Im ersten Feld geben Sie wie immer eine ID [.guihint]#(Username#) und einen Titel [.guihint]#(Full name)# ein -- hier
den ausgeschriebenen Namen des Benutzers. Die Felder [.guihint]#Email address# und
[.guihint]#Pager address# sind optional und dienen der link:intro.html#notification[Alarmierung]
via E-Mail bzw. SMS.

*Hinweis:* Tragen Sie hier vorerst _noch keine_ Mailadresse ein. Lesen
Sie zunächst die Hinweise im Kapitel über die link:intro.html#notification[Alarmierung.]

Das zweite Feld betrifft Sicherheit und Berechtigungen:

image::wato_new_user_security.png[]

Lassen Sie die Einstellung auf [.guihint]#Normal user login with password# und
vergeben Sie hier in initiales Passwort. Ganz unten können Sie dem Benutzer
Rollen zuordnen. Ordnen Sie mehr als eine Rolle zu, so bekommmt der Benutzer einfach
das Maximum an Berechtigungen aus diesen Rollen (für die drei vordefinierten Rollen
ist das allerdings nicht sehr sinnvoll).

Im dritten Feld wählen Sie aus, zu welchen Kontaktgruppen der Benutzer gehören
soll. Wählen Sie die vordefinierte Gruppe [.guihint]#Everything# aus, so wird der Benutzer
für alles zuständig sein, da in dieser Gruppe jeder Host und Service enthalten ist:

image::wato_new_user_contact_groups.png[]

Übrigens: Das Feld [.guihint]#Personal Settings# enthält genau die Einstellungen
(bis auf das Passwort), die der Benutzer auch selbst ändern kann. Benutzer
der Rolle `guest` können ihre Einstellungen nicht ändern, und so gibt es hier die
Möglichkeit, z.B. die Sprache oder das [.guihint]#User interface theme# einzustellen.


== Alarmierung

[#notifications]
=== Grundlegendes

_Alarmierung_ (_Notification_) bedeutet in {CMK}, dass Benutzer aktiv
darüber benachrichtigt werden, wenn sich der Zustand von einem Host oder Service
_ändert_. Nehmen wir an, zu einem bestimmten Zeitpunkt geht auf dem Host
`mywebsrv17` der Service `HTTP foo.bar` von {OK} auf {CRIT}.
{CMK} erkennt dies und sendet z.B. an alle Kontaktpersonen dieses Services
eine E-Mail mit den wichtigsten Daten zu diesem Ereignis. Später ändert sich der
Zustand wieder von {CRIT} auf {OK}, und die Kontakte bekommen eine erneute E-Mail --
diesmal zu dem Ereignis, das _Recovery_ genannt wird.

Dies ist aber nur die einfachste Art der Alarmierung, und es gibt zahlreiche
Möglichkeiten, wie Sie das verfeinern können:

* Sie können per SMS, Pager, Slack und anderen Internetdiensten alarmieren.
* Sie können Alarmierungen an bestimmten link:timeperiods.html[Zeitfenstern] festmachen (Bereitschaft).
* Sie können Eskalationen definieren, falls der zuständige Kontakt nicht schnell genug aktiv wird.
* Benutzer können selbständig Alarme „abonnieren“ oder abbestellen, wenn Sie das zulassen möchten.
* Sie können generell über komplexe Regeln festlegen, wer wann über was alarmiert werden soll.

Bevor Sie jedoch mit der Alarmierung beginnen, sollten Sie noch Folgendes beachten:

* Die Alarmierung ist ein optionales Feature. Manche Anwender haben einen Leitstand, der rund um die Uhr besetzt ist und lediglich mit der Statusansicht arbeitet.
* Aktivieren Sie die Alarmierung zunächst nur für sich selbst und machen Sie sich für _alles_ zuständig. Beobachten Sie ein paar Tage oder Wochen, wie groß das Volumen an Alarmen ist. link:intro.html#finetuning[Tunen] Sie Ihr Monitoring.
* Aktivieren Sie die Alarmierung für Ihre Kollegen erst dann, wenn Sie die falschen Positiven (Fehlalarme) auf ein Minimum reduziert haben.

[#notify_init]
=== Mailversand vorbereiten

Der einfachste und bei weitem üblichste Fall ist die Alarmierung per E-Mail. Das ist
leicht einzurichten, und in einer E-Mail ist genug „Platz“, um auch die Graphen der Messdaten
mitzusenden.

Bevor Sie per E-Mail alarmieren können, muss Ihr {CMK}-Server für das Versenden von Mails
eingerichtet sein. Bei allen unterstützten Linux-Distributionen läuft das auf Folgendes hinaus:

. Installieren Sie einen SMTP-Serverdienst. Dies geschieht meist automatisch bei der Installation der Distribution.
. Geben Sie einen _Smarthost_ an. Auch hier werden Sie meist bei der Installation des Servers gefragt. Der Smarthost ist ein Mailserver in Ihrem Unternehmen, der für {CMK} die Zustellung der E-Mails übernimmt. Sehr kleine Unternehmen haben meist keinen eigenen Smarthost. In diesem Fall verwenden Sie den SMTP-Server, der Ihnen von Ihrem E-Mail-Provider bereitgestellt wird.

Wenn der Mailversand korrekt eingerichtet ist, sollten Sie in der Lage sein, auf der Kommandozeile eine
E-Mail zu versenden, z.B. über diesen Befehl:

[{shell}]
----
{c-omd} echo "Testcontent" | mail -s Test harri.hirsch@example.com
----

Die E-Mail sollte ohne Verzögerung zugestellt werden. Falls das nicht
klappt, finden Sie Hinweise in der Logdatei des SMTP-Servers im Verzeichnis
`/var/log`.  Weitere Details zum Einrichten von Mailservices unter Linux
finden Sie im link:notifications.html#smtp[Referenzteil des Handbuchs.]

=== Alarmierung per E-Mail aktivieren

Wenn der Versand von E-Mail grundsätzlich funktioniert, dann ist das Aktivieren der Alarmierung
sehr einfach -- und vielleicht haben Sie es quasi schon ohne zu wissen beim Anlegen der
Benutzer gemacht. Damit ein Benutzer Alarme bekommt, sind folgende zwei Schritte notwendig:

* In den Eigenschaften des Benutzers muss eine Mailadresse eingetragen sein.
* Der Benutzer muss für Hosts oder Services zuständig sein (über entsprechende Kontaktgruppen).

=== Alarmierung ausprobieren

Es wäre ein bisschen umständlich, zum Test der Alarmierung auf ein echtes Problem zu warten oder
gar eines zu provozieren. Einfacher geht das mit dem Kommando [.guihint]#Fake check results.# Dies finden
Sie auf dem gleichen Weg, wie die link:intro.html#ack[Quittierungen] oder die link:intro.html#downtimes[Wartungszeiten.]

*Wichtig:* Dieser Kasten ist nur dann sichtbar, wenn Sie die Rolle `admin` besitzen.

image::fake_check_results.png[]

Wählen Sie am besten einen Service, der gerade {OK} ist und setzen Sie ihn per Hand auf {CRIT}.
Dies sollte sofort eine Alarmierung auslösen. Nach spätestens einer Minute -- wenn der nächste reguläre
Check ausgeführt wird -- geht der Service dann von selbst wieder auf {OK} und eine zweite Alarmierung
sollte ausgelöst werden: die vom Recovery.

=== Unterdrückte Alarmierung

Falls Sie keine E-Mail bekommen, muss das nicht gleich ein Fehler sein, denn es gibt viele
Situationen, in denen die Alarmierung von {CMK} absichtlich unterdrückt wird:

* Wenn ein Host auf {DOWN} ist, werden keine Alarmierungen seiner Services ausgelöst!
* Wenn Sie die Alarmierung im Snapin [.guihint]#Master Control# ausgeschaltet haben.
* Wenn ein Service oder Host sich in einer link:intro.html#downtimes[Wartungszeit] befindet.
* Wenn der Zustand in letzter Zeit zu oft zwischen verschiedenen Zuständen gewechselt hat und der Service deswegen als icon:icon_flapping[] _unstetig (flapping)_ markiert wurde. Dies kann schnell passieren, wenn Sie mittels [.guihint]#Fake check results# den Zustand ständig wechseln!

=== Anpassen der Alarmierung

Sie können Sie Alarmierung in {CMK} auf unterschiedlichste Art anpassen und sehr komplexe
Regelwerke definieren, wer wann auf welchem Weg benachrichtigt werden soll. Alle Einzelheiten
dazu erfahren Sie im link:notifications.html[Referenzteil des Handbuchs.]

=== Fehlersuche

Das Alarmierungsmodul in {CMK} ist sehr komplex -- einfach weil es sehr viele sehr unterschiedliche
Anforderungen abdeckt, die sich in über zehn Jahren Praxiserfahrung als wichtig herausgestellt haben.
Die Frage „Warum hat {CMK} hier nicht alarmiert?“ wird Ihnen deswegen gerade am Anfang öfter gestellt
werden, als Sie vielleicht vermuten. Deswegen finden Sie hier ein paar Tipps zur Fehlersuche.

Wenn ein Alarm von einem bestimmten Service nicht ausgelöst wurde, ist der erste Schritt,
die _History_ des Services zu betrachten. Diese finden Sie, wenn Sie auf die Detailseite des Services
in der Statusoberfläche gehen und dort auf den Knopf icon:icon_history[] [.guihint]#History# klicken.
Dort finden Sie alle Ereignisse dieses Services chronologisch von neu nach alt aufgelistet.
Hier ist ein Beispiel von einem Service, wo zwar versucht wurde, die Alarmierung auszulösen, aber
der Mailversand nicht funktioniert hat (weil kein SMTP-Server installiert ist):

image::service_history_broken_alarm.png[]

Noch mehr Informationen finden Sie in der Datei `var/log/notifiy.log`.
Diese können Sie z.B. im Terminal mit dem Befehl `less` auslesen oder
mit dem Kommando `tail -f` fortlaufend beobachten. Letzteres ist dann
sinnvoll, wenn Sie nur an _neuen_ Meldungen interessiert sind, also
solchen, die erst nach der Eingabe von `tail` entstehen. Vergessen
Sie nicht, zunächst mit `su - ` zu Ihrem Instanzbenutzer zu wechseln:

[{shell}]
----
{c-root} su - mysite
{c-omd} 
----

Jetzt können Sie die Datei mit `less` öffnen:

[{shell}]
----
{c-omd} less var/log/notify.log
----

Falls Sie `less` noch nicht kennen: Mit *Umschalt-G* springen Sie
ans Ende der Datei (bei Logdateien ist das ja immer nützlich), und mit *Q*
beenden Sie `less`.

Hier ist ein Ausschnitt aus `notify.log` für eine erfolgreich ausgelöste Alarmierung:

./var/log/notify.log
[{file}]
----
2019-09-05 10:21:48 Got raw notification (server-linux-3;CPU load) context with 71 variables
2019-09-05 10:21:48 Global rule 'Notify all contacts of a host/service via HTML email'...
2019-09-05 10:21:48  -> matches!
2019-09-05 10:21:48    - adding notification of martin via mail
2019-09-05 10:21:48 Executing 1 notifications:
2019-09-05 10:21:48   * notifying martin via mail, parameters: (no parameters), bulk: no
2019-09-05 10:21:48 Creating spoolfile: /omd/sites/mysite/var/check_mk/notify/spool/cbe1592e-a951-4b70-9bac-0141d3d74986
----

Falls Sie tiefer in das Thema Alarmierung einsteigen möchten, finden Sie alle Details im
link:notifications.html[Referenzteil des Handbuchs.]


== Das Monitoring weiter ausbauen

Mit dem Einrichten der Alarmierung haben Sie den letzten Schritt vollzogen,
Ihr {CMK}-System ist einsatzbereit! Damit sind die Möglichkeiten von {CMK}
natürlich noch nicht ansatzweise ausgereizt. Es gibt zahlreiche Möglichkeiten,
Ihr Monitoring weiter auszubauen.

=== Sicherheit optimieren

Auch wenn Monitoring „nur schaut“, ist das Thema IT-Sicherheit auch hier wichtig.
Im Referenzteil finden Sie dazu einen link:security.html[Übersichtsartikel,] der Ihnen
Tipps gibt, wie Sie die Sicherheit Ihres Systems optimieren können.


=== Sehr große Umgebungen überwachen

Wenn Ihr Monitoring eine Größenordnung erreicht hat, wo Sie Tausende oder noch mehr
Hosts überwachen, werden Fragen der Architektur und des Tunings interessant.
Das wichtigste Thema ist hier zunächst das link:distributed_monitoring.html[verteilte Monitoring.]
Dabei arbeiten Sie mit mehreren {CMK}-Instanzen, die Sie zu einem großen System
zusammenschalten und die vielleicht sogar global verteilt sind.

image::distributed_monitoring.png[width=470]


=== Verfügbarkeit und SLAs

Mit dem link:availability.html[Verfügbarkeits-Modul] kann {CMK} sehr präzise berechnen,
wie hoch genau die Verfügbarkeit von Hosts oder Services in bestimmten Zeiträumen
war, wie viele Ausfälle es gegeben hat, wie lang diese waren und vieles mehr.

[{image-border}]
image::avail_screenshot_neu.png[]

Und mit dem in den {CEE} enthaltenen link:sla.html[SLA-Modul] können Sie {CMK} die
Einhaltung von Service-Level-Agreements überprüfen und sogar aktiv überwachen
lassen.

image::sla_view_example_modern.png[]

=== Hardware-/Software-Inventur

Die link:inventory.html[Hardware-/Software-Inventur] gehört eigentlich nicht mehr zum Monitoring,
aber {CMK} kann mit den bereits vorhanden Agenten umfangreiche Informationen
zu Hardware und Software Ihrer überwachten Systeme übermitteln. Dies ist sehr
hilfreich für die Wartung, das Lizenzmanagement oder das automatische Befüllen von
Configuration Management Databases.

[{image-border}]
image::inventory_example.png[]

=== Überwachen von Meldungen und Events

Bisher haben wir uns nur mit der Überwachung der aktuellen _Zustände_
von Hosts oder Services befasst. Ein ganz anderes Thema ist das Auswerten
von spontanen _Meldungen,_ die z.B. in Logdateien auftauchen oder
per Syslog oder SNMP-Traps versendet werden. {CMK} hat dafür ein komplett
integriertes System mit dem Namen link:ec.html[Event Console.]

image::ec_open_events.jpg[]


=== Visualisierung auf Karten und Diagrammen

Mit dem in {CMK} integrierten Add-on link:nagvis.html[NagVis] können Sie auf beliebigen
Karten oder Diagrammen Zustände darstellen. Dies eignet sich hervorragend, um
ansprechende Gesamtübersichten zu erstellen, z.B. für Bildschirme in Leitständen.

[{image-border}]
image::nagvis_map_2.png[]


=== Business Intelligence

Mit dem link:bi.html[Business-Intelligence-Modul] können Sie
aus den vielen einzelnen Statuswerten, die {CMK} liefert, den Gesamtzustand von
_geschäftskritischen Anwendungen_ ableiten und übersichtlich darstellen.

image::bi_downtimes.png[]


=== PDF-Berichte erstellen

Das in den {CEE} enthaltene link:reporting.html[Reporting-Modul] von {CMK} erlaubt Ihnen
das Erstellen von PDF-Berichten zu Zeiträumen in der Vergangenheit, die
Ereignisse, Verfügbarkeiten und vieles mehr übersichtlich darstellen können.


=== Agenten automatisch updaten

Wenn Sie viele Linux- und Windows-Server überwachen, können Sie den in den {CEE}
enthaltenen link:agent_deployment.html[Agent-Updater] benutzen, um Ihre Monitoring-Agenten
und deren Konfiguration zentralisiert auf dem gewünschten Stand zu halten.

=== Eigene Plugins entwickeln

Auch wenn {CMK} fast 2.000 Check-Plugins mit ausliefert, kann es immer sein, dass
ein konkretes Plugin fehlt. Wie Sie Plugins selbst entwickeln können, lesen Sie in einem
link:legacy_documentation.html#devel[eigenen Bereich im Handbuch.]


[#best_practices]
== Best Practises, Tipps & Tricks

=== CPU-Single-Core-Auslastung

{CMK} richtet sowohl unter Linux als auch unter Windows automatisch einen Service
ein, der die durchschnittliche Auslastung der CPU-Leistung über die
letzte Minute überwacht. Dies ist natürlich sinnvoll, erkennt aber eine
Reihe von Fehlern nicht, beispielsweise dass ein einzelner Prozess Amok läuft
und permanent _eine_ CPU mit 100{nbsp}% belastet. Bei einem System mit 16 CPUs
trägt eine CPU nur mit 6.25{nbsp}% zur Gesamtleistung bei, und so wird selbst im Extremfall
nur eine Auslastung von 6.25{nbsp}% gemessen -- was natürlich
nicht zu einer Alarmierung führt.

Deswegen bietet {CMK} die Möglichkeit (sowohl für Windows als auch für Linux),
alle vorhandenen CPUs einzeln zu überwachen und festzustellen, ob einer der
Kerne über längere Zeit permanent ausgelastet ist. Diesen Check einzurichten,
hat sich als gute Idee herausgestellt.

Um das für Ihre Windows-Server einzurichten, legen Sie eine
link:intro.html#rules[Regel] in der Kette [.guihint]#CPU utilization for simple devices#
an. Diese Regel ist eigentlich auch zuständig für die Überwachung
aller CPUs. Es gibt hier aber eine Option mit dem Namem
[.guihint]#Levels over an extended time period on a single core CPU utilization.#
Aktivieren Sie in der Regel nur diese Option:

image::cpu_single_core.png[]

Definieren Sie die Regelbedingung so, dass sie nur für die Windows-Server greift,
z.B. durch einen geeigneten Ordner oder ein Host-Tag. Diese Regel wird
andere Regeln in der gleichen Kette nicht beeinflussen, wenn diese andere
Optionen festlegen, z.B. die Schwellwerte für die Gesamtauslastung.

Die zusätzliche Überprüfung findet im bereits vorhandenen Service [.guihint]#CPU utilization#
statt.

Bei Linux-Servern ist dafür die Regelkette [.guihint]#CPU utilization on Linux/UNIX#
zuständig, wo Sie exakt die gleiche Option finden.

=== Windows-Dienste überwachen

In der Voreinstellung überwacht {CMK} auf Ihren Windows-Servern keine Dienste! Warum nicht? Nun, weil
nicht automatisch klar ist, welche Dienste für Sie wichtig sind.

Wenn Sie sich nicht die Mühe machen wollen, für jeden Server von Hand festzulegen, welche Dienste
dort wichtig sind, können Sie auch einen Check einrichten, der einfach überprüft, ob alle
Dienste mit der Startart [.guihint]#automatisch# auch wirklich laufen. Zusätzlich können Sie sich informieren
lassen, ob Dienste laufen, die von Hand -- quasi außer der Reihe -- gestartet wurden. Denn diese
werden nach einem Reboot nicht mehr laufen, was natürlich ein Problem sein kann.

Dazu benötigen Sie zunächst eine Regel in der Kette [.guihint]#Windows Services,# die Sie wie immer bequem
mit der Suchfunktion finden können. Die entscheidende Option in dieser Regel lautet [.guihint]#Service states.#
Aktivieren Sie diese und fügen Sie drei Elemente hinzu:

image::windows_services_rule.png[]

Dadurch erreichen Sie folgende Überwachung:

* Ein Dienst mit der Startart [.guihint]#auto#, der läuft, gilt als {OK}.
* Ein Dienst mit der Startart [.guihint]#auto#, der nicht läuft, gilt als {CRIT}.
* Ein Dienst mit der Startart [.guihint]#demand#, der läuft, gilt als {WARN}.

Diese Regel gilt allerdings nur für Services, die auch wirklich überwacht
werden! Deswegen benötigen wir jetzt noch einen zweiten Schritt: Erstellen
Sie dazu eine neue Regel in der Kette [.guihint]#Windows Service Discovery.#
Diese regelt, welche Windows-Dienste {CMK} automatisch als zu überwachende
Services vorschlägt.

Wenn Sie diese Regel anlegen, können Sie zunächst im Feld [.guihint]#Services (Regular Expressions)#
den regulären Ausdruck `.*` angeben, der auf alle Services matcht. Wenn Sie dann
speichern und bei einem passenden Host in die Service-Konfiguration in WATO wechseln, werden
Sie eine große Zahl von neuen Services finden -- für jeden Windows-Service einen.

Um die Anzahl der überwachten Services einzuschränken, kehren Sie dann zu
der Regel zurück und verfeinern die Suchausdrücke nach Bedarf. Dabei wird
Groß- und Kleinschreibung unterschieden! Hier ist ein Beispiel:

image::windows_service_discovery.png[]

Sollten Sie die Services vorhin schon in die Überwachung aufgenommen haben, erscheinen diese jetzt als
fehlend. Mit dem Knopf [.guihint]#Automatic refresh (tabula rasa),#
können Sie reinen Tisch machen und die ganze Liste neu generieren.

=== Überwachen der Internetverbindung

Der Zugang Ihrer Firma zum Internet ist natürlich für alle sehr wichtig. Die Überwachung
desselben ist dabei etwas ungewöhnlich. Denn es gibt ja nicht „das Internet“, sondern
Milliarden von Hosts. Sie können aber trotzdem sehr effizient eine Überwachung einrichten,
nach folgendem Bauplan:

. Wählen Sie mehrere Ping-Ziele im Internet, die normalerweise erreichbar sein sollten, und notieren Sie deren IP-Adressen.
. Legen Sie in WATO _einen_ Host, etwa mit dem Namen `internet`, an.
. Tragen Sie eine der IP-Adressen bei diesem Host als IPv4-Adresse ein.
. Tragen Sie die weiteren Adressen bei demselben Host unter der Option [.guihint]#Network address => Additional IPv4 addresses# ein.
. Setzen Sie ferner [.guihint]#Data sources => Check_MK Agent# auf [.guihint]#No agent.#
. Legen Sie eine Regel unter [.guihint]#Active checks (HTTP, TCP, etc.) => Check hosts with PING (ICMP Echo Request)# an, die nur für diesen Host greift.
. Aktivieren Sie in dieser Regel die Option [.guihint]#Service description# und tragen Sie in das Feld als Service-Namen `Internet connection` ein.
. Aktivieren Sie außerdem die Option [.guihint]#Alternative address to ping# und wählen Sie dort [.guihint]#Ping all IPv4 addresses# aus.
. Aktivieren Sie [.guihint]#Number of positive responses required for OK state# und tragen Sie `1` ein.
. Legen Sie eine weitere Regel an -- diesmal unter [.guihint]#Monitoring Configuration => Host check command#, die ebenfalls nur für den Host `internet` gilt.
. Wählen Sie dort im Feld [.guihint]#Host check command# die Option [.guihint]#Use the status of a service...# und tragen Sie den Service-Namen `Internet connection` ein, den Sie im 7. Schritt definiert haben.

Wenn Sie jetzt die Änderungen aktivieren, erhalten Sie einen neuen Host
mit dem Namen `internet` und dem einzigen Service `Internet
connection`. Wenn mindestens eines der Ping-Ziele erreichbar ist,
hat der Host den Status {UP} und der Service den Status {OK}. Gleichzeitig
erhalten Sie bei dem Service für jedes der Ping-Ziele Messdaten für die
typische Round-Trip-Zeit sowie den Paketverlust und bekommen so auch einen
Anhaltspunkt für die Qualität Ihrer Verbindung im Laufe der Zeit:

image::service_internet.png[]

Die Schritte 10 und 11 sind notwendig, damit der Host nicht den Zustand {DOWN} bekommt, falls
die erste IP-Adresse nicht per `ping` erreichbar ist. Stattdessen übernimt der Host als Zustand immer
den Status seines einzigen Services.

*Wichtig:* Da ein Service grundsätzlich nicht alarmiert wird, wenn dessen Host {DOWN} ist, ist es
wichtig, dass Sie die Alarmierung über den Host machen -- nicht über den Service. Außerdem sollten
Sie einen Alarmierungsweg verwenden, der keine Internetverbindung voraussetzt!


=== Überwachen von HTTP/HTTPS-Diensten

Nehmen wir an, Sie wollen die Erreichbarkeit einer Website oder eines Webdienstes prüfen. Der normale
{CMK}-Agent bietet hier keine Lösung, da er diese Information nicht anzeigt -- und außerdem haben Sie
vielleicht gar nicht die Möglichkeit, den Agenten auf dem Server zu installieren.

Die Lösung ist ein sogenannter _aktiver Check_. Das ist einer, der nicht per Agent durchgeführt
wird, sondern direkt durch das Kontaktieren eines Netzwerkprotokolls beim Zielhost -- in diesem
Fall HTTP(S). Das Vorgehen ist wie folgt:

. Legen Sie den Zielserver als Host in WATO an. Nehmen wir an, er heißt `tribe29.com`.
. Wählen Sie bei [.guihint]#Data sources => Check_MK Agent# die Einstellung [.guihint]#No agent# und speichern Sie ohne Serviceerkennung.
. Legen Sie jetzt eine Regel im Regelsatz [.guihint]#Active Checks (HTTP, TCP, etc.) => Check HTTP service# an, die für diesen Host greift (z.B. mit [.guihint]#Explicit hosts# oder einem passenden Host-Tag).
. Im Kasten [.guihint]#Check HTTP service# finden Sie zahlreiche Optionen, wie der Check durchgeführt werden soll. Mehr dazu gleich im Anschluss.
. Speichern Sie die Regel und aktivieren Sie die Änderungen. Sie bekommen jetzt einen neuen Host mit einem Service, der einen Zugriff per HTTP(S) prüft.

Bei den Optionen der Regel gibt es Folgendes zu beachten:

* Eventell müssen Sie bei [.guihint]#Virtual host# die Domäne des Servers angeben, wenn dieser mehr als eine Domäne hostet.
* Die Option [.guihint]#Use SSL/HTTPS for the connection# ermöglicht die Überwachung von HTTPS.
* Bei [.guihint]#Expected response time# können Sie den Service auf {WARN} oder sogar {CRIT} setzen lassen, wenn die Antwortzeit zu schlecht ist.
* Die Option [.guihint]#Fixed string to expect in the content# erlaubt das Prüfen, ob in der Antwort -- also in der gelieferten Seite -- ein bestimmter Text vorkommt. Damit sollten Sie immer einen relevanten Teil des Inhalts prüfen, damit nicht eine simple Fehlermeldung des Servers auch als positive Antwort gewertet wird.

Übrigens können Sie den HTTP-Check natürlich auch auf einem Host durchführen, der
bereits normal mit {CMK} per Agent überwacht wird. In diesem Fall entfällt
das Anlegen des Hosts und Sie benötigen einfach nur die passende Regel.

image::http_service.png[]

[#magicfactor]
=== Intelligente Schwellwerte für Dateisysteme

Gute Schwellwerte für die Überwachung von Dateisystemen zu finden, kann
etwas mühsam sein und viele Regeln erfordern. Denn eine Schwelle von 90{nbsp}%
ist bei einer sehr großen Platte viel zu niedrig und bei einer kleinen
vielleicht schon zu knapp. Neben der im Kapitel über das Tuning erwähnten
Methode, Schwellen in Abhängigkeit von der Plattengröße zu definieren, gibt es aber noch
etwas Praktischeres: den _Magic factor._ Das funktioniert so:

. Im Regelsatz [.guihint]#Filesystems (used space and growth)# legen Sie nur einzige Regel an, und zwar mit den Schwellwerten 80{nbsp}% bzw. 90{nbsp}%.
. In derselben Regel aktivieren Sie die Option [.guihint]#Magic factor (automatic level adaptation for large filesystems)# und tragen `0.8` ein.
. Aktivieren Sie ferner [.guihint]#Reference size for magic factor# und tragen Sie als Größe 100{nbsp}GByte ein.

Wenn Sie jetzt das Ganze aktivieren, erhalten Sie Schwellwerte, die automatisch von der Größe des Dateisystems abhängen:

. Dateisysteme, die genau 100{nbsp}GByte groß sind, erhalten die Schwellwerte 80{nbsp}%/90{nbsp}%.
. Dateisysteme, die _größer_ als 100{nbsp}GByte sind, erhalten _höhere_ Schwellwerte, also solche, die näher an 100{nbsp}% sind.
. Dateisysteme, die _kleiner_ als 100{nbsp}GByte sind, erhalten _niedrigere_ Schwellwerte, also solche, die unter 80{nbsp}%/90{nbsp}% sind.

Wie hoch die Schwellwerte genau sind ist -- nun ja -- magisch! Über den Faktor (hier 0.8) bestimmen Sie, wie stark die
Werte verbogen werden. Ein Faktor von 1.0 ändert gar nichts, und alle Platten bekommen die gleichen Werte. Kleinere Werte
verbiegen die Schwellwerte stärker. Welche Schwellen genau gelten, können Sie bei jedem Service einfach in seinem
Statustext sehen:

image::magic_factor_services.png[]

Folgende Tabelle zeigt einige Beispiele für die sich ergebenden Schwellwerte bei einer Referenzgröße von 100{nbsp}GByte:

[cols="17,~,~,~,~,~,~"]
|===
|Plattengröße |mf = 1.0 |mf = 0.9 |mf = 0.8 |mf = 0.7 |mf = 0.6 |mf = 0.5 

|800{nbsp}GByte |80{nbsp}% |84{nbsp}% |87{nbsp}% |89{nbsp}% |91{nbsp}% |93{nbsp}%
|300{nbsp}GByte |80{nbsp}% |82{nbsp}% |84{nbsp}% |86{nbsp}% |87{nbsp}% |88{nbsp}%
|100{nbsp}GByte |80{nbsp}% |80{nbsp}% |80{nbsp}% |80{nbsp}% |80{nbsp}% |80{nbsp}%
|50{nbsp}GByte |80{nbsp}% |82{nbsp}% |83{nbsp}% |85{nbsp}% |86{nbsp}% |87{nbsp}%
|5{nbsp}GByte |80{nbsp}% |73{nbsp}% |64{nbsp}% |51{nbsp}% |50{nbsp}% |50{nbsp}%
|===

