= Messwerte und Graphing
:revdate: 2016-02-20
[.seealso][#user_interface] [#views] [#dashboards]MT:Messwerte in (CMK) schnell und einfach auswerten
MD:Checkmk bietet viele umfangreiche Metriken darzustellen, zu kombinieren und zu exportieren. Wichtiges Hintergrundwissen finden Sie am Ende des Artikels.

== Einleitung

image::bilder/example_graph.png[]

Nebem dem eigentlichen Sys&shy;tem-Monitoring -- näm&shy;lich der Erkennung von Problemen --
ist (CMK) ein ausgezeichnetes Werk&shy;zeug zur Auf&shy;zeich&shy;nung und
Analyse von unter&shy;schied&shy;lichsten Mess&shy;daten, welche in IT-Um&shy;ge&shy;bungen so anfallen können.
Da&shy;zu gehören zum Bei&shy;spiel:

* Betriebssystemperformance (Platten-IO, CPU- und Speicherauslastung,&nbsp;&#8230;)
* Netzwerkgrößen (genutzte Bandbreite, Paketlaufzeiten, Fehlerraten,&nbsp;&#8230;)
* Umgebungssensoren (Temperatur, Luftfeuchte, Luftdruck,&nbsp;&#8230;)
* Nutzungsstatistiken (eingeloggte User, Seitenabrufe, Sessions,&nbsp;&#8230;)
* Qualitätskennzahlen von Anwendungen (z.B. Antwortzeiten von Webseiten)
* Stromverbrauch und -qualität im RZ (Ströme, Spannungen, Leistungen, Batteriegüte,&nbsp;&#8230;)
* Anwendungsspezifische Daten (z.B. Länge von Mailqueues von MS Exchange)
* _Und vieles mehr&nbsp;&#8230;_

(CMK) zeichnet grundsätzlich alle beim Monitoring anfallenden Messgrößen
über einen Zeitraum von (einstellbar) vier Jahren auf, so dass Sie nicht
nur auf die aktuellen, sondern auch auf historische Messwerte zugreifen
können. Um den Verbrauch an Plattenplatz in Grenzen zu halten, werden die
Daten mit zunehmendem Alter immer weiter verdichtet.  Die Messwerte selbst
werden von den einzelnen Check-Plugins ermittelt. Sie legen somit auch fest,
welche Metriken genau bereitgestellt werden.

== Zugriff über die GUI

Die Messwerte eines Services werden in der GUI in drei verschiedenen Formen
präsentiert. Die sogenannten *Perf-O-Meter* tauchen direkt in der Tabelle
der Hosts oder Services auf und bieten einen schnellen Überblick und einen
optischen Vergleich. Allerdings beschränken sich diese aus Platzgründen
meist auf eine einzelne ausgewählte Metrik. Bei den Dateisystemen ist dies
z.B. der prozentual belegte Platz:

image::bilder/perfometer_filesystems.png[align=border]

Alle Metriken eines Services im *Zeitverlauf* erhalten Sie,
wenn Sie mit der Maus über das ICON[icon_pnp.png] Graphen-Icon fahren oder
draufklicken. Die gleichen Graphen finden Sie zudem auch ganz einfach in
den Details zu einem Host oder Service:

image::bilder/graph_used_cpu_time.png[]

In den Host-/Servicedetails gibt es zudem eine *Tabelle mit den aktuellen präzisen Messwerten*
für alle Metriken:

image::bilder/metrics_table.png[]


Wie genau die Zeitverläufe visualisiert werden, hängt von Ihrer (CMK)-Edition
ab:

== Das Graphing in den (EE)

[CEE] Die (CEE) enthalten eine eigenständige
komlett neu entwickelte Oberfläche für die Visualisierung der historischen
Messdaten, welche auf interaktivem HTML5 basiert. Außerdem gibt es eine
native Darstellung in PDF -- und zwar direkt als Vektorgraphik im PDF-Format
und damit ohne sichtbare Pixel im Ausdruck.

=== Interaktion mit dem Graphen

Sie können die Darstellung des Graphen auf verschiedene Arten interaktiv
beeinflussen:

* Durch Pannen (mit links klicken und festhalten, dann ziehen) verschieben Sie den Zeitbereich (links/rechts) oder skalieren vertikal (hoch/runter).
* Mit dem Mausrädchen Zoomen Sie in der Zeit rein und raus.
* Durch Ziehen an der rechten unter Ecke verändern Sie die Größe des Graphen.
* Ein Klick an eine Stelle im Graphen setzt eine _Stecknadel_ (den [.guihints]#Pin}}).# Damit erfahren Sie die genaue zeitliche Lage eines Punkts und alle präzisen Messwerte zu diesem Zeitpunkt. Der exakte Zeitpunkt des Pins wird pro Benutzer gespeichert und in allen Graphen angezeigt:

image::bilder/graphing_pin.png[]

Wenn sich auf einer Seite mehrere Graphen befinden, so folgen auch alle anderen Graphen der
Seite den gemachten Änderungen am gewählten Zeitbereich und der Stecknadel. Somit sind die
Werte immer vergleichbar. Auch eine Größenänderung wirkt sich auf alle Graphen
aus. Der Abgleich geschieht allerdings erst beim nächsten Neuladen der Seite (sonst
würde zeitweise in ziemliches Chaos auf dem Bildschirm entstehen&nbsp;&#8230;).

Sobald Sie die interaktiven Funktionen nutzen, also beispielsweise einen
Pin setzen, erscheint auf dem Bildschirm ein großes Pause-Symbol und die
Seitenaktualisierung setzt für 60 Sekunden aus. So wird Ihre Änderung im
Graphen nicht sofort durch die Aktualisierung wieder rückgängig gemacht. Der
Countdown wird immer wieder auf 60 Sekunden zurückgesetzt, wenn Sie erneut
aktiv werden. Sie können den Countdown aber auch komplett abgeschalten,
wenn Sie auf die Zahl klicken. Über das Pause-Symbol können Sie Pause
in jedem Fall direkt wieder beenden.

image::bilder/graphing_pause.png[]

[#graph_collections]
== Graphensammlungen (Graph Collections)

Mit dem ICON[icon_menu.png] Menüsymbol können Sie den Graphen an
verschiedenen Stellen einbetten, z.B. in Berichte oder Dashboards. Sehr
nützlich sind dabei die [.guihints]#Graph Collections}}.# In so eine Graphensammlung
können Sie beliebig viele Graphen packen und diese dann später vergleichen
oder auch als PDF exportieren.  Per Standard hat jeder Benutzer eine
Graphsammlung mit dem Namen [.guihints]#My Graphs}}.# Sie können aber sehr einfach
weitere anlegen und diese sogar für andere Benutzer sichtbar machen.
Das Vorgehen ist dabei exakt das Gleiche wie bei den [views|Ansichten].

Sie gelangen zu Ihren Graphsammlungen über [.guihints]#Views => Metrics => My Graphs# in der
Seitenleiste. Der Eintrag [.guihints]#My Graphs# taucht erste auf, wenn Sie auch
tatsächlich mindestens einen Graphen hinzugefügt haben.

image::bilder/snapin_graph_collections.png[align=center,width=200]

Der Knopf ICON[button_graph_collections.png] bringt Sie zur Tabelle all Ihrer
Graphensammlungen mit der Möglichkeit, weitere anzulegen, zu ändern usw.


[#custom_graphs]
== Freiformgraphen (Custom Graphs)

Die (CEE) bieten einen grafischen Editor, mit dem Sie komplett eigene
Graphen mit eigenen Berechungsformeln erstellen können. Damit ist es
auch möglich, Metriken *von verschiedenen Hosts und Services in einem
Graphen* zu kombinieren.  Zu den Freiformgraphen gelangen Sie z.B. über
[.guihints]#Views => EDIT# und dann mit dem Knopf ICON[button_custom_graphs.png].

Ein anderer Weg geht über die Metrik-Tabelle bei einem Service. Dort gibt es
bei jeder Metrik ein ICON[icon_custom_graph.png] Symbol, mit der Sie diese
Metrik zu einem Freiformgraphen hinzufügen können:

image::bilder/metrics_table.png[]

Folgende Abbildung zeigt die Liste der Freiformgraphen (hier mit nur
einem Eintrag):

image::bilder/custom_graph_list.png[align=border]

Bei jedem vorhandenen Graphen haben Sie vier mögliche Operationen:

[cols=, ]
|===
<td width="5%">ICON[icon_new_custom_graph.png]</td><td>Erzeugt eine Kopie dieses Graphen.</td><td>ICON[icon_delete.png]</td><td>Löscht den Graphen.</td><td>ICON[icon_edit.png]</td><td>Öffnet die *allgemeinen Eigenschaften* dieses
Graphen. Hier können Sie nebem dem Titel auch Einstellungen zur Sichtbarkeit für
andere Benutzer festlegen. Alles verhält sich exakt wie bei den [views|Ansichten]. Bitte denken
Sie an die ICON[icon_help.png] Onlinehilfe, wenn Sie Fragen zu einer der Einstellungen haben.</tr>
<td>ICON[icon_custom_graph.png]</td><td>Hier gelangen Sie zum eigentlichen Graphdesigner,
 mit dem Sie die Inhalte verändern können.</tr>
|===

Beachten Sie, dass jeder Freiformgraph -- analog zu den Ansichten -- eine
eindeutige ID hat.  Über diese wird der Graph in Berichten und Dashboards
angesprochen. Wenn Sie die ID eines Graphen später ändern, gehen dadurch
solche Referenzen verloren.  Alle Graphen, die nicht [.guihints]#hidden# sind, werden
in Ihrer Seitenleiste unter [.guihints]#Views => Metrics# angezeigt.

=== Der Graphdesigner

image::bilder/custom_graphs.png[align=border]

Der Graphdesigner ist in vier Bereiche unterteilt:

=== Vorschau des Graphen
Hier sehen Sie den Graphen exakt so, wie er auch später zu sehen sein wird. Sie können alle
interaktiven Funktionen nutzen.


=== Liste der Metriken

Die im Graphen enthaltenen Kurven, welche hier direkt editiert werden
können. Eine Änderung des Titels einer Kurve in diesem Feld bestätigen
Sie mit der Enter-Taste. Der [.guihints]#Style# legt fest, wie der Wert im Graphen
optisch gezeichnet wird. Dabei gibt es folgende Möglichkeiten:

[cols=, ]
|===
<td>{{Line}}</td><td>Der Wert wird als Linie eingezeichnet.</td><td>{{Area}}</td><td>Der Wert wird als Fläche eingezeichnet. Beachten Sie, dass die Kurven, die weiter oben in der Liste stehen,
Vorrang vor späteren haben und diese dabei überdecken können. Wenn Sie Linien und Flächen kombinieren möchten, sollten die Flächen immer unten stehen.</tr>
<td>{{Stacked Area}}</td><td>Alle Kurven dieses Stils werden als Flächen gezeichnet und vom Wert her aufeinander gestapelt (also quasi addiert).
Die obere Grenze dieses Stapels symbolisiert also die Summe aller beteiligten Kurven.</tr>
|===

Die weiteren drei Möglichkeiten [.guihints]#Mirrored Line}},# [.guihints]#Mirrored Area# und [.guihints]#Mirrored Stacked# funktionieren analog, nur dass
die Kurven von der Nulllinie aus nach unten gezeichnet werden. Das ermöglicht eine Art von Graph, wie sie (CMK)
generell für Input/Output-Graphen wie den folgenden verwendet:

image::bilder/graph_input_output.png[]

In der letzten Spalte der Metriktabelle können Sie bestehende Metriken
editieren. Das ermöglicht z.B., eine Kurve zu ICON[button_clone.png]
klonen und dann einfach den Hostnamen auszutauschen. Die Bedeutung der
einzelnen Felder wird im nächsten Abschnitt erlärt.

[#adding_metrics]
=== Formular zum Hinzufügen einer Metrik

Über das Formular [.guihints]#Metrics# können Sie neue Metriken zum Graphen
hinzufügen. Sobald Sie in das erste Feld einen gültigen Hostnamen
eingeben, wird das zweite Feld mit der Liste der Services des Hosts
gefüllt. Eine Auswahl in dieser Liste füllt das dritte Feld mit der Liste
der Metriken dieses Services. Im vierten und letzten Feld wählen Sie die
*Konsolidierungsfunktion*.  Zur Auswahl stehen [.guihints]#Minimum}},# [.guihints]#Maximum}}# 
und [.guihints]#Average}}.# Diese Funktionen kommen immer dann zur Anwendung, wenn
die Speicherung der Daten in den RRDs für den gewählten Zeitraum bereits
verdichtet ist. In einem Bereich, wo z.B. nur noch ein Wert pro halber
Stunde zur Verfügung steht, können Sie so wählen, ob Sie den größten,
kleinsten oder durchschnittlichen Originalmesswert dieses Zeitraums
einzeichnen möchten.

image::bilder/graphing_metrics.png[]

Auf die gleiche Art blenden Sie über die Funktion [.guihints]#Scalar}}# 
die Werte eines Service für (WARN), (CRIT), Maximum und Minimum
als waagerechte Linie ein.

image::bilder/graphing_scalar.png[]

Sie können dem Graphen auch eine *Konstante* hinzufügen. Diese wird
dann zunächst als waagerechte Linie angezeigt. Konstanten sind manchmal
nötig zur Bildung von Berechnungsformeln. Dazu später mehr.

=== Graphoptionen

Hier finden Sie Optionen, die den Graphen als Ganzes betreffen. Die Einheit
[.guihints]#Unit# beeinflusst die Beschriftung der Achsen und der Legende. Sie wird
automatisch eingestellt, sobald die erste Metrik hinzugefügt wird. Beachten
Sie, dass es zwar möglich, aber nicht sehr sinnvoll ist, zwei Metriken mit
unterschiedlichen Einheiten in einem Graphen unterzubringen.

Unter [.guihints]#Explicit vertical range# können Sie den vertikalen Bereich des
Graphen voreinstellen. Normalerweise wird die Y-Achse so skaliert, dass alle
Messwerte im gewählten Zeitraum genau in den Graphen passen. Wenn Sie einen
Graphen für z.B. einen Prozentwert entwerfen, könnten Sie sich aber auch
entscheiden, dass immer von 0 bis 100 dargestellt wird. Beachten Sie dabei,
dass der Graph vom Benutzer (und auch Ihnen selbst) trotzdem mit der Maus
skaliert werden kann und die Einstellung dann wirkungslos wird.

[#calculation]
=== Rechnen mit Formeln

Der Graphdesigner ermöglicht es Ihnen, die einzelnen Kurven durch Rechenoperationen
zu kombinieren. Folgendes Beispiel zeigt einen Graphen mit zwei Kurven: CPU utilization
[.guihints]#User# und [.guihints]#System}}.# 

image::bilder/graphdesigner_ops_1.png[align=border]

Nehmen wir an, dass Sie für diesen Graphen nur die Summe von beiden interessiert.
Dazu wählen Sie zunächst die beiden Kurven durch Ankreuzen ihrer Checkboxen aus.
Sobald Sie das tun, erscheint im Kasten [.guihints]#Metrics# eine neue Zeile [.guihints]#Operation on selected metrics# mit einer Reihe von Knöpfen:

image::bilder/graphdesigner_ops_2.png[]

Ein Klick auf [.guihints]#Sum# kombiniert die beiden gewählten Kurven zu einer neuen
Kurve. Als Farbe wird automatisch die Mischung aus den Einzelfarben gewählt.
Der Titel der neuen Kurve wird zu [.guihints]#Sum of User, System}}.# Die Berechnungsformel
wird in der Spalte [.guihints]#Formula# angezeigt. Außerdem taucht ein neues
ICON[button_dissolve_operation.png] Symbol auf:

image::bilder/graphdesigner_ops_3.png[]

Durch einen Klick auf ICON[button_dissolve_operation.png] machen Sie die Operation
quasi rückgängig, in dem Sie die Formel wieder auflösen und die einzelnen
enthaltenen Kurven wieder zum Vorschein kommen. Weitere Hinweise zu den Rechenoperationen:

* Manchmal ist es sinnvoll, Konstanten hinzuzufügen, um z.B. den Wert einer Kurve von der Zahl 100 abzuzuiehen.
*  Scalare können ebenfalls für Berechnungen genutzt werden.
* Sie können die Operation können beliebig verschachteln.

== Die Graphingoberfläche von PNP4Nagios

[CRE] In der (CRE) bildet das Graphingsystem
<a href="http://www.pnp4nagios.org">PNP4Nagios von Jörg
Linge</a> die Grundlage für die Erfassung und Visualisierung von Messdaten. Dieses ist in der Sprache PHP geschrieben und ein
eigenständiges Projekt, welches auch ohne (CMK) verfügbar und vor
allem bei Benutzern von klassichen Nagios-basierten Monitoringsystemen beliebt
ist. PNP4Nagios ist über einen Frame in die (CMK)-Oberfläche
eingebunden sowie von der Farbgebung her eigens an (CMK) angepasst:

image::bilder/graphingpnp.png[]

=== Zeitraum auswählen

Um den dargestellten Zeitraum auszuwählen, haben Sie verschiedene Möglichkeiten:

* Direkt im Graphen können Sie mit der Maus einen Bereich auswählen.
* Die ICON[pnp_zoom.png] Lupe öffnet einen Dialog mit Knöpfen zum Blättern und Zoomen.
* Der ICON[pnp_calendar.png] Kalender ermöglicht die Eingabe von Datum und Uhrzeit.
* Im Kasten [.guihints]#Timeranges# können Sie einen von fünf Standardzeiträumen wählen (z.B. [.guihints]#One Month}}).# 

=== Das Basket

In Ihrem [.guihints]#Basket# können Sie mit dem Icon ICON[pnp_add.png] mehrere Graphen
"einsammeln", um diese dann später über [.guihints]#My basket# gleichzeitig anzusehen. So
können Sie auch Graphen von verschiedenen Hosts auf einmal ansehen und diese
leichter vergleichen.

=== PDF-Export

Der Knopf ICON[pnp_pdf.png] startet einen einfachen Export der aktuellen Ansicht
als PDF.


[#graphing_api]
== Graphite, Grafana und InfluxDB

[CEE] Wenn Sie eine der (CEE) einsetzen, so können Sie parallel zum in
(CMK) eingebauten Graphing auch externe Metrik-Datenbanken anbinden. Der
(CMK) Micro Core kann alle Messdaten zusätzlich an eine (ab Version
VERSION[1.2.8] sogar mehrere) Datenbank weiterleiten, die das
Protokoll von <a href="http://graphite.wikidot.com/">Graphite</a>
unterstützt. Neben Graphite selbst hat z.B. die
<a href="https://influxdata.com/">InfluxDB</a> eine derartige Schnittstelle.

Die Anbindung konfigurieren Sie in den [.guihints]#Global Settings# unter
[.guihints]#Send metrics to Graphite / InfluxDB}}:# 

image::bilder/graphite.png[]

Neben den offensichtlichen Angaben zum Netzwerk können Sie hier optional einen
Präfix konfigurieren, der jedem Hostnamen vorangestellt wird, um z.B. eindeutige
Namen zu erzwingen. Als Namensschema für den Export der Metriken wird HOST.SERVICE.METRIK
verwendet.

Sollte die Anbindung nicht funktionieren, so finden Sie Diagnoseinformationen
in der Datei `~/var/log/cmc.log` in ihrer Instanz. Folgendes Beispiel
zeigt die Meldungen im Fall, dass ein Connect zum Graphite-Server nicht klappt:

./omd/sites/mysite/var/log/cmc.log

----2016-02-24 16:30:48 [5] Successfully initiated connection to Carbon/Graphite at 10.0.0.5:2003.
2016-02-24 16:32:57 [4] Connection to Carbon/Graphite at 10.0.0.5:2003 failed: Connection timed out
2016-02-24 16:32:57 [5] Closing connection to Carbon/Graphite at 10.0.0.5:2003
----

Der Core versucht in so einer Situation von sich aus immer wieder, die
Verbindung aufzubauen. Messdaten, die während einer Zeit anfallen, zu der
keine Verbindung zu Graphite besteht, werden nicht zwischengespeichert,
sondern gehen verloren (bzw. sind dann nur in den RRD-Datenbanken von (CMK)
verfügbar).


[#rrds]
== Hintergründe, Tuning, Fehlerdiagnose

(CMK) speichert alle Messwerte in dafür eigens entwickelten Datenbanken,
sogennannten *RRDs* (*Round Robin Datenbanken*). Dabei kommt das
<a href="http://www.rrdtool.org">RRDTool von Tobi Oetiker</a> zum
Einsatz, welches in Open-Source-Projekten sehr beliebt und weit verbreitet ist.

Die RRDs bieten gegenüber klassischen SQL-Datenbanken bei der Speicherung
von Messwerten wichtige Vorteile:

* RRDs speichern die Messdaten sehr kompakt und effizient.
* Der Platzverbrauch auf der Platte pro Metrik ist statisch. RRDs können weder wachsen noch schrumpfen. Der benötigte Plattenplatz kann gut geplant werden.
* Die benötigte CPU- und Disk-Zeit pro Update ist immer gleich. RRDs sind (nahezu) echtzeitfähig, da es nicht zu Staus aufgrund von Reorganisationen kommen kann.

=== Organisation der Daten in den RRDs

(CMK) ist so voreingestellt, dass der Verlauf jeder Metrik über einen
Zeitraum von *vier Jahren* aufgezeichnet wird.  Die Grundauflösung ist
dabei eine Minute. Dies ist deswegen sinnvoll, weil das Check-Intervall auf
eine Minute voreingestellt ist und so von jedem Service genau einmal pro
Minute neue Messwerte kommen.

Nun kann sich allerdings jeder ausrechnen, dass die Speicherung von einem Wert
pro Minute über vier Jahre eine enorme Menge an Plattenplatz benötigen würde
(obwohl die RRDs pro Messwert nur genau 8 Byte benötigen). Aus diesem Grund
werden die Messdaten mit der Zeit *verdichtet*. Die erste Verdichtung
findet nach 48 Stunden statt. Ab diesem Zeitpunkt wird nur noch ein Wert pro
fünf Minuten aufbewahrt.  Die übrigen Stufen sind nach 10 Tagen und 90 Tagen:

[cols=, ]
|===
<th>Phase</th><th>Dauer</th><th>Auflösung</th><th>Messpunkte</th><td>1</td><td>2 Tage</td><td>1 Minute</td><td>2880</td><td>2</td><td>10 Tage</td><td>5 Minuten</td><td>2880</td><td>3</td><td>90 Tage</td><td>30 Minuten</td><td>4320</td><td>4</td><td>4 Jahre</td><td>6 Stunden</td><td>5840</td>|===

Jetzt stellt sich natürlich die Frage, wie denn nun fünf Werte sinnvoll zu
einem einzigen konsolidiert werden sollen.
Als *Konsolidierungsfunktionen* bieten sich z.B. das *Maximum*,
das *Minimum* oder der *Durchschnitt* an.
Was in der Praxis
sinnvoll ist, hängt von der Anwendung oder Betrachtungsweise ab. Möchten Sie
z.B. den Temperaturverlauf in einem Rechenzentrum über vier Jahre beobachten,
wird Sie wahrscheinlich eher die maximale Temperatur interessieren, die je
erreicht wurde. Bei der Messung von Zugriffszahlen auf eine Anwendung könnte
der Durchschnitt interessieren.

Um maximal flexibel bei der späteren Auswertung zu sein, sind die RRDs von
(CMK) so voreingestellt, dass sie einfach jeweils *alle drei* Werte
speichern -- also Minimum, Maximum _und_ Durchschnitt.
Pro Verdichtungsstufe und Konsolidierungsfunktion enthält die RRD
einen ringförmigen Speicher -- ein sogenanntes RRA (Round Robin Archive).
Im Standardaufbau gibt es also insgesamt 12 RRAs.   So
benötigt das Standardschema von (CMK) genau 384.952 Byte pro Metrik.
Das ergibt sich aus 2880 + 2880 + 4320 + 5840 Messpunkten mal drei
Konsolidierungsfunktionen mal acht Byte pro Messwert, was genau 382.080 Byte
ergibt. Dazu kommt ein Dateiheader von 2872 Byte.

Ein interessantes alternatives Schema wäre z.B. das Speichern von einem Wert
pro Minute für ein komplettes Jahr. Dabei kann man einen kleinen Vorteil
ausnutzen: Da die RRDs dann zu allen Zeiten die optimale Auflösung haben,
können Sie auf die Konsolidierung verzichten und z.B. nur noch _Average_
anlegen. So kommen Sie auf 365 x 24 x 60 Messpunkte zu je 8 Byte, was
ziemlich genau 4 MB pro Metrik ergibt. Auch wenn die RRDs somit mehr als
den zehnfachen Platz benötigen, ist die nötige *Disk-IO* sogar reduziert!
Der Grund: Ein Update muss nicht mehr in 12 verschiedene RRAs geschrieben
werden, sondern nur noch in eines.

=== Anpassen des RRD-Aufbaus

[CEE] Wenn Ihnen das voreingestellte Speicherschema nicht zusagt, so können Sie
dieses über [wato_rules|Konfigurationsregeln] ändern (sogar pro Host oder Service
unterschiedlich). Den nötigen Regelsatz finden Sie
am einfachsten über die Regelsuche -- also [.guihints]#WATO => Host & Service Parameters => Searchfor rules sets}}.# 
Und dort geben Sie einfach [.guihints]#RRD# ein. So finden Sie die Regel
[.guihints]#Configuration of RRD databases of services}}.# Es gibt auch eine analoge Regel
für Hosts, aber Hosts haben nur in Ausnahmefällen Messwerte. Folgendes Bild
zeigt die Regel mit den Defaulteinstellungen (diese wird ab Version VERSION[1.2.8]
beim Einrichten einer neuen Instanz automatisch angelegt):

image::bilder/rrd_configuration.png[]

In den Abschnitten [.guihints]#Consolidation Functions# und [.guihints]#RRA Configuration}}# 
können Sie die Anzahl und Größe der Verdichtungsphasen bestimmen und
festlegen, welche Konsolidierungen bereit gehalten werden sollen. Das Feld
[.guihints]#Step# bestimmt die Auflösung in Sekunden, in der Regel 60 (eine
Minute). Für Services mit einem Check-Interval von kleiner als einer Minute
kann es sinnvoll sein, diese Zahl kleiner einzustellen. Beachten Sie dabei,
dass die Angaben im Feld [.guihints]#Number of steps aggregated into one data point}}# 
dann nicht mehr Minuten bedeuten, sondern die in [.guihints]#Step# eingestellte
Zeitspanne.

[CEE] Jede Änderung des RRD-Aufbaus hat zunächst nur Einfluss auf *neu
angelegte* RRDs -- sprich wenn Sie neue Hosts oder Services in das Monitoring
aufnehmen.  Sie können aber die bestehenden RRDs von (CMK) umbauen lassen.
Dazu dient der Befehl `cmk --convert-rrds`, bei welchem sich immer
die Option `-v` (verbose) anbietet. (CMK) kontrolliert dann
alle vorhandenen RRDs und baut diese nach Bedarf in das eingestellte
Zielformat um:

[source,bash]
----
OM:cmk -v --convert-rrds
myserver012:
  Uptime (CMC).....converted, 376 KB -> 159 KB
  Filesystem / (CMC).....converted, 1873 KB -> 792 KB
  OMD slave apache (CMC).....converted, 14599 KB -> 6171 KB
  Memory (CMC).....converted, 14225 KB -> 6012 KB
  Filesystem /home/mk (CMC).....converted, 1873 KB -> 792 KB
  Interface 2 (CMC).....converted, 4119 KB -> 1741 KB
  CPU load (CMC).....converted, 1125 KB -> 475 KB
----

Der Befehl ist intelligent genug, um RRDs zu erkennen, die bereits den
richtigen Aufbau haben:
[source,bash]
----
OM:cmk -v --convert-rrds
myserver345:
  Uptime (CMC).....uptodate
  Filesystem / (CMC).....uptodate
  OMD slave apache (CMC).....uptodate
  Memory (CMC).....uptodate
  Filesystem /home/mk (CMC).....uptodate
  Interface 2 (CMC).....uptodate
  CPU load (CMC).....uptodate
----

Wenn das neue Format eine höhere Auflösung oder zusätzliche
Konsolidierungsfunktionen hat, werden die bestehenden Daten so gut es geht
interpoliert, so dass die RRDs mit möglichst sinnvollen Werten gefüllt
werden. Nur ist natürlich klar, dass wenn Sie z.B ab sofort nicht 2 sondern
5 Tage mit minutengenauen Werten haben möchten, die Genauigkeit der bestehenden
Daten nicht nachträglich erhöht werden kann.

[#rrdformat]
=== RRD-Speicherformat

[CEE] Die oben gezeigte Regel hat noch eine weitere Einstellung: [.guihints]#RRD storage format}}.# 
Mit dieser können Sie zwischen zwei Methoden
wählen, wie (CMK) die RRDs erzeugt. Diese Einstellung existiert ab Version
VERSION[1.2.8]. Hier wurde das neue Format [.guihints]#One RRD per host/service}}# 
(oder Kurz (CMK)-Format oder CMK-Format) einführt.
Dabei werden alle Metriken eines Hosts bzw. Services in eine einzige
RRD-Datei gepackt. Dies sorgt für ein effizienteres Schreiben der Daten, da so immer ein kompletter Satz an Metriken in einer einzigen
Operation geschrieben werden kann. Diese Metriken liegen dann in benachbarten
Speicherzellen, was die Anzahl der Plattenblöcke reduziert, die geschrieben
werden müssen.

Bitte beachten Sie, dass das Format [.guihints]#One RRD per host/service# nicht von
PNP4Nagios untetstützt wird. (CMK)-Instanzen die ab Version VERSION[1.2.8]
der (CEE) erzeugt werden, verwenden automatisch das neue Format. Bestehende Instanzen
aus früheren Versionen behalten das alte PNP-Format. Sie können diese über das Anlegen
einer Regel im oben gezeigten Regelsatz auf das (CMK)-Format umstellen.
 Auch hier benötigen Sie anschließend den Befehl `cmk --convert-rrds`:

[source,bash]
----
OM:cmk -v --convert-rrds
myhost123:
   Uptime PNP -> CMC..converted.
  WARNING: Dupliate RRDs for stable/Uptime. Use --delete-rrds for cleanup.
   OMD heute apache PNP -> CMC..converted.
  WARNING: Dupliate RRDs for stable/OMD heute apache. Use --delete-rrds for cleanup.
   fs_/home/mk PNP -> CMC..converted.
  WARNING: Dupliate RRDs for stable/fs_/home/mk. Use --delete-rrds for cleanup.
   OMD slave apache PNP -> CMC..converted.
  WARNING: Dupliate RRDs for stable/OMD slave apache. Use --delete-rrds for cleanup.
   Memory PNP -> CMC..converted.
...
----

Wie Sie an der Warnung sehen können, lässt (CMK) die bestehenden Dateien
im alten Format zunächst liegen. Dies ermöglicht Ihnen im Zweifel eine Rückkehr
zu diesem Format, weil ein Konvertieren in die Rückrichtung *nicht*
möglich ist. Die Option `--delete-rrds` sorgt dafür, dass diese Kopien
nicht erzeugt bzw. nachträglich gelöscht werden. Sie können das Löschen
bequem später mit einem weiteren Aufruf des Befehls machen:

[source,bash]
----
OM:cmk -v --convert-rrds --delete-rrds
----


[#rrdcached]
=== Der RRD-Cache-Daemon (rrdcached)

Um die Anzahl der nötigen Schreibzugriffe auf die Platte (drastisch) zu reduzieren,
kommt ein Hilfsprozess zum Einsatz: der RRD-Cache-Daemon (rrdcached). Er ist einer
der Dienste, welche beim Start einer Instanz gestartet werden:

[source,bash]
----
OM:omd start
Starting mkeventd (builtin: syslog-udp)...OK
Starting Livestatus Proxy-Daemon...OK
Starting mknotifyd...OK
*Starting rrdcached...OK*
Starting Check_MK Micro Core...OK
Starting dedicated Apache for site stable...OK
Initializing Crontab...OK
----

Alle neuen Messwerte für die RRDs werden zunächst vom Kern ((EE)) bzw. von NPCD ((RE))
an den rrdcached gesendet. Dieser schreibt die Daten zunächst nicht in die RRDs, sondern
merkt sie sich im Hauptspeicher, um sie später dann gesammelt in die jeweilige RRD
zu schreiben. So wird die Anzahl der Schreibzugriffe auf die Platte (oder in das SAN!)
deutlich reduziert.

Damit im Falle eines Neustarts keine Daten verloren gehen, werden die Updates zusätzlich
in Journaldateien geschrieben. Dies bedeutet zwar auch Schreibzugriffe, aber da hier
die Daten direkt hintereinander liegen, wird dadurch kaum IO erzeugt.

Damit der RRD-Cache-Daemon effizient arbeiten kann, benötigt er natürlich
viel Hauptspeicher. Die benötigte Menge hängt von der Anzahl Ihrer RRDs ab
und davon, wie lange Daten gecachet werden sollen. Letzteres können Sie in der
Datei `etc/rrdcached.conf` einstellen. Die Standardeinstellung legt
eine Speicherung von 7200 Sekunden (zwei Stunden) plus eine Zufallsspanne
von 1800 Sekunden fest.  Diese zufällige Verzögerung pro RRD verhindert
ein pulsierendes Schreiben und sorgt für eine gleichmäßige Verteilung
der IO über die Zeit:

.

----# Data is written to disk every TIMEOUT seconds. If this option is
# not specified the default interval of 300 seconds will be used.
*TIMEOUT=3600*

# rrdcached will delay writing of each RRD for a random
# number of seconds in the range [0,delay).  This will avoid too many
# writes being queued simultaneously.  This value should be no
# greater than the value specified in TIMEOUT.
*RANDOM_DELAY=1800*

# Every FLUSH_TIMEOUT seconds the entire cache is searched for old values
# which are written to disk. This only concerns files to which
# updates have stopped, so setting this to a high value, such as
# 3600 seconds, is acceptable in most cases.
*FLUSH_TIMEOUT=7200*
----

Eine Änderung der Einstellungen in dieser Datei aktivieren Sie mit:

[source,bash]
----
OM:omd restart rrdcached
Stopping rrdcached...waiting for termination....OK
Starting rrdcached...OK
----

=== Verzeichnisse

Hier ist eine Übersicht über die wichtigsten Dateien und Verzeichnisse, die
mit Messdaten und RRDs zu tun haben (alle bezogen auf das Homeverzeichnis
der Instanz):

[cols=, ]
|===
<td class=tt>var/check_mk/rrd</td><td>RRDs im (CMK)-Format</td><td class=tt>var/pnp4nagios/perfdata</td><td>RRDs im alten Format (PNP)</td><td class=tt>var/rrdcached</td><td>Journaldateien des RRD-Cache-Daemons</td><td class=tt>var/log/rrdcached.log</td><td>Logdatei des RRD-Cache-Daemons</td><td class=tt>var/log/cmc.log</td><td>Logdatei des (CMK)-Kerns (Fehlermeldungen zu RRDs)</td><td class=tt>etc/pnp4nagios</td><td>Einstellungen für PNP4Nagios ((CRE))</td><td class=tt>etc/rrdcached.conf</td><td>Einstellungen für den RRD-Cache-Daemon</td>|===
