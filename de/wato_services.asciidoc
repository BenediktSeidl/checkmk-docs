= Services verstehen und konfigurieren
:revdate: 2018-07-05
[.seealso][#monitoring_basics] [# wato_hosts] [# wato_rules]:title: Elemente eines Hosts erkennen und überwachen
:description: Services bilden den Kern eines jeden überwachten Host. Diese werden automatisch erfasst und können umfangreich konfiguriert und strukturiert werden.

== Einleitung

Die Services sind das eigentliche Fleisch im Monitoringsystem. Jeder
Einzelne von ihnen repräsentiert ein wichtiges Rädchen ihn Ihrer komplexen
IT-Landschaft. Die Nutzen des ganzen Monitorings steht und fällt
damit, wie treffsicher und sinnvoll die Services konfiguriert sind.
Schließlich soll das Monitoring zuverlässig melden, wenn sich irgendwo ein
Problem abzeichnet, aber auf der anderen Seite falsche und nutzlose Alarme
unbedingt vermeiden.

image::bilder/services_illu.png[align=float,left]

Bei der Konfiguration der Services zeigt Checkmk seine vielleicht größte
Stärke: Es verfügt über ein einzigartiges und sehr mächtiges System für
eine _auto&shy;matische Erkennung und Konfiguration von Services._ Sie
müssen mit Checkmk nicht jeden einzelnen Service über Scha&shy;blonen
und Einzelzuweisungen definieren. Denn Checkmk kann die Liste der zu
überwachenden Services sehr zuverlässig automatisch ermitteln und vor allem auch
_aktuell halten._  Das spart nicht nur sehr viel Zeit -- es macht das
Monitoring auch _genauer._ Denn es stellt sicher, dass die täglichen
Änderungen im Rechenzentrum auch immer zeitnah im Monitoring abgedeckt werden
und kein wichtiger Dienst ohne Monitoring bleibt.

Die Serviceerkennung in Checkmk basiert auf einem wichtigen Grundprinzip:
der Trennung des _Was_ vom _Wie_:

* *Was* soll überwacht werden? → _Das Dateisystem `/var` auf dem Host `lnxsrv015`_
* *Wie* soll es überwacht werden? → _Bei 90% belegtem Platz (WARN), bei 95% (CRIT)_

Das _Was_ wird bei der Serviceerkennung automatisch ermittelt. Es
setzt sich aus dem *Hostnamen* (`lnxsrv015`), dem
[wato_services#checkplugins|*Check-Plugin*] (`df:` Dateisystemcheck
unter Linux) und dem *Item* (`/var`) zusammen.  Check-Plugins, die auf
einem Host maximal einen Service erzeugen können, benötigen kein Item
(z.B. das Check-Plugin für die CPU-Ausnutzung).  Das Ergebnis der Erkennung
ist eine Tabelle, die Sie sich so vorstellen können:

<table class=small>

<tr>
<th>Host</th>
<th>Check-Plugin</th>
<th>Item</th>
</tr>

<tr>
<td class=tt>lnxsrv015</td>
<td class=tt>df</td>
<td class=tt>/</td>
</tr>

<tr>
<td class=tt>lnxsrv015</td>
<td class=tt>df</td><td class=tt>/var</td></tr>
<tr><td class=tt>lnxsrv015</td><td class=tt>cpu.util</td>
<td class=tt></td>
</tr>

<tr>
<td class=tt>...</td>
<td class=tt>...</td>
<td class=tt>...</td>
</tr>

<tr>
<td class=tt>app01cz2</td>
<td class=tt>hr_fs</td>
<td class=tt>/</td>
</tr>

<tr>
<td class=tt>...</td>
<td class=tt>...</td>
<td class=tt>...</td>
</tr>

[cols=, ]
|===

Das _Wie_ -- also die Schwellwerte/Checkparameter für die
einzelnen Services -- wird unabhängig davon über [wato_rules|Regeln]
konfiguriert. Sie können z.B. eine Regel aufstellen, dass alle Dateisysteme mit
dem Mountpunkt `/var` mit den Schwellwerten 90%/95% überwacht werden,
ohne sich dabei Gedanken machen zu müssen, auf welchen Hosts denn nun
überhaupt so ein Dateisystem existiert. Das ist es, was die Konfiguration mit
(CMK) so einfach und übersichtlich macht!

Einige wenige Services können nicht über eine automatische Erkennung
eingerichtet werden. Dazu gehören z.B. Checks, die per HTTP bestimmte
Webseiten abrufen sollen.  Diese werden per Regeln angelegt; wie, erfahren Sie
[wato_services#active_checks|weiter unten].


[#discovery]
== Services eines Hosts in WATO

=== Host neu aufnehmen

Nachdem Sie einen neuen Host in WATO aufgenommen haben, ist der nächste
Schritt, die Liste der Services aufzurufen. Hierbei läuft bereits das erste Mal die Serviceerkennung
für den Host. Sie können diese Liste
auch jederzeit später wieder aufrufen, um die Erkennung neu zu starten
oder Anpas&shy;sungen an der Konfiguration vorzunehmen. Sie erreichen die Serviceliste
auf verschiedene Arten:

* über die Knöpfe ICON[button_save_and_services.png] und ICON[button_host_services.png] in den Details eines Hosts in WATO
* über das Symbol ICON[button_services.png] in der Liste der Hosts in einem Ordner in WATO
* über den Eintrag ICON[button_services.png] [.guihints]#Edit services# im Kontextmenü des Services [wato_services#discovery_check => {{Check_MKDiscovery}}]# eines Hosts


Wenn der Host gerade neu aufgenommen wurde, ist noch kein Service konfiguriert
und daher erscheinen alle gefundenen Services in der Rubrik
[.guihints]#Available (missing) services}}:# 

image::bilder/wato_available_services.jpg[]

Der übliche Weg ist nun einfach das Speichern mit ICON[button_save_manual.png]. Danach ein
[.guihints]#Activate changes# und schon ist der Host
im Monitoring.


[#available]
=== Fehlende Services hinzufügen

Bei einem Host, der bereits überwacht wird, sieht diese Liste anders aus. Anstelle
von [.guihints]#Missing (available) services# sehen Sie [.guihints]#Already configured services}}.# Sollte
(CMK) allerdings feststellen, dass es auf dem Host etwas gibt, das aktuell nicht
überwacht wird, aber überwacht werden _sollte,_ dann sieht das etwa so aus:

image::bilder/wato_services_missing.jpg[]

Obige Abbildung zeigt einen Windows-Host, auf dem ein Dateisystem `D:\`
gefunden wurde, welches aktuell nicht überwacht wird! Es könnte sein,
dass ein Kollege hier eine neue LUN eingerichtet hat. Ein Klick auf
ICON[button_activate_missing.png] fügt einfach alle fehlenden Services hinzu, so dass
die Überwachung wieder vollständig ist. Wenn Sie nur manche der fehlenden
Services aufnehmen möchten, können Sie diese alternativ über die Check&shy;boxen auswählen
und mit ICON[button_save_manual.png] speichern.


=== Verschwundene Services

Im Rechenzentrum können Dinge nicht nur neu auftauchen, sondern auch verschwinden.
Eine Datenbank&shy;instanz wird abgeschafft, eine LUN ausgehängt, ein Dateisystem entfernt
u.s.w. Checkmk er&shy;kennt solche Services dann automatisch als verschwunden _(vanished)._
In der Serviceliste sieht das z.B. so aus:

image::bilder/wato_vanished_services.jpg[]

Der einfachste Weg um diese Services loszuwerden ist ein Klick auf den in so einem Fall
erscheinenden Knopf ICON[button_remove_vanished.png]. *Achtung:* Der Grund für das Verschwinden
kann durchaus auch ein Problem sein! Das Verschwinden eines Dateisystems kann ja auch
bedeuten, dass dieses aufgrund eines Fehlers nicht gemounted werden konnte. Und für solche
Fälle ist das Monitoring schließlich da! Sie sollten den Service also nur dann entfernen,
wenn Sie wissen, dass hier eine Überwachung auch wirklich keinen Sinn mehr macht.


=== Ungewünschte Services loswerden

Nicht alles, was Checkmk findet, möchten Sie auch unbedingt überwachen. Zwar arbeitet
die Erkennung durchaus zielgerichtet und kann schon viel Unnützes im Vorfeld ausschließen.
Doch woher soll Checkmk z.B. wissen, dass eine bestimmte Datenbankinstanz nur
zum „Herumspielen“ eingerichtet wurde und nicht produktiv ist?
Sie können solche Services auf zwei Arten loswerden:

==== Vorübergehendes Abschalten von Services

Entfernen Sie einfach bei den Services, die nicht überwacht werden sollen,
die Häkchen in den Checkboxen und speichern Sie mit ICON[button_save_manual.png].
Und natürlich, wie immer [.guihints]#Activate changes# nicht vergessen&nbsp;&#8230;

Das Ganze ist allerdings nur für vorübergehende und kleinere Maßnahmen gedacht. Denn
die so abge&shy;wählten Services werden von Checkmk dann wieder als [.guihints]#missing# angemahnt.
Und der [wato_services#discovery_check|Discovery Check] (den wir Ihnen weiter unten zeigen)
wird ebenfalls nicht glücklich damit sein.
Außerdem ist das in einer Umgebung mit ein paar zigtausend Services einfach zu viel
Arbeit und nicht wirklich praktikabel&nbsp;&#8230;


[#disabled_services]
==== Permanentes Abschalten von Services

Viel eleganter und dauerhafter ist das permanente Ignorieren von Services mit Hilfe
des [wato_rules|Regelsatzes] [.guihints]#Disabled services}}.# Hier können Sie nicht nur einzelne
Services vom Monitoring ausschließen, sondern Regeln wie „Auf Testsystemen
möchte ich keine Dateisysteme überwachen, die mit `/mnt/dsk` be&shy;ginnen“ formulieren.
Das Symbol ICON[button_ignore.png] in der Serviceliste erleichtert das Neuanlegen
von solchen Regeln, so dass Sie nicht den längeren Weg über das WATO-Modul
ICON[icon_rulesets.png] [.guihints]#Host & Service parameters# gehen müssen:

image::bilder/disable_services_1.png[]

Das ICON[button_ignore.png] bringt Sie direkt zum Anlegen
einer neuen Regel, die für den aktuellen Ordner, Host und Service vorausgefüllt ist:

image::bilder/disable_services_2.jpg[]

Sie können diese Regel sehr leicht auf alle Hosts verallgemeinern: Entfernen Sie
einfach den Haken bei [.guihints]#Specify explicit host names# und -- wichtig -- setzen Sie
den [.guihints]#Folder# auf [.guihints]#Main directory}}.# Natürlich können Sie wie immer bei den
[wato_rules|Regeln] auch alle beliebigen anderen Bedingungen formulieren.

Wenn Sie die Regel speichern und erneut auf die Serviceliste des Hosts gehen,
werden Sie den neuen Abschnitt [.guihints]#Disabled services (configured away by admin)}}# 
entdecken. Dieser dokumentiert alle so „still&shy;gelegten“ Services:

image::bilder/disable_services_3.jpg[]

[#refresh]
=== Services auffrischen

Es gibt einige Check-Plugins, die sich während der Erkennung Dinge
_merken._  So merkt sich z.B. das Plugin für Netzwerkinterfaces die
Geschwindigkeit, auf die das Interface während der Erkennung eingestellt
war. Warum? Um Sie zu warnen, falls sich diese ändert! Es ist selten ein
gutes Zeichen, wenn ein Interface mal auf 10MBit, mal auf 1GBit eingestellt
ist -- eher ein Hinweis auf eine fehlerhafte Autonegotiation.

Was aber, wenn diese Änderung gewollt ist und von nun an als OK gelten soll?
Entfernen Sie entweder den Service via Checkbox und fügen Sie Ihn anschließend
wieder hinzu. Dazu müssen Sie nach dem Entfernen einmal Speichern. Oder Sie
drücken ICON[button_tabula_rasa.png]. Dann werden _alle_ Services des
Hosts aufgefrischt und neu erkannt. Das ist natürlich viel bequemer -- geht
aber nur, wenn Sie nicht einzelne Services im Fehlerzustand behalten wollen.

[#snmp]
=== Besonderheiten bei SNMP

Bei Geräten, die per SNMP überwacht werden, gibt es ein paar Sonderheiten.
Diese erfahren Sie im [snmp#services|Artikel über SNMP].

[#bulk_discovery]
== Serviceerkennung für viele Hosts gleichzeitig

Wenn Sie die Erkennung für mehrere Hosts auf einmal machen
wollen, können Sie sich die Arbeit mit WATOs
[wato_hosts#bulk_operations|Bulkoperationen] erleichtern. Wählen Sie zunächst aus,
auf welchen Hosts die Erkennung durch&shy;geführt werden soll. Dazu
haben Sie mehrere Möglichkeiten:

. In einem Ordner die Checkboxen bei einzelnen Hosts ankreuzen und ICON[button_discovery.png] drücken
. Mit der [wato_hosts#search|Hostsuche] Hosts suchen und beim Suchergebnis ICON[button_discovery.png] drücken
. In einem Ordner auf ICON[button_bulk_discovery.png] klicken

Bei der dritten Variante können Sie die Serviceerkennung auch rekursiv in allen Unterordnern
ausführen lassen. In allen drei Fällen gelangen Sie im nächsten Schritt zu folgendem
Dialog:

image::bilder/wato_bulk_discovery_form.jpg[align=center,width=500]

Im [.guihints]#Mode# finden Sie genau die verschiedenen Möglichkeiten, die Sie auch in der
Serviceliste in WATO haben und die wir schon weiter oben erläutert haben.

Unter [.guihints]#Selection# können Sie die Auswahl der Hosts noch mal steuern. Das ist vor
allem dann sinnvoll, wenn Sie diese nicht per Checkboxen, sondern über den Ordner
ausgewählt haben. Die meisten Optionen zielen auf eine Beschleunigung der Discovery
hin:

[cols=, ]
|===


|{{Only include hosts that failed on previous discovery}}
|Hosts, bei denen eine frühere Serviceerkennung per Bulkoperation fehlgeschlagen ist (z.B. weil der
Host zu dem Zeitpunkt nicht erreichbar war), werden von WATO mit dem Symbol ICON[icon_inventory_failed.png]
markiert. Diese Option erlaubt, die Erkennung nur genau für diese Hosts zu wiederholen.


|{{Only include hosts with a failed discovery check }}
|Dies schränkt die Erkennung auf solche Hosts ein, bei denen der [wato_services#discovery_check|Discovery Check] angeschlagen
hat. Wenn Sie mit dem Discovery Check arbeiten, ist das eine gute Methode,
um das Discovery von vielen Hosts massiv zu beschleunigen. Die Kombination mit der Option {{Refresh all services (tabula rasa)}} macht
hier allerdings weniger Sinn, da dies den Status von bestehenden Services verfälschen kann.


|{{Exclude hosts where the agent is unreachable}}
|Hosts, die nicht erreichbar sind, verursachen beim Discovery Wartezeiten durch Verbindungstimeouts. Dies kann
das Discovery einer größeren Zahl von Hosts stark verlangsamen. Wenn die Hosts aber schon im Monitoring
sind und dieses weiß, dass die Hosts (DOWN) sind, können Sie diese hiermit überspringen und die Timeouts somit
vermeiden.

|===

Die [.guihints]#Performance Options# sind so voreingestellt, dass bei SNMP-Geräten
immer ein [.guihints]#Full Scan# gemacht wird. Wenn Sie nicht auf neue Plugins aus sind,
können Sie die Erkennung durch Wegnahme der Option beschleunigen. Das
Arbeiten ohne Cachedateien ist nur in Ausnahmefällen ratsam. Insbesondere
bei Hosts, die per Checkmk-Agent überwacht werden, kann es dann sogar dazu
kommen, dass, wenn es der Zufall will, neue Logmeldungen quasi von der Discovery
„verbraucht“ werden und nicht mehr beim eigentlichen Check ankommen.

Die eingestellte `10` unter [.guihints]#Number of hosts to handle at once}}# 
bedeutet, dass immer zehn Hosts auf ein mal bearbeitet werden. Intern geschieht
das mit einem HTTP-Request. Sollten Sie Probleme mit Timeouts haben, weil
einzelne Hosts sehr lange zum Discovern brauchen, können Sie versuchen,
diese Zahl kleiner einzustellen (zulasten der Gesamtdauer).

Sobald Sie den Dialog bestätigen geht es los und Sie können den Fortschritt
beobachten -- und  den Vorgang gegebenenfalls auch abbrechen:

image::bilder/wato_bulk_discovery_progress.jpg[align=center,width=350]


[#parameters]
== Checkparameter von Services

Viele der Check-Plugins können über Parameter konfiguriert werden.
Die häufigste Anwendung ist das Setzen von Schwellwerten für
(WARN) und (CRIT). Parameter können aber auch deutlich komplexer aufge&shy;baut sein,
wie das Beispiel der Temperaturüberwachung mit Checkmk zeigt:

image::bilder/temperature_levels.png[align=center,width=350]

Die Checkparameter für einen Service werden in drei Schritten
gebildet:

. Jedes Plugin hat _Defaultwerte_ für die Parameter.
. Manche Plugins setzen Werte während der Erkennung (siehe [wato_services#refresh|oben]).
. Parameter können über Regeln gesetzt werden.

Dabei haben Parameter aus Regeln Vorrang vor den bei der Erkennung gesetzten
und diese wiederum Vor&shy;rang für den Defaultwerten. Bei komplexen Parametern,
bei denen per Checkbox einzelne Unterparameter festgelegt werden (wie im
Beispiel mit der Temperatur), gilt diese Vorrangregel für jeden einzelnen
Unterparameter separat. Wenn Sie also per Regel nur einen der Unterparameter
anpassen, bleiben die anderen auf ihren jeweiligen Defaultwerten.
So können Sie z.B mit einer Regel die Trendberechnung der Tem&shy;peratur aktivieren
und mit einer anderen die Temperaturschwellwerte für einen konkreten Sensor einstellen.
Der komplette Parametersatz wird dann aus beiden Regeln zusammengesetzt.

Welche Parameter ein Service am Ende genau hat, erfahren Sie in
der Parameterseite des Services. Diese erreichen Sie in der Serviceliste
eines Hosts über das Symbol ICON[button_check_parameters.png]. Wenn Sie die Parameter
von allen Services direkt in der Servicetabelle sehen möchten, können
Sie diese mit dem Knopf ICON[button_show_check_parameters.png] einblenden.
Das sieht dann etwa so aus:

image::bilder/wato_check_parameters.png[]


== Anpassen der Serviceerkennung

Wie Sie die Serviceerkennung konfigurieren, um nicht erwünschte Services auszublenden,
haben wir bereits [wato_services#disabled_services|weiter oben] gezeigt. Es gibt aber
für etliche Check-Plugins noch weitere Regelsätze, die das Verhalten der Discovery bei diesen
Plugins beeinflussen. Dabei gibt es nicht nur Einstellungen zum _Weglassen_ von
Items, sondern auch solche, die positiv Items finden oder zu Gruppen zusammenfassen.
Auch die Benennung von Items ist manchmal ein Thema -- z.B. bei den Switchports, wo
Sie sich entscheiden können, anstelle der Interface-ID dessen Description oder Alias
als Item (und damit im Servicenamen) zu verwenden.

Alle Regelsätze, die mit der Serviceerkennung zu tun haben, finden Sie unter
ICON[icon_rulesets.png] [.guihints]#Host & Services parameters => Parametersfor discovered services => Discovery- automatic service detection}}.# 
Bitte verwechseln Sie diese Regelsätze nicht mit denen, die zum Parametrieren
der eigentlichen Services gedacht sind. Etliche Plugins haben in der Tat zwei
Regelsätze -- einen für die Erkennung und einen für die Parameter. Dazu gleich
ein paar Beispiele.


[#processes]
=== Überwachung von Prozessen

Es wäre wenig sinnvoll, wenn Checkmk einfach für jeden Prozess,
den es auf einem Host findet, einen Service für die Überwachung einrichten
würde. Die meisten Prozesse sind entweder nicht interessant oder sogar
nur vorübergehend vorhanden. Und auf einem normalen Linux-Server laufen
mindestens hunderte von Prozessen.

Zum Überwachen von Prozessen müssen Sie daher mit
[wato_services#manual_checks|manuellen Checks] arbeiten oder -- und das ist
viel eleganter -- der Serviceerkennung mit dem Regelsatz [.guihints]#Process discovery}}# 
sagen, nach welchen Prozessen sie Ausschau halten soll. So können Sie immer dann,
wenn auf einem Host _bestimmte interessante_ Prozesse gefunden werden,
dafür automatisch eine Überwachung einrichten lassen.

Folgende Abbildung zeigt eine Regel im Regelsatz [.guihints]#Process discovery}},# 
welche nach Prozessen sucht, die das Programm `/usr/sbin/apache2`
ausführen.  In diesem Beispiel wird für jeden unterschiedlichen
Betriebs&shy;systembenutzer, für den ein solcher Prozess gefunden wird,
ein Service erzeugt
({{Grab user from found processes}}).# 
Der Name des Services wird `Apache %u`, wobei das `%u` durch den Benutzernamen
ersetzt wird. Als Schwellwerte für die Anzahl der Prozessinstanzen werden 1/1
(untere) bzw. 30/60 (obere) verwendet:

image::bilder/process_discovery.jpg[]

Bitte beachten Sie, dass die festgelegten Schwellwerte
[.guihints]#Default parameters for detected services# heißen. Denn Sie können diese -- wie bei allen anderen Services
auch -- per Regel überdefinieren. Zur Erinnerung: Obige Regel konfiguriert die
_Erkennung_ der Services -- also das _Was._ Sind die Services erst mal vorhanden,
so ist eigentlich die Regelkette [.guihints]#State and count of processes# für die Schwellwerte zuständig.

Die Tatsache, dass Sie schon bei der Erkennung Schwellwerte festlegen können, ist
nur der Bequemlichkeit geschuldet. Und es gibt auch einen Haken: Änderung in der
Erkennungsregel haben erst bei der _nächsten Erkennung_ Einfluss. Wenn Sie also Schwellwerte
ändern, müssen Sie die Erkennung nochmal ausführen.
Wenn Sie aber die Regel nur zum eigentlichen Finden verwenden (also das _Was_),
und den Regelsatz [.guihints]#State and count of processes# für das _Wie_ verwenden,
haben Sie dieses Problem nicht.

Weitere Details zur Prozesserkennung finden Sie in der ICON[icon_help.png] Onlinehilfe
dieses Regelsatzes.


=== Überwachung von Windows-Diensten

Das Erkennung und Parametrieren der Überwachung von Windows-Services geht analog
zu den Prozessen und wird über die Regelsätze [.guihints]#Windows Service Discovery# _(Was)_
bzw. [.guihints]#Windows services# _(Wie)_ gesteuert. Hier ist ein Beispiel für eine
Regel, die nach zwei Diensten Ausschau hält:

image::bilder/windows_services_discovery.jpg[]

Genau wie bei den Prozessen ist auch hier die Serviceerkennung nur eine Option.
Wenn Sie anhand von Hostmerkmalen und Ordnern präzise Regeln formulieren
können, auf welchen Hosts bestimmte Dienste erwartet werden, können Sie
auch mit [wato_services#manual_checks|manuellen Services] arbeiten. Das ist dann unabhängig
von der tat&shy;sächlich vorgefundenen Situation -- allerdings kann das deutlich
mehr Aufwand sein, da Sie unter Umstän&shy;den viele Regeln brauchen, um genau
abzubilden, auf welchem Host welche Dienste erwartet werden.


[#switches]
=== Überwachung von Switchports

(CMK) verwendet für die Überwachung von Netzwerkschnittstellen von Servern und
für die Ports von Ethernetswitchen die gleiche Logik. Vor allem bei den
Switchports sind die vorhandenen Optionen für die Steuerung der Serviceerkennung
interessant, auch wenn (im Gegensatz zu den Prozessen und Windows&shy;diensten) die
Erkennung auch erst mal ohne Regel funktioniert.
Per Default überwacht Checkmk nämlich automatisch alle physikalischen Ports,
die gerade den Zustand UP haben. Der Regelsatz
dazu heißt [.guihints]#Network Interface and Switch Port Discovery# und bietet
zahlreiche Einstellmöglichkeiten, die hier nur gekürzt dargestellt sind:

image::bilder/switch_port_discovery.jpg[]

Am wichtigsten sind folgende Möglichkeiten:

* Verwendung der [.guihints]#Description# oder des [.guihints]#Alias# im Servicenamen
* Einschränken oder _Ausweiten_ der überwachten Interfacetypen oder -namen

[#manual_checks]
== Services manuell einrichten

Es gibt einige Situationen, in denen eine automatische Serviceerkennung
nicht sinnvoll ist. Das ist immer dann der Fall, wenn Sie das Einhalten
einer bestimmte _Richtlinie_ erzwingen möchten. Wie Sie im vorherigen
Kapitel gesehen haben, können Sie Überwachung von Windows-Diensten automatisch
einrichten lassen, wenn diese gefunden werden. Was ist aber, wenn schon das
Fehlen eines solchen Diensts ein Problem darstellt? Beispiele:

* Auf jedem Windows-Host soll ein bestimmter Virenscanner installiert sein.
* Auf jedem Linux-Host soll NTP konfiguriert sein.

In solchen Fällen können Sie Services manuell anlegen. Der Einstiegspunkt
dafür ist das WATO-Modul ICON[icon_static_checks.png] [.guihints]#Manual Checks}}.# 
Dahinter verbirgt sich eine Sammlung von [wato_rules|Regelsätzen], welche
exakt die gleichen Namen haben, wie diejenigen Regelsätze, mit denen auch
Parameter für diese Checks konfiguriert werden.

Die Regeln unterscheiden sich jedoch in zwei Punkten:

* Es sind Regeln für _Hosts,_ nicht für Services. Die Services werden ja erst durch die Regeln erzeugt.
* Da keine Erkennung stattfindet, müssen Sie selbst das Check-Plugin auswählen, das für den Check verwendet werden soll.

Folgendes Beispiel zeigt den Rumpf der Regel [.guihints]#State of NTP time synchronisation# unter
[.guihints]#Manual Checks}}:# 

image::bilder/manual_check_ntp.jpg[]

Neben den Schwellwerten legen Sie hier auch das Check-Plugin fest
(z.B. `chrony` oder `ntp.time`).  Bei Check-Plugins, die ein
Item benötigen, müssen Sie auch dieses angeben. Dies ist z.B. beim Plugin
[.guihints]#oracle_processes# notwendig, welches die Angabe der zu überwachenden
Datenbank-SID benötigt:

image::bilder/manual_check_oracle_processes.jpg[]

Der so definierte manuelle Service wird auf allen Hosts angelegt, auf die
diese Regel greift. Für die eigentliche Überwachung gibt es jetzt drei Fälle:

. Der Host ist korrekt aufgesetzt und der Service geht auf (OK).
. Der Agent liefert die Information, dass der gefragte Dienst nicht läuft oder ein Problem hat. Dann geht der Service auf (CRIT) oder auf (UNKNOWN).
. Der Agent stellt überhaupt keine Informationen bereit, z.B. weil NTP überhaupt nicht installiert ist. Dann bleibt der Service auf (PEND) und der Checkmk-Service geht auf (WARN), mit dem Hinweis, dass die entsprechende Sektion in den Agentendaten fehlt.

Die meisten Regelsätze im Modul ICON[icon_static_checks.png] [.guihints]#Manual Checks# werden Sie nie
benötigen und sind nur der Voll&shy;ständigkeit halber vorhanden.
Die häufigsten Fälle für manuelle Checks sind:

* Überwachung von Windows-Diensten (Regelsatz: [.guihints]#Windows Services}})# 
* Überwachung von Prozessen (Regelsatz: [.guihints]#State and count of processes}})# 



[#discovery_check]
== Der Discovery Check

In der Einleitung haben wir versprochen, dass Checkmk die Liste der
Services nicht nur automatisch ermitteln, sondern auch _aktuell halten_
kann. Natürlich wäre dafür eine Möglichkeit, dass Sie ab und zu von Hand
eine Bulkerkennung über alle Hosts durchführen.

[#discovery_auto]
=== Automatisches Prüfen auf nicht überwachte Services

Viel besser ist dafür aber ein regelmäßiger _Discovery Check_, welcher
ab Version VERSION[1.2.8] von Checkmk bei neuen Instanzen automatisch
eingerichtet wird. Dieser Service existiert für jeden Host und meldet mit
sich mit einer Warnung, wenn er nicht überwachte Dinge findet:

image::bilder/discovery_check_warn.png[align=border]

Die Einzelheiten zu den nicht überwachten oder verschwundenen Services
finden Sie im [.guihints]#Long output of check plugin# in den Details des Services:

image::bilder/discovery_check_long_output.png[]

Zu der Serviceliste der Hosts in WATO gelangen Sie bequem über das ICON[icon_menu.png] Kontextmenü
des Discovery Checks über den Eintrag ICON[icon_services.png] [.guihints]#Edit services}}.# 

Wenn Ihre Instanz von einer älteren Version geupdated wurde, müssen Sie
diesen Check von Hand einrichten.  Das Einrichten und auch das Parametrieren
des Discovery Checks geht sehr einfach über den [wato_rules|Regelsatz]
[.guihints]#Periodic service discovery}}.# Im Parameterbereich der Regeln haben Sie
folgende Einstell&shy;möglich&shy;keiten:

image::bilder/periodic_service_discovery.jpg[]

Neben dem Intervall, in dem der Check laufen soll, und dem Monitoringstatus,
für die Fälle von nicht überwachten bzw. verschwundenen Services,
können Sie dabei auch noch auswählen, ob bei SNMP-Geräten ein
[wato_services#snmp|SNMP-Scan] stattfinden soll.


=== Services automatisch hinzufügen

Sie können den Discovery Check fehlende Services automatisch hinzufügen lassen. Dazu
aktivieren Sie die Option [.guihints]#Automatically update service configuration}}.# Nun
werden weitere Optionen sichtbar.

image::bilder/discovery_check_activate.png[]

Neben dem Hinzufügen können Sie bei [.guihints]#Mode# auch auswählen, überflüssige
Services zu entfernen oder sogar alle bestehenden Services zu entfernen und
komplett neu zu erkennen ({{Refresh}}).# Beide Optionen sind mit Vorsicht
zu genießen! Ein verschwundener Service kann auf ein Problem hindeuten! Der
Discovery Check wird so einen Service dann einfach entfernen und Sie im Glauben
wiegen, dass alles in Ordnung ist. Der Refresh ist besonders gefährlich. So
übernimmt z.B. der Check für Switchports nur solche Ports in das Monitoring,
die up sind. Ports mit Status down gelten dann als verschwunden und
würden vom Discovery Check ohne Rückfrage weggeräumt!

Ein weiteres Problem gilt es noch zu bedenken: Das Hinzufügen von Services
oder gar das automatische [.guihints]#Activate Changes# kann Sie als Admin bei Ihrer
Arbeit am System stören, wenn Sie gerade beim Konfigurieren sind.  Es kann
theoretisch passieren, dass Sie gerade dabei sind, an Regeln und Einstellungen
zu arbeiten und just in dem Augenblick ein Discovery Check Ihre Änderungen
aktiviert. Denn [wato|WATO] kann immer nur alle Änderungen auf einmal aktivieren!
Um dies zu verhindern, können Sie die Uhrzeiten, in denen so etwas geschieht,
z.B. in die Nacht legen. Die obige Abbildung zeigt dafür ein Beispiel.

Die Einstellung [.guihints]#Group discovery and activation for up to# sorgt dafür,
dass nicht jeder einzelne Service, der neu gefunden wird, sofort ein
[.guihints]#Activate Changes# auslöst, sondern eine bestimmte Zeit gewartet wird,
um gleich mehrere Änderungen in einem Rutsch zu aktivieren. Denn selbst
wenn der Discovery Check auf ein Intervall von zwei Stunden oder mehr
eingestellt ist, gilt das nur für jeden Host separat. Die Checks laufen
nicht für alle Hosts gleichzeitig -- und das ist auch gut so, denn der
Discovery Check braucht erheblich mehr Ressourcen als ein normaler Check.


[#passive_checks]
== Passive Services

Passive Services sind solche, die nicht von Checkmk aktiv angestoßen werden, sondern bei
denen regel&shy;mäßig von außen neue Checkergebnisse eingeschleust werden. Dies geschieht
in der Regel über die Kommandopipe des Cores. Hier ist ein Schritt-für-Schritt-Vorgehen
für das Einrichten eines passiven Services:

Zunächst müssen Sie den Service dem Kern bekannt machen. Dies geschieht mit dem gleichen
Regelsatz wie bei den [wato_services#legacy_checks|eigenen aktiven Checks], nur dass
Sie die [.guihints]#Command line# weglassen:

image::bilder/passive_checks.png[align=center,width=500]

Die Abbildung zeigt auch, wie Sie prüfen lassen können, ob regelmäßig
Checkergebnisse eingehen. Wenn dies für länger als 10 Minuten ausbleibt,
so wird der Service hier automatisch auf (UNKNOWN) gesetzt.

Nach einem [.guihints]#Activate Changes# beginnt der neue Service sein Leben im Zustand (PEND):

image::bilder/passive_check_pending.png[]

Das Senden der Checkergebnisse geschieht nun auf der Kommandozeile durch
ein `echo` des Befehls `PROCESS_SERVICE_CHECK_RESULT` in die
Kommandopipe `~/tmp/run/nagios.cmd`.

Die Syntax entspricht den bei Nagios üblichen Konventionen -- inklusive eines
aktuellen Zeitstempels in eckigen Klammern. Als Argumente nach dem Befehl
brauchen Sie den Hostnamen (z.B. `myhost123`) und den gewählten
Servicenamen (im Beispiel `BAR`). Die beiden weiteren Argumente sind
wieder der Status (`0` ... `3`) und die Pluginausgabe. Den
Zeitstempel erzeugen Sie mit `$(date +%s)`:

[source,bash]
----
OM:echo "[$(date +%s)] PROCESS_SERVICE_CHECK_RESULT;myhost123;BAR;2;Something bad happened" > ~/tmp/run/nagios.cmd
----

Nun zeigt der Service ohne Verzögerung den neuen Status:

image::bilder/passive_check_crit.png[]

Wenn Sie von Nagios noch das Werkzeug _NSCA_ kennen, können Sie das auch mit Checkmk
weiter&shy;verwenden. Schalten Sie dazu den NSCA-Empfänger mittels `omd config` ein und
bearbeiten Sie nach Bedarf die Konfiguration für NSCA, welche unter `etc/nsca/nsca.cfg`
liegt:

[source,bash]
----
OM:omd stop
OM:omd config set NSCA on
OM:omd config set NSCA_TCP_PORT 5667
OM:vim etc/nsca/nsca.cfg
OM:omd start
----

Das System ist dann zum Empfang von passiven Checkergebnissen via NSCA bereit.


[#commandline]
== Serviceerkennung auf der Kommandozeile

So schön eine GUI ist, so praktisch ist doch manchmal noch die gute alte Kommandozeile --
sei es zum Automatisieren oder einfach zum schnellen Arbeiten für den geübten Benutzer.
Die Serviceerkennung können Sie auf der Kommandozeile mit dem Befehl `cmk -I` auslösen.
Dabei gibt es ein paar verschiedene Spielarten. Bei allen empfehlen wir die Option `-v`,
damit Sie sehen, was genau passiert. Ohne `-v` verhält sich Checkmk nach guter alter
Unix-Tradition: Solange alles gut geht, schweigt es.

Mit einem einfachen `-I` suchen Sie auf *allen* Hosts nach neuen Services:

[source,bash]
----
OM:cmk -vI
switch-cisco-c4000:
  nothing new

switch-cisco-c4500:
  nothing new

switch-cisco-c4500-2:
  nothing new

switch-cisco-c4500-3:
  nothing new
----

Sie können nach dem `-I` auch einen oder mehrere Hostnamen angeben, um nur diese zu discovern.
Das hat gleich noch einen zweiten Effekt. Während ein `-I` auf allen Hosts
grundsätzlich nur mit *gecachten* Daten arbeitet, holt Checkmk bei der
expliziten Angabe von einem Host immer *frische* Daten!

[source,bash]
----
OM:cmk -vI myhost123
----

Alternativ können Sie über Tags filtern:

[source,bash]
----
OM:cmk -vI @mytag
----

Damit würde das Discovery für alle Hosts mit dem Hostmerkmal `mytag` durchgeführt.
Filtern mit Tags steht für alle cmk-Optionen zur Verfügung, die mehrere Hosts akzeptieren.

Mit den Optionen `--cache` bzw. `--no-cache` können Sie die Verwendung
von Cache auch explizit be&shy;stimmen.

Zusätzliche Ausgaben bekommen Sie mit einem zweiten `-v`. Bei SNMP-basierten Geräten
können Sie dann sogar jede einzelne OID sehen, die vom Gerät geholt wird:

[source,bash]
----
OM:cmk -vvI myswitch123
Discovering services on myswitch123:
myswitch123:
  SNMP scan:
       Getting OID .1.3.6.1.2.1.1.1.0: Executing SNMP GET of .1.3.6.1.2.1.1.1.0 on switch
=> ['24G Managed Switch'] OCTETSTR
24G Managed Switch
       Getting OID .1.3.6.1.2.1.1.2.0: Executing SNMP GET of .1.3.6.1.2.1.1.2.0 on switch
=> ['.1.3.6.1.4.1.11863.1.1.3'] OBJECTID
.1.3.6.1.4.1.11863.1.1.3
       Getting OID .1.3.6.1.4.1.231.2.10.2.1.1.0: Executing SNMP GET of .1.3.6.1.4.1.231.2.10.2.1.1.0 on switch
=> [None] NOSUCHOBJECT
failed.
       Getting OID .1.3.6.1.4.1.232.2.2.4.2.0: Executing SNMP GET of .1.3.6.1.4.1.232.2.2.4.2.0 on switch
=> [None] NOSUCHOBJECT
failed.
----

Ein komplettes Erneuern der Services (Tabula Rasa) machen Sie mit einem Doppel- `-II`:

[source,bash]
----
OM:cmk -vII myhost123
Discovering services on myhost123:
myhost123:
    <b class=green>1* cpu.loads
    <b class=green>1* cpu.threads
    <b class=green>6* cups_queues
    <b class=green>3* df
    <b class=green>1* diskstat
    <b class=green>3* kernel
    <b class=green>1* kernel.util
    <b class=green>3* livestatus_status
    <b class=green>1* lnx_if
    <b class=green>1* lnx_thermal
----

Sie können das Ganze auch auf ein einzelnes Check-Plugin einschränken. Die Option dazu
lautet `--checks=` und muss vor dem Hostnamen stehen:

[source,bash]
----
OM:cmk -vII --checks=df myhost123
Discovering services on myhost123:
myhost123:
    <b class=green>3* df
----

Wenn Sie fertig sind, können Sie mit `cmk -O` (bei Nagios als Kern `cmk -R`)
die Änderungen aktivieren:

[source,bash]
----
OM:cmk -O
Generating configuration for core (type cmc)...OK
Packing config...OK
Reloading monitoring core...OK
----

Und wenn Sie mal bei einer Discovery auf einen Fehler stoßen&nbsp;&#8230;

[source,bash]
----
OM:cmk -vII --checks=df myhost123
  <b class=yellow>WARNING:* Exception in discovery function of check type 'df': global name 'bar' is not defined
  nothing
----

&nbsp;&#8230; dann können Sie mit einem zusätzlichen `--debug` einen genauen Python-Stacktrace der
Fehlerstelle bekommen:

[source,bash]
----
OM:cmk --debug -vII --checks=df myhost123
Discovering services on heute:
heute:
Traceback (most recent call last):
  File "/omd/sites/heute/share/check_mk/modules/check_mk.py", line 5252, in <module>
    do_discovery(hostnames, check_types, seen_I == 1)
  File "/omd/sites/heute/share/check_mk/modules/discovery.py", line 76, in do_discovery
    do_discovery_for(hostname, check_types, only_new, use_caches, on_error)
  File "/omd/sites/heute/share/check_mk/modules/discovery.py", line 96, in do_discovery_for
    new_items = discover_services(hostname, check_types, use_caches, do_snmp_scan, on_error)
  File "/omd/sites/heute/share/check_mk/modules/discovery.py", line 677, in discover_services
    for item, paramstring in discover_check_type(hostname, ipaddress, check_type, use_caches, on_error):
  File "/omd/sites/heute/share/check_mk/modules/discovery.py", line 833, in discover_check_type
    discovered_items = discovery_function(info)
  File "/omd/sites/heute/share/check_mk/checks/df", line 91, in inventory_df
    foo = bar
NameError: global name 'bar' is not defined
----


=== Optionen im Überblick

Hier noch mal alle Optionen auf einen Blick:

[cols=, ]
|===

|`cmk -I`
|Neue Services erkennen.


|`cmk -II`
|Alle Services verwerfen und neu erkennen (Tabula Rasa).


|`-v`
|Verbose: Hosts und gefundene Services anzeigen.


|`-vv`
|Very verbose: genaues Protokoll von allen Operationen anzeigen.


|`--checks=foo`
|Erkennung (und auch Tabula Rasa) nur für das gewählte Check-Plugin durchführen.



|`@foo`
|Erkennung (und auch Tabula Rasa) nur für Hosts mit dem gewählten Hostmerkmal durchführen.



|`--cache`
|Verwendung von Cachedateien erzwingen (sonst nur bei fehlender Hostangabe).


|`--no-cache`
|Frische Daten holen (sonst nur bei Angabe von Hostname).


|`--debug`
|Im Fehlerfall abbrechen und den kompletten Aufrufstapel von Python anzeigen.


|`cmk -O`
|Änderungen aktivieren ((EE) mit CMC als Kern.)


|`cmk -R`
|Änderungen aktivieren ((RE) bzw. Nagios als Kern).

|===


=== Speicherung in Dateien

Das _Ergebnis_ der Serviceerkennung -- also die eingangs genannte Tabelle
von Hostname, Check-Plugin, Item und erkannten Parametern -- finden Sie im
Verzeichnis `var/check_mk/autochecks`. Dort existiert für jeden Host
eine Datei, welche die automatisch erkannten Services speichert. Solange
Sie die Python-Syntax der Datei nicht verletzen, können Sie einzelne Zeilen
auch von Hand löschen oder ändern. Ein Löschen der Datei entfernt
alle Services und setzt diese quasi wieder auf „unmonitored“.

.var/check_mk/autochecks/myhost123.mk

----[
  ('cpu.loads', None, cpuload_default_levels),
  ('cpu.threads', None, threads_default_levels),
  ('diskstat', u'SUMMARY', diskstat_default_levels),
  ('kernel', u'Context Switches', kernel_default_levels),
  ('kernel', u'Major Page Faults', kernel_default_levels),
  ('kernel', u'Process Creations', kernel_default_levels),
  ('kernel.util', None, {}),
  ('livestatus_status', u'stable', {}),
  ('lnx_if', u'2', {'state': ['1'], 'speed': 0}),
  ('lnx_thermal', u'Zone 0', {}),
  ('mem.linux', None, {}),
  ('mknotifyd', u'heute', {}),
  ('mknotifyd', u'stable', {}),
  ('mounts', u'/', [u'data=ordered', u'errors=remount-ro', u'relatime', u'rw']),
  ('ntp.time', None, ntp_default_levels),
  ('omd_apache', u'stable', None),
  ('tcp_conn_stats', None, tcp_conn_stats_default_levels),
  ('uptime', None, {}),
]
----


== Servicegruppen in wato_services

=== Wofür Servicegruppen?

Bis hierher haben Sie erfahren, wie Sie Services ins Monitoring aufnehmen. Nun
macht es wenig Sinn, sich Listen mit Tausenden Services anzuschauen oder
immer über Hostansichten zu gehen. Wenn Sie beispielsweise alle Dateisystem-
oder Update-Services gemeinsam beobachten wollen, können Sie in ähnlicher
Weise Gruppen bilden, wie das mit [wato_hosts#hostgroups|Hostgruppen]
möglich ist

Servicegruppen ermöglichen Ihnen auf einfach Art, über [views|Ansichten]
und NagVis-Karten deutlich mehr Ordnung ins Monitoring zu bringen und gezielte
[notifications|Alarmierungen] und [alert_handlers|Alerthandler] zu schalten.
Übrigens: Sie könnten entsprechende Ansichten fast immer auch rein über
die Ansichten-Filter konstruieren -- Servicegruppen sind aber einfacher und
übersichtlicher zu handeln.


=== Servicegruppen anlegen

Sie finden Servicegruppen unter [.guihints]#WATO => Host & Service Groups}}.# Standardmäßig
erscheinen hier die Hostgruppen, klicken Sie also zunächst auf
ICON[button_service_groups.png]. Dort finden Sie ein ähnliches Menü,
um die Service Gruppen zu definieren:

image::bilder/servicegroups_list2.png[]

Das Anlegen einer Servicegruppe ist simpel: Legen Sie über
ICON[button_new_service_group.png] eine Gruppe an und vergeben Sie einen
später nicht mehr veränderbaren Namen sowie einen aussagekräftigen Alias:

image::bilder/servicegroups_config.png[]


=== Services in Servicegruppe aufnehmen

Für die Zuordnung von Services in Servicegruppen benötigen Sie den
[wato_rules#conditions|Regelsatz] {{Assignment of services to service groups}},
zu finden unter [.guihints]#WATO => Host & Service Parameters => Grouping}}.# Erstellen Sie nun
über ICON[button_create_rule_in_folder.png] eine neue Regel im gewünschten
Ordner. Zunächst legen Sie fest, welcher Servicegruppe Services zugeordnet
werden sollen, hier beispielsweise _myservicegroup_ beziehungsweise
dessen Alias _My Service Group 1._

image::bilder/servicegroups_rule_assignment.png[]

Der spannende Teil folgt nun im Bereich [.guihints]#Conditions}}.# Zum einen dürfen
Sie hier über Ordner, Hostmerkmale und explizite Hostnamen Einschränkungen
abseits der Services vornehmen. Zum anderen nennen Sie eben die Services, die
Sie gerne gruppiert hätten, beispielsweise _Filesystems_ und _CIFS
mount_, um eine Gruppe mit Dateisystemen zu erstellen. Die Angabe der
Services erfolgt hier in Form [regexes|Regulärer Ausdrücke]. So können
Sie Gruppen ganz exakt definieren.

image::bilder/servicegroups_rule_conditions.png[]


===  Servicegruppen eines Services prüfen

Die Zuordnungen von Services können Sie auf der Detailseite eines jeweiligen
Service prüfen. Hier finden Sie, standardmäßig weit unten, die Zeile
[.guihints]#Service groups the service is member of}}.# 

image::bilder/servicegroups_service_detail.png[]


=== Servicegruppen einsetzen

Zum Einsatz kommen die Servicegruppen wie bereits erwähnt an mehreren
Stellen: [views|Ansichten,] NagVis-Karten, [notifications|Alarmierungen]
und [alert_handlers|Alerthandler.] Bei neuen Ansichten ist hier wichtig,
dass Sie als Datenquelle die [.guihints]#Servicegroups# setzen. Im [.guihints]#Views}}-Widget# 
finden Sie natürlich auch vordefinierte Ansichten für Servicegruppen,
zum Beispiel eine übersichtliche Zusammenfassung:

image::bilder/servicegroups_view_summary.png[]

Mit einem Klick auf die Servicegruppennamen gelangen Sie zur vollständigen
Ansicht aller Services der jeweiligen Gruppe.

Wenn Sie Servicegruppen in NagVis-Karten einsetzen, bekommen Sie als Ergebnis
beispielsweise Zusammenfassungen von Servicegruppen per Hover-Menü über
ein einzelnes Icon:

image::bilder/servicegroups_nagvis.png[]

Wenn Sie Servicegruppen in [notifications|Alarmierungen]
und [alert_handlers|Alerthandlern] nutzen, stehen sie als
[wato_rules#conditions|Bedingungen/Filter] zur Verfügung, von denen Sie
einen oder mehrere nutzen können:

image::bilder/servicegroups_notification_rule2.png[]


[#checkplugins]
== Mehr über Check-Plugins

=== Kurze Beschreibung der Funktionsweise

Check-Plugins werden benötigt, um die Services in Checkmk zu erstellen. Jeder
Service greift auf ein Check-Plugin zurück, um seinen Status zu ermitteln,
Metriken zu erstellen/pflegen usw. Dabei kann ein solches Plugin einen oder
mehrere Services pro Host erstellen. Damit mehrere Services vom gleichen
Plugin unterschieden werden können, wird ein *Item* benötigt.  So ist
z.B. beim Service `Filesystem /var` das Item der Text `/var`. Bei
Plugins, die pro Host maximal einen Service anlegen können (z.B. `CPU
utilization`), ist das Item leer und nicht sichtbar.


=== Verfügbare Check-Plugins

Eine Liste aller verfügbaren Check-Plugins finden Sie unter [.guihints]#WATO => Check Plugins}}.# 
Hier können Sie nach verschiedenen Kategorien gefiltert die
einzelnen Plugins durchsuchen:

image::bilder/wato_services_checkplugins_01.png[]

Zu jedem Plugin werden drei Spalten ausgegeben, die die Servicebeschreibung
(Type of Check), den Namen des Check-Plugins (Plugin Name) und die kompatiblen
Datenquellen (Agents) enthalten:


image::bilder/wato_services_checkplugins_02.png[]
