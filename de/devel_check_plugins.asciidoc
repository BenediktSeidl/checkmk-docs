include::global_attr.adoc[]
= Eigene Checkplugins schreiben
:revdate: draft
:title: 
:description: 

[TIP]
.Related Articles:
====
link:localchecks.html[]

link:agent_linux.html[]

link:agent_windows.html[]

link:cmk_commandline.html[]

link:legacy_writing_checks.html[]

link:mkps.html[]

link:simulation_mode.html[]

link:snmp.html[]

link:wato_monitoringagents.html[]

link:wato_services.html[]

====


== Einleitung

{CMK} umfasst fast 2.000 fertige Checkplugins für alle nur denkbare Hardware und Software.
Diese werden vom {CMK}-Team gepflegt, und jede Woche kommen neue dazu.
Daneben gibt es auf der
link:https://exchange.checkmk.com[{CMK}-Exchange] weitere Plugins, die von unseren
Anwendern beigesteuert werden.

Und trotzdem gibt es immer wieder Situationen, in denen ein Gerät, eine
Anwendung oder einfach nur eine bestimmte Metrik, die für Sie wichtig ist,
noch von keinem dieser Plugins erfasst ist -- vielleicht auch einfach
deshalb, weil es sich dabei um etwas handelt, dass in Ihrer Firma entwickelt
wurde und es daher niemand anders haben kann.

=== Muss es immer ein echtes Plugin sein?

Welche Möglichkeiten haben Sie also, hier dennoch eine sinnvolle Überwachung
zu implementieren? Nun -- natürlich können Sie sich an unseren
link:https://checkmk.de/support.html[Support] wenden und ein geeignetes
Plugin entwickeln lassen. Aber Sie können sich auch
selbst helfen. Dabei haben Sie erstmal vier Möglichkeiten:

[cols=4]
|===
|Methode |So geht's |Vorteile |Nachteile 

|link:localchecks.html[Localcheck] |{CMK}-Agent um einfaches Skript erweitern |Geht sehr einfach, ist in allen Programmiersprachen möglich, welche das Betriebssystem des überwachten Hosts anbietet, unterstützt sogar Serviceerkennung |Konfiguration der Schwellwerte nur beim Agenten selbst, für komplexere Dinge unkomfortabel, keine Unterstützung für SNMP.
|Nagios-kompatibles Checkplugin |Plugin per _MRPE_ vom [agent_windows#mrpe|Windows-] oder link:agent_linux.html#mrpe[Linux-]Agenten aufrufen lassen. |Zugriff auf alle vorhandenen Nagios-Plugins, auch hier freie Wahl der Programmiersprache |Konfiguration der Schwellwerte nur beim Agenten selbst, Keine SNMP-Unterstützung durch {CMK}, keine Serviceerkennung möglich
|Logmeldungen auswerten |_Meldungen_ überwachen per link:ec.html[Event Console] |Keine Entwicklung notwendig sondern nur aufstellen von Regeln in der Event Console |Geht nur, wenn passende Logmeldungen vorhanden sind, kein gesichterter aktueller Status, kein Erfassen von Metriken, keine konfigurierbaren Schwellwerte
|Echtes {CMK}-Plugin |Wird link:devel_check_plugins.html#agentbased[in diesem Artikel] erklärt |Fügt sich zu 100% in {CMK} ein, automatische Serviceerkennung, zentrale Konfiguration der Schwellwerte über die grafische Oberfläche, sehr performant, unterstützt SNMP, automatische Host- und Servicelabels möglich, unterstützt link:inventory.html[HW/SW-Inventur], Unterstützung durch Standardbibliothken von {CMK}. |Erfordert mehr Einarbeitungszeit sowie Kenntnisse in der Programmsprache Python
|===


Dieser Artikel zeigt Ihnen, wie Sie echte {CMK}-Checkplugins entwickeln
können -- mit allem was dazugehört. Dabei zeigen wir Ihnen, wie Sie
die in Version VERSION[1.7.0] von {CMK} *neu entwickelte API* für die
Pluginprogrammierung nutzen. Wenn Sie Plugins entwickeln möchten, welche
auch auf älteren {CMK}-Versionen funktionieren sollen, können Sie die auf
die link:legacy_writing_checks.html[früheren Handbuchartikel] zurückgreifen. Diese
werden allerdings schon seit längerem nicht mehr gepflegt und sind nur auf
Englisch verfügbar.

=== Was hat sich seit der alten API geändert?

Haben Sie schon Erfahrung mit dem Entwickeln von Checkplugins für die
{CMK}-Version VERSION[1.6.0] oder früher?  Dann finden Sie hier eine knappe
Übersicht über alle Änderungen, welche die ab VERSION[1.7.0] verfügbare neue
Check-API mit sich bringt:

* Plugins sind jetzt Python-3-Module und die Dateien müssen mit `.py` enden.
* Die eigenen Plugins liegen jetzt im Verzeichnis `local/lib/check_mk/base/plugins/agent_based`.
* Am Anfang der Datei brauchen Sie nun mindestens eine spezielle `import`-Anweisung.
* Die Sektionen und die eigentlichen Checks werden getrennt registiert. Dazu gibt es die neuen Funktionen `register.agent_section` und `register.check_plugin`.
* Etliche Funktions- und Argumentnamen wurden umbenannt. Unter anderem wird jetzt immer konsequent von _Discovery_ gesprochen (früher: _Inventory_).
* Die Discovery-Funktion (vormals Inventory-Funktion) und auch die Check-Funktion müssen nun _immer_ als Generatoren arbeiten (also `yield` verwenden).
* Die Namen der Argumente der deklarierten Funktionen sind jetzt fest vorgegeben.
* Anstelle der SNMP-Scanfunktion schreiben Sie eine _Deklaration_, welche OIDs mit welchen Werten erwartet werden.
* Die Funktionen zum Darstellen von Zahlen wurden neu strukturiert (z.B. wird `render_bytes_human_readable` zu `render.bytes`).
* Es gibt nun eine eigene Methode, mit der Checks andere ausschließen können (`superseeds`). Das wird nicht mehr in der SNMP-Scanfunktion gemacht.
* Die Hilfsfunktionen für die Arbeit mit Countern, Raten und Durchschnitten haben sich geändert.
* Anstelle von magischen Rückgabewerten wie z.B. `2` für {CRIT} gibt es jetzt Konstanten (z.B. `state.CRIT`).
* Viele mögliche Programmierfehler in Ihrem Plugin erkennt {CMK} jetzt sehr früh und kann Sie gleich darauf hinweisen.

=== Wird die alte API noch unterstützt

Ja, die bis zu Version VERSION[1.6.0] von {CMK} gültige API für die
Entwicklung von Checkplugins wird noch etliche Jahre unterstützt werden,
da mit dieser sehr sehr viele Plugins entwickelt wurden. Während dieser
Zeit wird {CMK} bei APIs parallel anbieten.

Trotzdem empfehlen wir für die Enwicklung von neuen Plugins die neue API,
da diese konsistenter und logischer ist, besser dokumentiert und langfristig
am zukunftssichersten.

=== Verschiedene Arten von Agenten

Checkplugins werten die Daten der {CMK}-Agenten aus. Und deswegen sollten wir,
bevor wir uns in Geschehen stürzen, uns zunächst einen Überblick
darüber verschaffen, welche Arten von Agenten {CMK} eigentlich kennt:

[cols="20,~"]
|===

|{CMK}-Agent |Hier werten die Plugins Daten aus, welcher der {CMK}-Agent für Linux, Windows oder andere Betriebssysteme sendet. Damit werden Betriebssystemparameter und Anwendungen überwacht und teilweise auch Serverhardware. Jedes neue Checkplugin erfordert eine Erweiterung des Agenten in Form eines Agent-Plugins, damit dieser die nötigen Daten bereitstellt.
|link:devel_check_specialagent.html[Spezialagent / API-Integration] |Einen Spezialagenten benötigen Sie, wenn Sie weder mit dem normalen {CMK}-Agenten noch per SNMP an die Daten kommen, welche für das Monitoring relevant sind. Der häufigste Fall ist das Abfragen von HTTP-basierten APIs. Beispiele sind die Überwachung von [monitoring_aws|AWS], [monitoring_azure|Azure] oder link:monitoring_vmware.html[VMware]. Hier schreiben Sie ein Skript, welches direkt auf dem {CMK}-Server läuft, sich mit der API verbindet, und Daten im gleichen Format ausgibt, wie dies ein Agentenplugin tun würde.
|link:devel_check_snmp.html[SNMP] |Bei der Überwachung via link:snmp.html[SNMP] benötigen Sie keine Erweiterung eines Agenten sondern werten Daten aus, welche {CMK} von dem zu überwachenden Gerät per SNMP abruft, welche dieses standardmäßig bereitstellt. {CMK} unterstützt Sie dabei und übernimmt sämtliche Details und Sonderheiten des SNMP-Protokolls. Eigentlich gibt es auch hier einen Agenten: nämlich den auf dem überwachten System vorinstallierten SNMP-Agenten.
|link:devel_check_active.html[Aktiver Check] |Dieser Checktyp bildet eine Sonderrolle. Hier schreiben Sie zunächst ein klassisches Nagios-kompatibles Plugin, welches für die Ausführung _auf dem {CMK}-Server_ bestimmt ist und von dort aus mit einem Netzwerkprotokoll direkt einen Dienst auf dem Zielgerät abfragt. Das prominenteste Beispiel ist das Plugin `check_http`, mit welchem Sie Webserver und Webseiten überwachen können. Dieses Plugin können Sie dann so in {CMK} integrieren, dass man es wie gewohnt per Regeln einrichten kann.
|===


=== Voraussetzungen

Wenn Sie Lust haben, sich mit dem Programmieren von Checkplugins zu befassen,
benötigen Sie die folgenden Voraussetzungen:

* Kenntnisse in der Programmiersprache Python
* Erfahrung mit {CMK}, vor allem was das Thema Agenten und Checks betrifft
* etwas Übung mit Linux auf der Kommandozeile

Als Vorbereitung sind außerdem folgende Artikel gut:

- link:wato_services.html[Services verstehen und konfigurieren]
- link:wato_monitoringagents.html[Monitoringagenten]
- link:agent_windows.html[Windows überwachen]
- link:agent_linux.html[Linux überwachen]
- link:snmp.html[Überwachen via SNMP]
- link:cmk_commandline.html[Checkmk auf der Kommandozeile]
- link:mkps.html[Checkmk Erweiterungspakete (MKPs)]
- link:simulation_mode.html[Der Simulationsmodus]


[#agentbased]
== Ein erstes einfaches Checkplugin

Nach dieser langen Einleitung wird es Zeit, dass wir unser erstes einfaches
Checkplugin programmieren. Als Beispiel nehmen wir eine einfache Überwachung
für Linux. Denn da {CMK} selbst auf Linux läuft, ist es sehr wahrscheinlich,
dass Sie auch auf ein Linuxsystem Zugriff haben.

Das Checkplugin soll einen neuen Service anlegen, welcher erkennt, ob auf einem
Linuxserver jemand einen USB-Stick eingesteckt hat. In diesem Fall soll er
kritisch werden. Vielleicht werden Sie sowas sogar nützlich finden, aber
es ist wirklich nur ein vereinfachtes Beispiel und möglicherweise auch
nicht ganz wasserdicht programmiert. Denn darum geht es hier erstmal nicht.

Das Ganze läuft in zwei Schritten:

. Wir finden heraus, mit welchem Linuxbefehl man sehen kann, ob ein USB-Stick eingesteckt ist, und erweitern den Linux-Agenten um ein kleines Skript, welches diesen Befehl aufruft.
. Wir schreiben in der {CMK}-Instanz ein Checkplugin, welches diese Daten auswertet.

Und los geht's...

=== Den richtigen Befehl finden

Am Anfang jeder Checkprogrammierung steht: die Recherche! Das bedeutet, dass
wir herausfinden, wie wir überhaupt an die Informationen kommen, die wie für
die Überwachung brauchen. Bei Linux sind das oft Kommandozeilenbefehle, bei
Windows hilft die PowerShell, VBScript oder WMI und bei SNMP müssen wir die
richtigen OIDs finden (dazu gibt es einen link:devel_check_snmp.html[eigenen Artikel]).

Für das Herausfinden des richtigen Befehls gibt es leider kein allgemeines
Vorgehen und so will ich mich auch nicht allzulange mit dem Thema aufhalten,
erkläre aber kurz, wie das mit dem USB-Stick funktioniert.

Zunächst loggen wir uns also auf dem zu überwachenden Host ein.  Unter Linux
läuft der Agent per Default als `root`-Benutzer. Deswegen machen
wir auch alle unsere Tests einfach als `root`.  Für unsere Aufgabe
mit dem USB-Stick gibt es praktischerweise symbolische Links im Verzeichnis
`/dev/disk/by-id`. Diese zeigen auf alle Linux-Block-Devices.  Und ein
solches ist auch ein eingesteckter USB-Stick. Außerdem kann man an der ID
am Präfix `usb-` erkennen, wenn ein Block-Device ein USB-Gerät ist.
Folgender Befehl listet alle Einträge in diesem Verzeichnis auf:

{c-start}
{c-root}ls -l /dev/disk/by-id/
total 0
lrwxrwxrwx 1 root root  9 May 14 11:21 ata-APPLE_SSD_SM0512F_S1K5NYBF810191 -> ../../sda
lrwxrwxrwx 1 root root 10 May 14 11:21 ata-APPLE_SSD_SM0512F_S1K5NYBF810191-part1 -> ../../sda1
lrwxrwxrwx 1 root root 10 May 14 11:21 ata-APPLE_SSD_SM0512F_S1K5NYBF810191-part2 -> ../../sda2
lrwxrwxrwx 1 root root 10 May 14 11:21 ata-APPLE_SSD_SM0512F_S1K5NYBF810191-part3 -> ../../sda3
lrwxrwxrwx 1 root root 10 May 14 11:21 ata-APPLE_SSD_SM0512F_S1K5NYBF810191-part4 -> ../../sda4
lrwxrwxrwx 1 root root 10 May 14 11:21 ata-APPLE_SSD_SM0512F_S1K5NYBF810191-part5 -> ../../sda5
lrwxrwxrwx 1 root root  9 May 14 11:21 wwn-0x5002538655584d30 -> ../../sda
lrwxrwxrwx 1 root root 10 May 14 11:21 wwn-0x5002538655584d30-part1 -> ../../sda1
lrwxrwxrwx 1 root root 10 May 14 11:21 wwn-0x5002538655584d30-part2 -> ../../sda2
lrwxrwxrwx 1 root root 10 May 14 11:21 wwn-0x5002538655584d30-part3 -> ../../sda3
lrwxrwxrwx 1 root root 10 May 14 11:21 wwn-0x5002538655584d30-part4 -> ../../sda4
lrwxrwxrwx 1 root root 10 May 14 11:21 wwn-0x5002538655584d30-part5 -> ../../sda5
{c-end}

So. Und das Ganze jetzt mit eingestecktem USB-Stick:

{c-start}
{c-root}ls -l /dev/disk/by-id/
total 0
lrwxrwxrwx 1 root root  9 Mai 14 11:21 ata-APPLE_SSD_SM0512F_S1K5NYBF810191 -> ../../sda
lrwxrwxrwx 1 root root 10 Mai 14 11:21 ata-APPLE_SSD_SM0512F_S1K5NYBF810191-part1 -> ../../sda1
lrwxrwxrwx 1 root root 10 Mai 14 11:21 ata-APPLE_SSD_SM0512F_S1K5NYBF810191-part2 -> ../../sda2
lrwxrwxrwx 1 root root 10 Mai 14 11:21 ata-APPLE_SSD_SM0512F_S1K5NYBF810191-part3 -> ../../sda3
lrwxrwxrwx 1 root root 10 Mai 14 11:21 ata-APPLE_SSD_SM0512F_S1K5NYBF810191-part4 -> ../../sda4
lrwxrwxrwx 1 root root 10 Mai 14 11:21 ata-APPLE_SSD_SM0512F_S1K5NYBF810191-part5 -> ../../sda5
<b class=hilite>lrwxrwxrwx 1 root root  9 Mai 14 12:15 usb-SCSI_DISK-0:0 -> ../../sdc*
<b class=hilite>lrwxrwxrwx 1 root root 10 Mai 14 12:15 usb-SCSI_DISK-0:0-part1 -> ../../sdc1*
<b class=hilite>lrwxrwxrwx 1 root root 10 Mai 14 12:15 usb-SCSI_DISK-0:0-part2 -> ../../sdc2*
lrwxrwxrwx 1 root root  9 Mai 14 11:21 wwn-0x5002538655584d30 -> ../../sda
lrwxrwxrwx 1 root root 10 Mai 14 11:21 wwn-0x5002538655584d30-part1 -> ../../sda1
lrwxrwxrwx 1 root root 10 Mai 14 11:21 wwn-0x5002538655584d30-part2 -> ../../sda2
lrwxrwxrwx 1 root root 10 Mai 14 11:21 wwn-0x5002538655584d30-part3 -> ../../sda3
lrwxrwxrwx 1 root root 10 Mai 14 11:21 wwn-0x5002538655584d30-part4 -> ../../sda4
lrwxrwxrwx 1 root root 10 Mai 14 11:21 wwn-0x5002538655584d30-part5 -> ../../sda5
{c-end}

=== Die Daten entschlacken

Eigentlich wären wir damit fertig und könnten diese ganze Ausgabe per {CMK}-Agent
zum {CMK}-Server transportieren und dort analysieren lassen. Denn im {CMK} gilt
immer folgende Empfehlung: lassen Sie die komplexe Arbeit immer den Server erledigen.
Halten Sie das Agentenplugin so einfach wie möglich.

Aber: Hier ist trotzdem noch zuviel heiße Luft drin. Es ist immer gut,
unnötige Daten nicht zu übertragen. Das spart Netzwerkverkehr, Speicher,
Rechenzeit und macht alles auch übersichtlicher. Das geht besser!

Als erstes können wir das `-l` weglassen. Damit ist die Ausgabe von
`ls` schon deutlich schlanker:

{c-start}
{c-root}ls /dev/disk/by-id/
ata-APPLE_SSD_SM0512F_S1K5NYBF810191        ata-APPLE_SSD_SM0512F_S1K5NYBF810191-part5  wwn-0x5002538655584d30-part3
ata-APPLE_SSD_SM0512F_S1K5NYBF810191-part1  wwn-0x5002538655584d30-part4                ata-APPLE_SSD_SM0512F_S1K5NYBF810191-part2
wwn-0x5002538655584d30                      wwn-0x5002538655584d30-part5                ata-APPLE_SSD_SM0512F_S1K5NYBF810191-part3
wwn-0x5002538655584d30-part1                ata-APPLE_SSD_SM0512F_S1K5NYBF810191-part4  wwn-0x5002538655584d30-part2
{c-end}

Jetzt wiederum stört der mehrspaltige Aufbau. Dieser ist aber nur deswegen, weil der `ls`-Befehl erkennt,
dass er in einem interaktiven Terminal läuft. Später als Teil vom Agenten wird er die Daten einspaltig ausgeben.
Das können wir aber auch ganz einfach hier mit der Option `-1` erzwingen:

{c-start}
{c-root}ls -1 /dev/disk/by-id/
ata-APPLE_SSD_SM0512F_S1K5NYBF810191
ata-APPLE_SSD_SM0512F_S1K5NYBF810191-part1
ata-APPLE_SSD_SM0512F_S1K5NYBF810191-part2
ata-APPLE_SSD_SM0512F_S1K5NYBF810191-part3
ata-APPLE_SSD_SM0512F_S1K5NYBF810191-part4
ata-APPLE_SSD_SM0512F_S1K5NYBF810191-part5
wwn-0x5002538655584d30
wwn-0x5002538655584d30-part1
wwn-0x5002538655584d30-part2
wwn-0x5002538655584d30-part3
wwn-0x5002538655584d30-part4
wwn-0x5002538655584d30-part5
{c-end}

Wenn Sie genau hinsehen, werden Sie nicht nur die Blockgeräte selbst sehen,
sondern auch dort vorhandene Partitionen. Dies sind die Einträge, die
auf `-part1`, `-part2` usw. enden. Diese brauchen wir für unseren
Check nicht und bekommen sie ganz einfach mit einem `grep`. Dort
nehmen wir die Option `-v` für eine negative Logik. Hier sieht man
jetzt auch viel deutlicher, dass es in meinem Beispiel eigentlich genau vier Geräte sind,
falls der USB-Stick eingesteckt ist:


{c-start}
{c-root}ls /dev/disk/by-id/ | grep -v -- -part
ata-APPLE_SSD_SM0512F_S1K5NYBF810191
<b class=hilite>usb-SCSI_DISK-0:0*
wwn-0x5002538655584d30
{c-end}

Perfekt! Jetzt haben wir eine übersichtliche Liste aller Blockgeräte, die
mit einem einfachen Befehl ermittelt wird. Mehr brauchen wir nicht.

Das `-1` hab ich jetzt hier wieder weggelassen, weil `ls`
jetzt in eine Pipe schreibt und von sich aus einspaltig ausgibt. Und
`grep` braucht das `--`, da es sonst das Wort `-part`
als die vier Optionen `-p`, `-a`, `-r` und `-t`
interpretieren würde.

Übrigens: Warum greppen wir nicht gleich noch nach `usb`? So dass
nur noch USB-Geräte übertragen werden? Nun, natürlich könnten wir
das tun. Aber zum Einen wird dann unser Beispiel zunehmend langweilig und
außerdem ist es irgendwie beruhigender, im Normalfall _irgendeinen_
Inhalt in der Sektion zu bekommen und nicht einfach nur nichts. So kann
man auf dem {CMK}-Server sofort erkennen, dass das Agentenplugin korrekt
funktioniert.


=== Den Befehl in den Agenten einbauen

Damit wir vom {CMK}-Server aus diese Daten abrufen können, müssen wir den
neuen Befehl Teil vom {CMK}-Agenten auf dem überwachten System machen. Wir
könnten dazu natürlich einfach dort die Datei `/bin/bin/check_mk_agent` editieren
und das einbauen. Das hätte dann aber den Nachteil, dass bei einem Softwareupdate
des Agenten unser Befehl wieder verschwindet, weil die Datei ersetzt wird.

Besser ist daher, wenn wir ein *Agentenplugin* machen. Das ist sogar
noch einfacher. Alles was wir brauchen, ist eine ausführbare Datei mit unserem
Befehl im Verzeichnis `/usr/lib/check_mk_agent/plugins`.

Und noch eins ist wichtig: Wir können unsere Daten nicht einfach so
ausgeben. Was wir noch brauchen, ist eine *Sektionskopf* (_section header_).
Das ist eine speziell formatierte Zeile, in der der Name unseres
neuen Checks steht. An diesen Sektionsköpfen kann {CMK} später erkennen, wo die
Daten des Plugins beginnen und die des vorherigen aufhören.

Also brauchen wir jetzt erstmal einen sinnvollen Namen für unseren neuen
Check. Dieser Name muss aus Kleinbuchstaben, Unterstrichen und Ziffern
bestehen und eindeutig sein. Es darf also nicht schon eine Sektion mit
diesem Namen geben. Wenn Sie neugierig sind, welche Namen es schon gibt,
können Sie diese in einer {CMK}-Instanz auf der Kommandozeile mit `cmk -L`
auflisten lassen:

{c-start}
{c-omd}cmk -L | head -n 20
3par_capacity                     tcp    HPE 3PAR: Capacity
3par_cpgs                         tcp    HPE 3PAR: CPGs
3par_cpgs.usage                   tcp    HPE 3PAR: CPGs Usage
3par_hosts                        tcp    HPE 3PAR: Hosts
3par_ports                        tcp    HPE 3PAR: Ports
3par_remotecopy                   tcp    HPE 3PAR: Remote Copy
3par_system                       tcp    HPE 3PAR: System
3par_volumes                      tcp    HPE 3PAR: Volumes
3ware_disks                       tcp    3ware ATA RAID Controller: State of Disks
3ware_info                        tcp    3ware ATA RAID Controller: General Information
3ware_units                       tcp    3ware ATA RAID Controller: State of Units
acme_agent_sessions               snmp   ACME Devices: Agent Sessions
acme_certificates                 snmp   ACME Devices: Certificates
acme_fan                          snmp   ACME Devices: Fans
acme_powersupply                  snmp   ACME Devices: Power Supplies
{c-end}

Wählen wir für unser Beispiel den Namen `linux_usbstick`. In diesem
Fall muss der Sektionskopf so aussehen:

.
....
<<<linux_usbstick>>>
....

Den können wir einfach mit `echo` ausgeben. Wenn wir dann noch den
„Shabang“ nicht vergessen (das ist kein giftiger Stachel aus dem Wüstenplaneten
sondern eine Abkürzung für _sharp_ und _bang_, wobei letzteres
eine Abkürzung für das Ausrufezeichen ist!), an dem Linux erkennt, dass es
das Skript mit der Shell ausführen soll, dann sieht unser Plugin
so aus:

./usr/lib/check_mk_agent/plugins/linux_usbstick
....
#!/bin/sh
echo '<<<linux_usbstick>>>'
ls /dev/disk/by-id/ | grep -v -- -part
....

Als Dateiname hab ich jetzt einfach auch `linux_usbstick` verwendet,
auch wenn der eigentlich egal ist. Aber eines ist noch sehr wichtig: Machen
Sie die Datei ausführbar!

{c-start}
{c-root}chmod +x /usr/lib/check_mk_agent/plugins/linux_usbstick
{c-end}

Natürlich können Sie das Plugin ganz einfach von Hand ausprobieren, indem Sie den
kompletten Pfad als Befehl eingeben:

{c-start}
{c-root}/usr/lib/check_mk_agent/plugins/linux_usbstick
<<<linux_usbstick>>>
ata-APPLE_SSD_SM0512F_S1K5NYBF810191
wwn-0x5002538655584d30
{c-end}

=== Agent ausprobieren

Wie immer ist am wichtigsten Test und Fehlersuche. Am besten gehen Sie in drei Schritten vor:

. Plugin solo ausprobieren. Das haben wir gerade gemacht.
. Agent aus ganzes lokal testen.
. Agent vom {CMK}-Server aus abrufen.

Das lokale Testen des Agenten ist sehr einfach. Rufen Sie einfach als `root`
den Befehl `check_mk_agent` auf. Irgendwo in der Ausgabe muss die neue
Sektion erscheinen:

{c-start}
{c-root}check_mk_agent
{c-end}

Hier ist ein Ausschnitt der Ausgabe, welcher die neue Sektion enthält:

{c-start}
<<<lnx_thermal:sep(124)>>>
thermal_zone0|-|BAT0|35600
thermal_zone1|-|x86_pkg_temp|81000|0|passive|0|passive
<<<local>>>
<b class=hilite><<<linux_usbstick>>>*
<b class=hilite>ata-APPLE_SSD_SM0512F_S1K5NYBF810191*
<b class=hilite>wwn-0x5002538655584d30*
<<<lnx_packages:sep(124):persist(1589463274)>>>
accountsservice|0.6.45-1ubuntu1|amd64|deb|-||install ok installed
acl|2.2.52-3build1|amd64|deb|-||install ok installed
acpi|1.7-1.1|amd64|deb|-||install ok installed
{c-end}


Durch Anhängen von `less` können Sie in der Ausgabe blättern
(drücken Sie die Leertaste zum Blättern,
`/` zum Suchen und `Q` zum Beenden ):

{c-start}
{c-root}check_mk_agent | less
{c-end}

Der dritte Test ist dann direkt von der {CMK}-Instanz aus. Nehmen Sie den Host ins Monitoring
auf (z.B. als `myserver01`) und rufen Sie die Agentendaten dann mit `cmk -d` ab.
Hier sollte die gleiche Ausgabe kommen:

{c-start}
{c-omd}cmk -d myserver01 | less
{c-end}

Übrigens: `grep` hat mit `-A` eine Option, nach jedem Treffer
noch einige Zeilen mehr auszugeben.  Damit können Sie bequem die Sektion
suchen und ausgeben:

{c-start}
{c-root}cmk -d heute | grep -A5 '^&lt;&lt;&lt;linux_usbstick'
<<<linux_usbstick>>>
ata-APPLE_SSD_SM0512F_S1K5NYBF810191
wwn-0x5002538655584d30
<<<lnx_packages:sep(124):persist(1589463559)>>>
accountsservice|0.6.45-1ubuntu1|amd64|deb|-||install ok installed
{c-end}

Wenn das funktioniert, ist Ihr Agent vorbereitet! Und was haben wir
dafür gemacht? Wir haben lediglich ein dreizeiliges Skript mit dem Pfad
`/usr/lib/check_mk_agent/plugins/usbstick` erzeugt und ausführbar
gemacht!

Alles was nun folgt, geschieht nur noch auf dem {CMK}-Server: Dort schreiben
wir das eigentliche Checkplugin.

=== Die Sektion deklarieren

Das Vorbereiten des Agenten ist zwar der komplizierteste Teil, aber nur die
halbe Miete. Jetzt müssen wir {CMK} noch beibringen, wie es mit den Informationen
und der neuen Agentensektion umgehen soll, welches Services es erzeugen soll,
wann diese auf {OK} oder {CRIT} gehen sollen usw. All dies machen wir durch
die Programmierung eines Checkplugins in Python.

Für Ihre eigenen Checkplugins finden Sie ein Verzeichnis vorbereitet
in der `local`-Hierarchie des
link:cmk_commandline.html#sitedir[Instanzverzeichnisses]. Dieses lautet
`local/lib/check_mk/base/plugins/agent_based/`. Hier im Pfad
bedeutet `base` den Teil von {CMK}, der für das eigentlich Monitoring
und die Alarmierung zuständig ist. Das `agent_based` ist
für alle Plugins, die sich auf den {CMK}-Agenten
beziehen (also z.B. nicht Alarmierungsplugins). Am einfachsten, Sie wechseln
zum Arbeiten dort hinein:

{c-start}
{c-omd}cd local/lib/check_mk/base/plugins/agent_based
{c-end}

Das Verzeichnis gehört dem Instanzbenutzer und ist daher für Sie schreibbar.
Sie können Ihr Plugin mit jedem auf dem Linuxsystem installierten Texteditor
bearbeiten.

Legen wir also unser Plugin hier an. Konvention ist, dass der Dateiname
den Namen der Agentensektion wiedergibt. _Pflicht_ ist, dass die Datei
mit `.py` endet, denn ab Version VERSION[1.7.0] von {CMK} handelt es
sich bei den Plugins immer um echte Pythonmodule.

Als erstes müssen wir die für die Plugins nötigen Funktionen aus
anderen Pythonmodulen importieren. Die einfachste Methode dafür ist die
mit einem `*`. Wie Sie vielleicht ahnen können, steckt hier auch
eine Versionsnummer der API für die Pluginprogrammierung. Diese ist bis
auf weiteres Version 1, was hier durch `v1` abgekürzt ist:

.local/lib/check_mk/base/plugins/agent_based/linux_usbstick.py
....
from .agent_based_api.v1 import *
....

Diese Versionierung ermöglicht es uns in Zukunft eventuell neue
Versionen der API _parallel_ zu den bisherigen bereitzustellen,
so dass bestehende Checkplugins weiterhin problemlos funktionieren.


=== Den Check deklarieren

Damit {CMK} weiß, dass es den neuen Check gibt, muss dieser
registriert werden. Dies geschieht durch den Aufruf
der Funktion `register.check_plugin`.
Dabei müssen Sie immer mindestens vier Dinge angeben:

. `name`: Der Name des Checkplugins. Wenn Sie keinen Ärger bekommen möchten, nehmen Sie hier den gleichen Namen wie bei Ihrer neuen Agentensektion. Damit weiß der Check automatisch, welche Sektion er auswerten soll.
. `service_name`: Der Name des Services wie er dann im Monitoring erscheinen soll.
. `discovery_function`: Die Funktion zum Erkennen von Services dieses Typs (dazu gleich mehr).
. `check_funktion`: Die Funktion zum Durchführen des eigentlichen Checks (auch dazu gleich mehr).
=== Die Discovery-Funktion schreiben
=== Die Check-Funktion schreiben
* Mit `for line in section` gehen wir in einer Schleife alle Zeilen der Agentenausgabe durch.
* Dann prüfen wir, ob das erste Wort der Zeile -- das jeweilige Gerät -- mit `usb-SCSI_DISK` beginnt.
* Falls ja, erzeugen wir ein Check-Resultat mit dem Status {CRIT} und dem Text `Found USB stick`. Und wir beenden dann die Funktion mit einem `return`.
* Falls die Schleife durchlaufen wird, ohne etwas zu finden, erzeugen wir den Status {OK} und den Text `No USB stick found`.
=== Die Discovery testen
=== Den Check testen
=== Das ganze Plugin auf einen Blick
== Checks mit mehr als einem Service pro Host (Items)
=== Grundprinzip
* Die Discovery-Funktion muss die Liste der Items generieren, die auf dem Host sinnvollerweise überwacht werden sollen.
* Im Servicenamen müssen Sie das Item mithilfe des Platzhalters `%s` einbauen (also z.B. `"Filesystem %s"`).
* Die Check-Funktion wird pro Item einmal separat aufgerufen und bekommt dieses als Argument. Sie muss dann aus den Agentendaten die für dieses Item relevanten Daten herausfischen.
=== Ein einfaches Beispiel
* Wenn alle Slots belegt sind, soll das Ding {CRIT} werden.
* Wenn weniger als 10 Slots frei sind, dann wird es {WARN}.
* Ansonsten {OK}
. Der Befehl `return` sorgt dafür, dass die Check-Funktion nach dem Bearbeiten des gefundenen Items sofort abgebrochen wird. Es gibt schließlich auch nichts mehr weiter zu tun.
. Wird die Schleife durchlaufen, ohne das gesuchte Item zu finden, so erzeugt {CMK} _automatisch_ das Resultat `UNKNOWN - Item not found in monitoring data`. Das ist so gewollt und gut so. Behandeln Sie diesen Fall nicht selbst. Wenn sie ein gesuchtes Item nicht finden, so lassen sie Python einfach aus der Funktion rauslaufen und {CMK} seine Arbeit erledigen.
. Mit dem Argument `summary` definieren Sie den Text, den der Service aus Statusausgabe produziert. Er ist rein informell und wird von {CMK} nicht weiter ausgewertet.
{c-start}
{c-omd}cmk --checks=foobar -vI myhost123
{c-end}
{c-start}
{c-omd}cmk --checks=foobar -v myhost123
{c-end}
=== Beispiel komplett
== Messwerte
=== Werte in der Checkfunktion ermitteln
=== Informationen zu den Schwellwerten
* Falls nur eine der beiden Schwellen definiert ist, tragen Sie für die andere einfach `None` ein, also z.B. `levels=(None, 200)`.
* Es sind auch Fließkommazahlen erlaubt, aber keine Strings.
* Achtung: für die _Überprüfung_ der Schwellwerte ist die Checkfunktion selbst verantwortlich.  Die Angabe von `levels` dient lediglich als Randinformation für das Graphingsystem!
=== Der Wertebereich
== Checks mit mehreren Teilresultaten
== Summary und Details
== Weitere Aspekte
* Fehlerbehandlung
* SNMP-basierte Checks
* Schwellwerte und andere Checkparameter
* Die Renderfunktionen (korrekte Darstellung von Zahlen)
* Checks im Cluster
* Checks mit einem Regelsatz, welche die Discovery steuert
* Counter und andere persistierte Daten
* Host- und Servicelabels erzeugen
* Includefunktionen, geteilter Code
* Definition von Perf-O-Metern, Graphtemplates, Metriken
* Manpages schreiben
* Checks, die mehr als eine Sektion verwenden
* Deklaratoren in den Sektionen, z.B. `sep(...)`.
* Mehrere Checks für die gleiche Sektion
* Ein Check, der mehrere Sektionen auswertet
== Ausblick
* Definitionen für die von den Services gelieferten link:graphing.html[Messdaten], damit schöne und gut beschriftete Graphen und „Perf-O-Meter“ erzeugt werden.
* Ein Regelsatz, mit dem Sie die Parameter des Checkplugins konfigurieren können.
* Ein Regelsatz, welcher das Agentenplugin für die link:wato_monitoringagents.html#bakery[Agentenbäckerei] konfiguriert.
* Ein Regelsatz, mit der der Spezialagent konfiguriert werden kann.
* Eine Manualpage, welche das Checkplugin für den Anwender dokumentiert.
* Ein link:mkps.html[MKP-Paket], in welchem das Plugin paketiert und einfach installierbar ist.
