include::global_attr.adoc[]
= Host and service views
:revdate: 2020-02-21
:title: Views and their possibilities in detail
:description: Views are very powerful in checkmk and can be individually created or customized. How to effectively use views is explained here.

[TIP]
.Related Articles:
====
link:user_interface.html[]
link:dashboards.html[]
link:graphing.html[]
====



== Introduction

The most important task performed by {CMK}’s link:user_interface.html[user interface] is displaying the current
status of hosts and services. This is achieved largely with tabular [.guihint]#views#. In order
for the daily operations to run as efficiently as possible, these tabular views offer numerous functions, and they
can be customised to meet your requirements.

We distinguish between *global* views and those that require a *context*. Global views can always
be directly called up. An example of a global view is the list of all current service problems.
A context view -- the [.guihint]#Status of Host ...# view for example -- namely needs to specify by name the host whose status is to be displayed.
Such views can only be called-up in situations relevant to a particular host.

The global view is most easily accessed via the [.guihint]#Tactical Overview}} and {{Views#. In the tactical
overview each number is clickable and takes you to a global view that individually
lists the hosts or services counted in each case.

image::tactical_overview.png[center, width=42%]

In the [.guihint]#Views# element all global views are accessible -- grouped according to theme. In addition
you will find a few entries that aren’t actually [.guihint]#Views# -- such as for example, the link:dashboards.html[Dashboards],
which are sorted under the [.guihint]#Overview# theme.  Dashboards can however _contain_ views.

image::snapin_views.png[center, width=280]

From a global view, with a further step you can access the details for a particular host or service.
On the one hand, the names of hosts and services and the individual cells in other columns are clickable for more detailed views:

[.border]
image::views_all_hosts.png[]

On the other hand, at the top of views _that relate to a specific host or
service_ you can find a row of buttons that can be opened with
ICON[context_button_dots.png]. These buttons then open further views with the
same context -- meaning those from the same host or service.

[.border]
image::views_context_buttons.png[]

Another way to the detailed view is via the quicksearch snapin in the sidebar:

image::snapin_quicksearch.png[center, width=42%]

Which view you receive will depend on the result of the search. If the search identifies a host
explicitly, you will reach this host’s [.guihint]#Services of host ...# page directly. There you will again
find the buttons for the other views of this same host.

//SK: Might have been like this a long time ago.
//Especially practical -- a click on the host’s name takes you a detailed view of the host’s availability:

[.border]
image::view_services_of_host.png[]

== Using views

=== Options, filters and commands

At the top left of every view there are six symbols with which you can influence the display, and
trigger actions:

[#filter]
=== Time and Date
=== Sorting
* sorted in ascending order
* sorted in descending order
* column unsorted
[.border]
image::views_sortbyhost.png[]
=== Export#export

|===

|Opens the dialogue with the [.guihint]#filters#. With this you can further limit the displayed data. As soon as you set a filter the symbol on ICON[button_filters_set_lo.png] changes so that it is clear that under certain circumstances not all data will be will be displayed.
 Conversely, some views already have predefined filters, (e.g. the list of all problems). Here, by removing the filters you can also have more data displayed.
 Changes to filters are not saved, rather they are reset when you quit the view.</td></tr>
 <tr><td>ICON[view_button_options.png]</td> <td>Opens the _display options_, with which you can, e.g., define the time data format (relative or absolute). Which options are available depends on what is appropriate for the information displayed in the view.</td></tr>
 <tr><td>ICON[icon_commands.png]</td> <td>Here you can execute link:commands.html[commands] to the object shown (e.g., entering scheduled downtimes).  The commands are described in detail in their link:commands.html[own article].</td></tr>
 <tr><td>ICON[icon_checkbox.png]</td> <td>With this you switch checkboxes on or off. With the checkboxes you can restrict the commands to selected data sets.</td></tr>
 <tr><td>ICON[view_button_columns.png]</td> <td>This ‘thumbwheel’ can be turned by clicking on it or with the mouse wheel. It defines the number of columns for the selected view. Views with multiple columns allow the space available on wider monitors to be exploited. For views that only display a single data set this setting has no effect.</td></tr>
 <tr><td>ICON[view_button_refresh.png]</td> <td>This ‘thumbwheel’ defines the view’s refresh interval. You can also disable the automatic refreshing. Be aware that in this case it is possible that you will not be informed of problems that occur in the meantime!</td></tr> </table>

 {CMK} shows time stamps as relative values in all of the views of states if these are less than 24 hours in the past or future -- e.g., [.guihint]#16 hours#. You can switch to absolute time values if you change the ICON[view_button_options.png] [.guihint]#time stamp format}} option to {{absolute#.

 The tabular views can be sorted by clicking on the column heading. A column has three states that can be selected in a loop of multiple clicks:

 Views are initially sorted ‘naturally’ according to how the view is defined. In service lists the sorting is alphabetic by service name -- with the exception of _Check_MK_ services that are always at the top. The [.guihint]#Check_MK# service is responsible for managing the monitoring agent. There are also [.guihint]#Check_MK Discovery}} and {{Check_MK HW/SW Inventory# services.

 Sorting by the [.guihint]#Perf-O-Meter# column sometimes produces surprising results. This is due to the graphic display of the link:graphing.html[values] being partly a percentaged summarisation of the actual values. The sorting is however performed according to absolute values, and is always based on the _first metric_ produced by a service.

 Data displayed in a view can be exported in several formats:
 <table> <tr>   <th>Format</th>   <th>Action</th> </tr>
 <tr>   <td>PDF





|===


=== The display limit#limit

In a larger monitoring environment displaying all views is no longer practical. When you are
monitoring 50,000 services and select the [.guihint]#All Services# view, not only will the display require a
very long time -- it will also not be very useful.

In such situations, in order to protect the user from long waiting times and to avoid crippling the
system with absurd quantities of data, views are limited to 1000 entries in their display. Exceeding
this limit produces the following warning:

image::views_limit1.png[]

As you can see, the records being displayed are not necessarily the first 1000 corresponding to
the selected sorting method! There is a technical reason for this: namely that the limit is applied
to the data source in the connected instance’s monitoring cores. This is very important, because if
we accumulate one million data records from your environment spread around the world, then 99.9% of the
data will be deleted immediately. The sorting takes place from the end of the list, thus it happens
_after_ the limit. The data from all instances must, after all, be sorted together.

If you really want to see more than one thousand records, then you can reach the next level by
clicking on [.guihint]#Repeat query and allow more results#. Here the limit is 5,000 records. If this
limit has again been exceeded, with _unlimited_ you can continue.  Insofar this is a
potentially risky action, you will require _Administrator rights_. You have been warned!

image::views_limit2.png[]

You can define both levels in the [.guihint]#WATO|Global Settings}} under {{User interface#:

image::views_limit3.png[]

== Customising views#edit

=== The basics

{CMK} allows you to customise its standard views, and even to create new ones that you can
incorporate into [reporting|reports] and link:dashboards.html[dashboards]. Thus you can define numerous
different aspects for every view:

* *General items* such as title, theme, etc.
* Which *data source* to be displayed (e.g. hosts, services, events on the event console, etc.)?
* Which selection of records is to be displayed (*filtering*)?
* Which *columns* will be displayed?
* Which other views are *linked* to the text in the columns?
* What is the standard *sorting* method?
* Is there a *grouping*, and if so, how does it look?
* Where and for which user should the view be *visible*?
* Which style of *table layout* should be used?

The edit mode for views can be reached in two ways:

. From an active view via the ICON[context_button_edit_view.png] button (which is possibly hidden behind ICON[context_button_dots.png]).
. From the sidebar element [.guihint]#Views# via the ICON[button_view_snapin_edit.png] button. Here you can create completely new views with ICON[context_button_new.png], or customise existing ones with ICON[button_clone.png]:

[.border]
image::table_views.png[]

=== Clone first -- then modify

The views supplied as standard are a part of the software and as such cannot be changed, however
{CMK} does recognise the concept of _cloning_. When a view is first customised (regardless
if by using ICON[context_button_edit_view.png] or via the list) a copy of that view is created
automatically. This copy is added to your user profile.

This copy can then be customised as desired. The original view is retained but is
_‘greyed-out’_ -- overlaid by your version in effect. You can return to the standard view later
by simply deleting your clone (achieved in the table of views, as you might expect, with
ICON[icon_delete.png]).

This concept has one further advantage: namely, that you can define whether the view should be
changed _for all users_ or just for yourself. This is specified in the view’s [.guihint]#General Properties#
with the checkbox [.guihint]#Make this view available for all users#. Not surprisingly, you can
only select this checkbox if you have link:wato_user.html#roles[administrator permissions] (or more correctly, this function has its own permission -- [.guihint]#Publish views#). Additionally, single views can be locked in
the link:wato_user.html#roles[role definitions].

What happens when a view is customised and published by several users? Each user then has their own
variant of the view. Which view will be visible for which user(s)? This can be determined with the
following rules:

. When a user creates a view for themself, this always has priority for him/her.
. After this are views that have been customised and published by an administrator (to be precise, someone with the [.guihint]#Modify building views# permission).
. If there are none here, then those views apply that another normal user with the [.guihint]#Publish Views# permission has published.
. And when there is also nothing here then the supplied version will be visible.

How can you create a _real copy_ of a view, so that when done you can have both the supplied
and your own views?  This is defined by using [.guihint]#Unique ID}} in the {{General Properties#. Simply
give your view a new name, so that it will no longer be identified as a clone of the supplied view,
rather it will begin its own life.

The ID is the decisive keyword for opening views in the URL. The schema is very simple.
Here for example is how the global view with its ID  `allhosts` is opened:

`/mysite/check_mk/view.py?view_name=allhosts`

The concept with cloning, customising and visibility can be found at many other locations in
{CMK}, namely in:

* link:dashboards.html[dashboards]
* link:reporting.html[reporting]
* link:graphing.html#graph_collections[graph collections]
* link:graphing.html#custom_graphs[custom graphs]
* link:user_interface.html#bookmarks[bookmark lists]

=== Integrating a view into the sidebar

How and if a view will be shown in the sidebar’s [.guihint]#Views# element, is defined by the following
characteristics under [.guihint]#General Properties#:

image::edit_view_general.jpg[]

* [.guihint]#Title# -- the item’s name
* [.guihint]#Topic# -- the view will be sorted under this topic. You can also define other topics.
* [.guihint]#Hide this view from the sidebar# -- this view will not appear in the sidebar

=== Context button for a view

A [.guihint]#Context Button# only makes sense for views with a context. An example is the
ICON[button_host_services.png] button which is linked to the `host` view (and which will
always be shown when a host is known). This is defined in the view’s characteristics:

* The view has a  *context*, namely [.guihint]#Show information of single... host#.
* ICON[icon_status.png] has been selected as the [.guihint]#Icon# for the button.
* The [.guihint]#Button Text# has been set as `services`.
* The checkbox [.guihint]#Do not show a context button to this view# is *deactivated*.

So are all of the requirements satified, and whenever we move in a host’s context a button for this
view will appear (possibly behind ICON[context_button_dots.png] as usual).

=== Basic layout

The next block -- [.guihint]#View Properties# -- defines the view’s general appearance:

image::edit_view_properties.jpg[]

Under [.guihint]#Basic Layout# there are various styles for displaying the data in tables. Most views use
[.guihint]#table}} -- a normal table that can be sorted by columns -- or {{Single data set# - which has the
legend on the left and which is mostly used for single data sets. You can however also use
[.guihint]#single data set}} for views with more than one object.  The {{All Hosts# view looks something like this
when altered to [.guihint]#Single data set#:

image::layout_single_dataset.png[]

The [.guihint]#Number of Columns# setting is the default for the ICON[view_button_columns.png] counter for
specifying the number of columns. Similarly, [.guihint]#Automatic page reload# is the default for the
ICON[view_button_refresh.png] display refresh counter.

=== Columns and grouping

The [.guihint]#Columns# box defines which columns you wish to see. The number of columns possible selection depends on
the selected data source. The most columns are found  in services, naturally, as all information for
the particular service is available. The list can be quite long here, and if you are uncertain which
column is the right one, there is only one thing to do -- try it out:

image::edit_view_columns.png[]

The [.guihint]#Link# field offers a selection of all views. If a view is selected here, then the column’s
respective cell is _clickable_ and takes the the user to the chosen view.  This really only
makes sense if the targetted view has a context. The best example is the [.guihint]#All Hosts# view. The
[.guihint]#Hostname}} column is clickable here and takes the user to this host’s {{Services of host#.

Under [.guihint]#Tooltip#, on the other hand, you will find a list of all columns.  Thus you can show
further information for the host or service, when the user moves the mouse cursor over the
respective cell (the IP-address in this example).

[.border]
image::view_hover_address.png[]

=== Information for services in a host view

Let’s imagine that you’d like to display the information for particular services in a table of
hosts. The following example illustrates this situation very well: here the current uptime, the
CPU load, the memory usage and the NTP-synchronisation are shown for each host:

[.border]
image::view_service_column_1.png[]

Here a table of hosts has been generated in which for each host the [.guihint]#Perf-O-Meter# *service column*
for four different services is displayed. One sees that for one of the three
hosts the [.guihint]#CPU load}} and the {{Memory# services do not exist and that the
column is consequently empty.

// SK: Beim Update des Bildes view_service_column_1.png wurde die Spalte für NTP Time weggelassen.
// SK: Ich kommentiere den entsprechenden Satz mal aus und füge etwas passendes ein.
// SK: One sees that for three of the five servers the
// SK: [.guihint]#NTP Time# service does not exist and that the column is consequently empty.

This view’s configuration was achieved by adding columns of the [.guihint]#Joined column# type. Here the
column for services in which [.guihint]#Perf-O-Meter}} has been selected appears under {{Column#.  The
[.guihint]#Title# entry defines the column's heading. The service’s *exact* name is entered (upper and
lower case sensitive!) in the [.guihint]#Of Service# field:

image::view_service_column_2.png[]

Naturally such a display is only useful if the view shows a list of similar hosts which also all
utilise the selected services. That is also the reason why {CMK} does not provide views of this
type -- which columns are meaningful here depends entirely on the type of host selected. For Linux
servers the information of interest is certainly completely different to that for USVs, for example.

=== Sorting

The sorting of a view is configured in the the fourth block. It’s only a matter of the predefined
sorting method. Users can -- as described above -- determine the sorting order themselves with a click
on the column heading. In the view’s configuration however you have more possibilities -- you can
define a _multi-step_ sorting order, e.g. first by service-status, and for the same status by
service name.  The order so determined is retained as a subordinate sorting when the user resorts in
a specific column.

image::edit_view_sorting.png[]

=== Grouping

Through grouping you divide a table into several segments -- in which each segment’s data is related
in some way. The best example of this is the [.guihint]#Service problems# view, which is simply reached via
the [.guihint]#Tactical overview#. As you can see, this table is grouped with _Service status_ (first
all {CRIT}, then {UNKNOWN}, then {WARN}):

[.border]
image::edit_view_grouping.png[]

The grouping in a view is configured similarly to the columns. Simply define which column the
grouping should relate to. It is usually only one, but can be more. All records with the same
value for all selected columns will then be displayed in a group -- and the column heading will be
shown as the group title.

It is important that you also *sort* the records by priority according to the group’s
selected characteristic! Otherwise it can be possible that the same group makes multiple appearances
(which may at times be desirable). Incidentally, a resorting by column performed by a user has no
effect on the grouping -- in such a case only the group’s sequence is determined and the records
sorted within the group. The groups themselves are unchanged.

=== Filters, contexts and searches

An important aspect of views is the data _selection_. Which hosts or services should be
displayed in a table? {CMK} uses the *Filter* concept for this purpose. Here are a couple of
examples of host-filters:

image::views_filter.png[]

Every filter can be defined with search terms or other criteria by a user, thus reducing the list of
results to those records meeting the criteria. In this way the filters are AND-linked. The filter
criteria actually used for a view are assembled from three sources:

. Filters with criteria defined as standard for the view
. Filters set interactively by the user with ICON[view_button_filters.png] in the view
. Filters that can be set with variables via the URL

The filters you assemble by editing in the view’s [.guihint]#context/search filters# box have two
functions. Firstly, you decide which filter will be available to a user with a click on
ICON[view_button_filters.png]. Secondly, you can predefine filters with criteria, thus limiting the
data to be displayed in the view (point 1 above).

If you create or edit a view with *context* -- instead of the filter for the relevant object
only an optional entry field appears. In this an _exact_ comparison always applies (upper and
lower case sensitive). As an example we can take the `host` view, which displays all services
of a _specified_ host. The host’s name will be added through a context to the view. You can
also build a display in which the diplayed host is effectively *hard-coded* directly in the
view:

image::view_filter_context.png[]

In this way you can summon the view without context, or if desired simply add it to the sidebar’s
[.guihint]#Views# element without problem.

=== Special search views

The supplied as standard [.guihint]#Host search}} and {{Service search# (and others) views behave in a special way in
relation to the filters. When you you select one of these views, it opens with a filter formula, and
then only shows hosts and services when this filter is activated.

Why? It would simply be very impractical if you first had to go to [.guihint]#All services#, and then be
forced to wait until several thousand services are displayed before you could filter the result with
a search entry. This behaviour is regulated by the [.guihint]#Show data only on search# option:

image::view_search_only.png[]

== Creating new views#new

Creating a new view with ICON[context_button_new.png] functions in principle just like the editing
of an existing view -- with a small difference: you must first select a *data source* and a
*specific object type*.

=== Data source

image::new_view_1.png[]

The data source is what you might call a table or database view in databases.
{CMK} does not use SQL-Data bases, but it is similarly-structured internally. In most cases you
will be correct with [.guihint]#All services}} or {{All hosts#.  There are however a few data sources that
should be listed briefly:

[options="header"]
|===


|Meaning

|Host and service groups, various
|see below

|[.guihint]#Alert Statistics#
|link:livestatus.html#Statistiken abrufen (Stats)[status statistics]

|BI, various
|link:bi.html[Business Intelligence]

|[.guihint]#Event Console#, host and service events
|link:ec.html[Event Console]

|[.guihint]#Inventory#, various
|link:inventory.html[inventory items]

|[.guihint]#The Logfile#
|link:livestatus.html#logs[Livestatus data]

|===


==== Host and service groups
The data sources [.guihint]#Hostgroups}} and {{Servicegroups# -- per line -- provide the information
about the group itself -- accordingly there are no filters for individual hosts
or services. An example of this data source is the standard
[.guihint]#Host groups (Summary)# view. In distributed environments the data sources
[.guihint]#Hostgroups, merged}} and {{Servicegroups, merged# do exactly the same.

[.border]
image::views_hostgroups_summary.png[]

However, if you want information about individual hosts, just grouped by host
groups, you can use [.guihint]#Hosts grouped by host groups#. Here each host is listed
once for each group it belongs to, as seen in the default view [.guihint]#Host groups#.
In the world of databases one would speak here of a _Join_ of the
[.guihint]#Hosts}} table with the {{Hostgroups# table.

[.border]
image::views_hostgroups.png[]

You can proceed in the same way with services: [.guihint]#Services grouped by host groups#
corresponds to a Join of the [.guihint]#Services}} table with the {{Hostgroups#, and
[.guihint]#Services grouped by service groups}} accordingly with the {{Servicegroups# table.

Depending on the selected data source, different columns are available for
building the view.

=== Object type -- global or with context

image::new_view_2.png[]

Here it can be decided whether your new view should have a context or if it will be a global view.
The selections available to you depend on the data source. The most common context by far is ‘Host’.
The image above appears after selecting the [.guihint]#All services# data source.

Checking the [.guihint]#Show information of a single host# box defines that the new view describes one
specific host. Thus you have created the basis for a view that is not globally-visible, but instead visible
via a link:

* For a host view with a context button (possibly hidden behind ICON[context_button_dots.png])
* As a link in a column (see above, e.g., click on a host name in a view)

There are two options for the [.guihint]#Service# context type. If you select only
[.guihint]#Show information of a single service#, you can build a view that displays all services
with the same name on _different hosts_. If it should be a specific service for a single host,
then check the [.guihint]#Show information of a single host# box.

== The matrix

When you specify the [.guihint]#Matrix# layout in one of your views you will probably see strange things at
first, and ask yourself what is going on. The matrix is certainly not intuitive on first viewing,
but you can achieve good things with it.

In the supplied standard views there is one that utilises this layout -- and that is
[.guihint]#Metrics|Search peformance data#. The following image shows how I searched for the
`CPU|Memory|Filesystem`
service printout in this view in my test system:

image::service_filter_cpumemfs.png[center, width=60%]

The result is a neat table of my hosts, in which all of the service’s metrics are listed adjacent.
Not all hosts have the same services, so some of the fields are simply empty:

[.border]
image::matrix_view_1.jpg[]

The result at first looks very similar to that described somewhat earlier [.guihint]#Information for services in a host view#.
There are a couple of significant differences however:

. The list of services is dynamic and has no fixed configuration.
. Here the hosts are the columns -- not the lines.
. With the matrix you can do much more.

When you look at the view’s definition you can see how it is constructed:

* [.guihint]#Matrix}} is specified in {{Basic layout#.
* The [.guihint]#Hostname}} is specified as the only column in {{Grouping#.
* In [.guihint]#Columns}} the {{Service description}} and the {{Service Perf-O-Meter# are specified.

The rule for the matrix layout is:

* The *[.guihint]#Grouping columns#* are used as headings for the vertical columns.
* The *first normal [.guihint]#column#* on the left provides the titles for the lines.
* All *further normal [.guihint]#columns#* are shown in the cells.

If you, e.g., wish to display more information about the host, simply add more columns in the
[.guihint]#Grouping# section.
Thus the table from above will look like this when you insert the [.guihint]#Host icons}} and {{WATO folder -- just folder name#
columns:

[.border]
image::matrix_view_2.jpg[]

Further normal columns then land directly in the cells. The following example shows (abreviated) the
matrix with the additional [.guihint]#Output of check plugin# column:

[.border]
image::matrix_view_3.jpg[]

=== Recognising outliers

Why do some cells have a coloured background? This alerts you to values *lying outside the majority*.
This is actually not so meaningful for measurement data,
but there are, for example, users with a specially-constructed matrix who can tell at a glance if an incorrect
contact group has been entered for certain hosts or services!

== Alarm sounds#alarm_sounds

A view can sound an alarm tone over the browser if at least one problem appears in the table (a host
that is not {UP}, or a service that is not {OK}). This primitive type of alarm is, e.g., interesting
for control centres where there is always a list of problems on a screen that the operator doesn’t
want to be continuously staring at.

The alarm sounds are deactivated by default. You can switch them on with the
[.guihint]#Global settings|User interface|Enable sounds in views# global switch. As always the search field helps here:

image::sounds_in_views.png[]

Sounds will not be heard in all views, rather only in those for which sounds are activated in [.guihint]#View Properties#:

image::view_properties_sounds.png[]

== Embedding views in external websites#embed_views

Since every view is accessible via a URL you can also embed these in other websites, for example, via
an `&lt;iframe&gt;`.  A number of elements in a view however make no sense or are even
distracting in such a context.  In a case like this you can attach a `display_options=...`
variable to the URL, via which you can precisely control which component of the view should be
generated in HTML code.

Every component is coded with a letter. If you use lower case letters the denoted element will be
deactivated and all those remaining will be created (effectively an ‘opt-out’). With capital letters this
situation is reversed: here with capitals you nominate only the elements to be created (‘opt-in’). A
mixture of upper and lower cases makes no sense.

The following letters have been defined:


|===


|===


For example -- if you want to switch off all control elements and buttons and only display the actual
table, a link on the `allhosts` view will look like this:

`http://myserver/mysite/check_mk/view.py?view_name=allhosts&display_options=tbdezocf`

== Adding your own icons and actions

In views of hosts and services you will also see a column for icons, and in this the ICON[icon_menu.png] [.guihint]#Action menu# icon with which you can select host or service actions. You can also add your own icons to views. These can be used simply for visualization, or your own actions can be assigned to them.

For example, hosts with a graphic web interface can be quickly identified using such an individual icon and can also be controlled directly via a link.

The procedure for adding your own icons and actions is divided into three steps:

* Upload the icons
* Define the icons/actions
* Assign the icons to hosts/services

Start with [.guihint]#WATO|Custom Icons# and upload a local file with a maximum size of 80x80 pixels. The icon is now in the system, but is not yet in use.

image::custom_icons_upload_modern.png[]

Now you have to define the icon as an object that can be addressed via link:wato_rules.html[rules], and optionally, an associated action. You can find the settings under [.guihint]#WATO|Global Settings|User Interface|Custom icons and actions}}. Create a new entry here using {{Add new element}}, and define {{ID}}, {{Icon}} and a {{title#; The title will later be displayed as a tool tip directly on the icon via on-mouse-over-effect, and is therefore indispensable for users.

Now it gets interesting with the point [.guihint]#Action#. Action is equivalent to a URL, and for this you can use some variables like `$HOSTNAME$` or `$SERVICEDESC$` (service-description) -- you can get further information from the online help. A valid action would be, for example, `view.py?host=$HOSTNAME$&site=mysite&view_name=host`, which is simply the standard host view for the respective host on the _mysite_ page calls.

With a check mark at [.guihint]#Show in column# you can then display the icon as an independent icon next to ICON[icon_menu.png], otherwise your action will end up in this action menu.

image::custom_icons_config_modern.png[]

In the last step, you now determine which hosts or services the new icon is to
be displayed for -- specifying these using rules of course. You can find the two
rules [.guihint]#Custom icons or actions for hosts in status GUI# and
[.guihint]#Custom icons or actions for services in status GUI# under
[.guihint]#WATO|Host & Service Parameters|User Interface#. Create a
new rule in the desired folder and set at least two options in it. First  select
the icon just created under [.guihint]#Custom icons or actions for hosts in status GUI#,
then as usual, filter in the [.guihint]#Conditions# area for the desired
hosts/services. Finally, save and confirm the changes.

image::custom_icons_host-rule_modern.png[]

In host and service views you will now be able to see your new icon next to or in the action menu for the filtered hosts and services.

image::custom_icons_host-view_modern.png[]
