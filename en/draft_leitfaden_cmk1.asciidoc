= Training Guide for CMK-1
:revdate: draft


This is the official guide for conducting the CMK-1 ‘System Monitoring with Checkmk - Part 1’ training.


== Technical setup in the training room

For each course participant we have prepared a separate Linux computer (physical or virtual), setup with the following:

* Debian, Ubuntu, SLES, RedHat or CentOS distributions in a current version supported by Checkmk.
* The installation always takes place with the *default selection*! This means that you almost always ‘click through’ when installing the Distro. Additional packages should *not* be installed.
* The participants’ computers have a login as a normal user.
* The participants have access to the `root` user.
* The computers have internet access.
* The package sources are set up so that the participant’s packages can be installed using `zypper`, `yum` or `apt`.
* Each participant has access to a VM with a current Windows version in a basic installation.

There is also access to an SNMP device that the participants can later monitor. We should be able to work with the management interface of the switch and, for example, edit the descriptions of the switch ports so that later we can show how to use them for the discovery and the rules. Recommendation: Manageable fanless switches from TP-Link for example.

If we want to, we can also use additional devices or an SNMP simulator.


== Day 1


=== Introduction and preliminary small talk


==== Introduction of the participants and the lecturer

The participants and the lecturer introduce themselves. All sign the list of participants or sign the entry that has already been prepared for them.


==== Introduction of the tribe29 company

We briefly introduce tribe29. Mathias Kettner founded the company in 2007 in Munich. In 2008 the first version of Checkmk was released -- originally as an add-on for Nagios in those days.

In 2019 the company was renamed from ‘Mathias Kettner Gmbh’ to ‘tribe29 GmbH’. The company now has around 40 employees, and more than 2,000 customers who have a Checkmk subscription.

image::bilder/tribe29_logo.png[align=center,width=30%]


==== Presentation of Checkmk -- the theory

We start with the theoretical part concerning Checkmk -- this takes about 30-45 minutes. First, a general introduction to Checkmk. What is it? What can it do? We provide a general overview of what problems Checkmk can solve, and what features it has, based on the information on the
<a href="https://checkmk.de/features.html">website</a>.

We present the advantages of Checkmk:

* Security -- the agent is read-only, for example
* Efficiency, performance, scalability
* Lightweight agents!
* Manageability through the Bakery and deployment
* The ease with which the agent can be extended by the user themselves
* The wide variety of systems that can be monitored
* Automated Discovery
* Price
* German support (we like to promote ourselves)

Next, we present an illustration of the Checkmk architecture. We show, for example:

* The separation of the GUI from the monitoring core
* Where the notifications are triggered
* The agent communication
* How the Event Console is integrated


=== We install Checkmk


==== The Checkmk editions

We explain the different [intro#editions|editions] of Checkmk. We advise which edition is the right one for various situations. We also present the explanatory table on our website at <a href="https://checkmk.de/editions.html">Editions</a>.

We conduct the actual training using the (CEE) (with the (CFE) the number of hosts would not be sufficient, or would be annoying during the training). When features are not available in the (RE), we will always point out this out!

Next we will show the participants that the appliances (rack1, rack4, virt1) are available, and what their advantages are:

* Simple administration (without Linux knowledge)
* High availability
* Simple operating system updates
* Advantages with support (hardware failures, exchange without restoring of data required)
* Political advantages if you actually have no root access on Linux servers (in another department)

We usually don't *demonstrate* the appliance in the official part of the course -- if participants are interested, we can add it as an extra (for example, on Friday afternoon).

We now give the participants the passwords for their computers.


==== The Checkmk download

*Note*: We work with the *penultimate* stable version of Checkmk so that we can update to the latest stable version on the last day of the course.

We either provide the participant with the Checkmk software package in any suitable directory, or we download it together from the Checkmk homepage (if there is an account for the training).


==== The installation of Checkmk

Before we start we explain to the participants that Checkmk can have multiple versions and multiple instances on a server at the same time -- and the benefits this brings.

Now we install Checkmk following the [install_packages|instructions in the manual]. Each participant creates an instance that bears his/her first name in lower case. We would like to point out that all examples in the manual use the name `mysite`.

We will then change the password from `cmkadmin` to a password that is known to and the same for all participants.

Next we will show how to log in as an instance user with `omd su`. On the command line we show other things:

* `omd version` and `omd versions`
* Starting and stopping instances
* Displaying instance statuses
* A rough overview of the directory structure. We explain that the instance user has his own directory and where it is found. We only explain the four top-level directories -- `etc`, `tmp`, `var` and `local`. Then we briefly explain the principle of symbolic links to the version directory. We leave out the details: these come in Part 2!


Regarding the `local` directory:

* This directory is (only) for your own modifications to Checkmk, which should take account of any version update.
* Note: With a distributed WATO these files are transferred to all sites by default.
* The directories in `local` are ‘magic’.

Next we log on to the instance as `cmkadmin`, and help the participants so that this works for everyone.

*Note*: We also show the participants what happens (which error messages the browser displays) when

* the instance is not started
* the instance does not exist (or a typing error has been made)

==== An overview of the GUI

We will next show the participants an overview of Checkmk’s GUI:

* How to use the sidebar (scroll, flip, hide and reveal snap-ins)
* How to log out
* How to switch the language to German (and what the consequences are, for example, for a rule search)
* And above all: how you can turn on the cool *Dark Theme*!

*Note 1*: The training will always use the English GUI!

*Note 2*: We are not showing much more just now -- for example, we explain no details about the fields of the [.guihints]#Tactical Overview}},# because we don't have any hosts and services at this point.


=== Adding hosts


==== Hosts, services, agents

Before we get started, we will explain the terms _host_ and _ service _ to the participants. We also give examples where a host is not a real server, but, e.g., a VM or even an AWS object.

We also show the basic states (OK), (WARN), (CRIT), (UNKNOWN), (UP), (DOWN), (UNREACH) and (PENDING). We only discuss that for the parents later however.

Then we explain that you need the Checkmk agent for monitoring Linux, Windows etc., and what the advantages of monitoring with your own agents are.

* No external commands (security)
* Easy extendability by the admin
* You have control of the agent, and you can fix it yourself (which is difficult with WMI for example)

We also briefly mention SNMP, which does not need a Checkmk agent since SNMP already has an agent installed on the device.

We also mention that there are devices with APIs where Checkmk queries these APIs directly using so-called ‘special agents’ (vSphere, cloud services, storage)


==== Folders

We explain to the participants that Checkmk manages the hosts in folders. Then we discuss various structuring options, especially those based on location, technology or organization. We mention the principle that you can inherit properties from the folder without going into the actual details just now.

We provide the following specific folder structure for the training which the participants should set up later:

Top level: Location: Munich and Berlin.

Below the Munich location we create the further subfolders:

* Second level: Technology: Folder: Windows, Linux, Infrastructure
* Third level unter Windows and Linux: directly-create the hosts here
* Third level under Infrastructure: Router, Switches, Storage, Printers

The first exercise for the participants is to create all of these folders.

Now we present the WATO snap-in to the trainees, and say a few words about WATO in general. We then create some folders, and the participants do the same. Everyone decides for themselves which folders they want to create in the training.

==== The first host

Now we install the Checkmk agent for Linux on the Checkmk server itself following the instructions in the [intro#linux|Beginner's Guide]. We also show the trainees where the agent’s corresponding directories are on Linux.

We also show the participants various diagnostic possibilities:

* WATO’s own diagnostic page
* TSelnet on Port 6556 (also shows the Security-Level)
* Calling the agent manually with `check_mk_agent`

We also have a look at the Linux agent’s source code and show some of its structure -- but only briefly.

Now we add the host to the WATO. We also deal with the topic of DNS versus static IP addresses.

* If DNS, then Lookup for Activate Changes, and only once a day (explain the DNS cache and how you can delete it)
* Recommendation: think about the naming scheme beforehand
* Recommendation: specify uniform spelling as this is case-sensitive!
* Warning: changing names later is difficult because this is key to all databases.

We will not present the plug-ins now -- we will do it later when looking at the Hardware/Software (HW/SW) inventory.


==== Adding services

Now we will go to the service page and add all of the services to the monitoring.
We will not not yet discuss the principle of [.guihints]#Disabled Services# or the like.

We *do not* recommend to the participants that they themselves decide which of the services they want to monitor --
we would prefer to sensibly do that later with the [.guihints]#Disabled Services# function.

Then we look at the [.guihints]#Activate Changes# function and explain how that works -- the whole principle of WATO versus the status-world.

We next ask the participants to add more hosts, and to monitor each other while doing so.
We present the ‘Bulk-Import’ function in WATO as well.


=== Monitoring Windows

Now we introduce the Windows agent and monitor a Windows host with the participants. Each participant has access to their own Windows computer (virtual or real) with a freshly-installed Windows.

* We show how to install the agent.
* We show where the directories are on the agent.
* We include the host and its services in Checkmk.
* We show the diagnostic options (e.g., directly-call agents without service)

We won't go into further details about the agent here. In particular we do not yet deal with the plug-ins,
but cover them later with the HW/SW inventory.


=== Monitoring over SNMP

We explain what SNMP is, and what SNMP v1, v2c and v3 are all about. We briefly mention that there are SNMP-Traps, but that we don't need these just now.

We explain:

* The differences between v1 and v2c (64-bit counter)
* That v3 is needed for security
* What a community is, an that you have to activate SNMP on your devices.

For the training course itself we use v2c.

Next we add a host with SNMP into the monitoring. We also show the WATO diagnostic page again.


== Day 2


=== Customizing/extending the Checkmk agent

As you know, the agent can be expanded with plug-ins, which we mentioned to the participants on the first day. Today we show the participants:

* Extension through own local checks
* Extension through MRPE checks
* Packaging customized agents through the Agent Bakery
* Automatic agent updates

==== Local checks

* What are local checks and what can I use them for?
* What do these checks have to output (only lines that provide complete results), and in what syntax?
* What can I use the status ‘P’ for, and what else do I need (metrics with WARN/CRIT threshold values)?
* We make reference to Feature #10566, which from version 1.7. also allows spaces in the service name

==== MRPE Checks

* What exactly does MRPE do? (It runs Nagios plug-ins from remote hosts, for example)
* How can I configure MRPE?

==== The Agent Bakery

First of all we inform the participants that the bakery is only available in the CEE (Free/Standard/Managed Services) editions.

We show the participants how they can configure customized agents via the bakery:

* The integration/baking of the supplied agent plug-ins
* The integration of local checks/MRPE in the agent bakery ({{Deploy custom files with agent}}/{{Execute# MRPE checks}})# 

Finally, we cover the automatic agent updates facility, and we set these up together with the participants:

* Which security features are used with regard to automatic updates? (The communication channels must be known/configured [.guihints]#in advance}})# -- with HTTPS all signing certificates must be included with the configuration (no use of certificates available in the OS, etc).
* The necessary steps as specified in the bakery. Each participant registers his own training computer on his own site.
*  Finally, we provide the participants with important information:

No further manual intervention is necessary.
Make sure that hosts in the AutoUpdate are never offered agents without an Updater plug-in, otherwise this was your last AutoUpdate! ;-)

When changing the Checkmk server certificate (or the signing certificate) -- [.guihints]#before the change# -- configure the new CAs in the AgentUpdater plug-in and wait until all agents are updated so that the new certificate can be verified later!

If the agent signature key is to be changed, then in principle proceed exactly as when changing the certificate: create a new key, define it as valid in the updater plug-in, sign the agent [.guihints]#with the previous key# after all agents have installed an update. The new key can then be used for signing and the previous one can be removed if necessary.
AutoUpdates can (currently) only be made against the master site. A feature extension -- so that this also works against slave sites -- is in the works/testing and is planned for implementation in Checkmk version 1.7.


=== The Graphic Overview

Now that we have a number of hosts in the monitoring, we can deal with the status interface. We present:

* The Tactical Overview, and what the numbers that you can click on are for.
* The [.guihints]#Views# snap-in. What views are there? How are they linked to each other? Even the views with the history!
* The main dashboard, and how to get to it.
* How the bookmarks work.
* Quicksearch with some of its tricks (such as `h:` and `s:`)
* The Master Control and what all of its switches do

Now we’ll show you how to customize the sidebar and add some cool snap-ins. As examples we show:

* WATO-QuickAccess
* Host Matrix
* Folders:This snap-in modifies the scope of the views and dashboard shown on the right. We introduce and explain this snap-in.
* Server Performance and Microcore Statistics

We show how to fold the sidebar in by clicking on the far left. We also show how you can get a view without using a sidebar by clicking on the icons at the end of a view -- or how to get back to the view using a sidebar.


=== Customizing Views

We are now going to take a closer look at the views. We show you how to customize them. First of all, the things you can do directly in the view itself:

* The Refresh Time
* The number of columns
* Sorting by specific column

Next we show how to adapt a view by adding or removing columns, changing the grouping, etc. As an example, in the [.guihints]#All Hosts# view we show how to add a column with the IP addresses and the host’s contact groups.

Second example: permanently remove the inconvenient grouping by host name in the [.guihints]#Service Search# view, and instead add the host name as a column.

Third example: for the [.guihints]#All hosts# view add a service column. For this we take the [.guihints]#Perf-O-Meter# of the service [.guihints]#Check_MK# and the title [.guihints]#Agent}}.# Now you can see for each host how quickly (and whether) the agent can be called up.

We also show how you can set it up that views are visible to other users, and how the visibility of views functions in general.

As well we explain that for global views the best solution is to create a dedicated user for this specific purpose -- for example, a user so authorized so that it can only customize views.


=== Dashboards

Creating your own dashboards in Checkmk is a powerful function, but one that is not easy to learn by yourself. Therefore we are now showing the participants how they can create their own dashboard with their own views and metric graphs. We explain:

* That Checkmk supports dashboards with a dynamic layout, and we excite our participants’ interest in them.
* The three size types fixed (white), yellow arrow and red arrow
* How it works with anchoring in the four corners
* How to add a view or graph directly to the dashboard (and thereby copy them as independent objects)
* How to edit and customize the added views


=== Aktive Checks

Now we show how you can set up active checks, e.g. HTTP or TCP. Of course we need rules for this, however we do not explain rules now, instead we restrict ourselves to explicit hosts as a condition.


=== The Metrics System

As another part of the GUI, we present the metrics system. This is not just the graphs, but also the table of measured values for a service for example. First we explain how the measurement recording basically works.

Now for the operation:

* How do I get to the graphs?
* What interactive options are available? (horizontal zoom, vertical zoom, shifting the time range, clicking on the previews as a time selection, changing the screen size)
* Setting the needle-correlation with other graphs
* The graph collections, and there also the [.guihints]#Export as PDF# button. We would like to point out that the vertical scaling in all graphs is different, and are therefore difficult to compare.
* The Combined Graphs

*Note:* We *don’t* show the custom graphs -- they are treated in CMK-2. The same applies to the tuning of the RRDs (adjusting the aggregation mode).

At the end of the metrics topic we show how the data recording works. And the summary over four levels -- whereby min, max and average are calculated. Storage in special databases (RRD).


== Day 3


=== The operation

Now we deal with a number of operational issues. The first step is to understand all of the different states:

* We revise the basic states (OK), (WARN), (CRIT), (UNKNOWN), (UP), (DOWN), (UNREACH) and (PENDING). However, we only do this for the parents later.
* The [.guihints]#stale# state: What does that mean? How can this occur? For example, an unreachable agent, checks that depend on each other (such as ORACLE checks), timeouts or errors from agent plug-ins, etc.
* The ‘on down host’ status: How are services counted/treated that are on a host that is (DOWN)? Regarding the [.guihints]#Tactical Overview# and the dashboard.
* What is (PEND) and how does it come about? We also explain why some checks need two rounds (counter).
* What is [.guihints]#flapping# (discontinuous)? How does this happen? What are the consequences? And how can you configure it? (e.g., turn it off).

Now we’re going to discuss *Acknowledgments*. First of all, we discuss in general how to trigger commands in views. Once without checkboxes, then with the checkboxes. Then we discuss the acknowledgments:

* What are the effects? Tactical overview, problem view, alarms, etc.
* What are the options? (e.g., sticky and expiration time, persistent comment).
* How can I remove them?
* How can I see what has been acknowledged in the GUI?

Next up are the *Scheduled Downtimes*. First of all: The correct term in English means *scheduled* downtime, and not just downtime, because the latter means _every_ system failure, whether planned or not! In German, _maintenance time_ is the correct term.

We explain the purpose of Downtimes:

* A general communication with colleagues so that they are informed
* The prevention of alarms
* Hiding a non-(OK) status of problems, since these are currently not relevant
* The accurate calculation of availabilities
* Maintenance times are there so that they can be set *beforehand*.

Note: Using a Downtime to ‘acknowledge’ a problem will however prevent you from getting an (OK) message when it is (OK) again!

Then we discuss details:

* Why should you make meaningful comments?
* Where can I see a list of current maintenance times (global, or for an object)?
* How can I delete maintenance times?
* The topic: do I also have to set maintenance times for services when the host is in maintenance? Including the checkbox: Schedule downtimes on the affected hosts instead of on the individual services.

And then the [.guihints]#recurring downtimes# (only the (EE)): How can I set and remove these using commands? Then we say that it makes a lot more sense to make these via rules, because they then also work for hosts that are only later included in the monitoring.


=== Rule-based configuration


==== Rule-based configuration in general

Then we go a little further and show the rule-based configuration. First the theory. This also includes the different ‘match types’, as if there were first, dict, list. We explain the advantages of using tables and template-based systems.

As an example we take the rule for the [.guihints]#CPU Load# under Linux.

Then we create rules for CPU load together with the participants. We show the participant:

* How to find the correct rule chains in different ways (e.g., rule search, route via a certain service, link from the host side in WATO, etc.)
* We show how you can diagnose a rule chain (the green and gray ‘balls’ in WATO).
* We show which rule has priority, and when.
* We show that several rules can also apply together if each rule specifies only one parameter (checkbox).
* We show the participants where it can be found, and exactly how the matching of this special rule chain works.

Then we explain how all of the conditions work:

* Rules that only apply to certain folders.
* Rules that only apply to certain hosts or services (show this exactly with the regexes).
* Conditions for host tags -- whereby we first only work with the predefined tag groups.
* We only mention the label now, and show it later.

We next show the new ‘Predefined Conditions’.


==== Host tags

Now we explain how to create your own tag groups. And that one should not touch existing tag groups. We do not explain the auxiliary tags in more detail.

The participants should now define their own tag groups and practice the whole procedure.

We do not discuss Service Tags here.


==== Labels

Next we introduce the labels for hosts and services. There are three types of labels: automatic, manual, and those that are created by a rule.


=== Tuning the monitoring


==== The motivation for tuning

Our next big goal is to get a ‘clean’ monitoring, thus avoiding faulty conditions (false alarms). We tell the participants that they should first ensure quality, and then quantity. So only pick up a few hosts, make sure that everything is (OK) and remains so (except for the things that really have problems), and only then involve colleagues or expand the whole thing. See also the motivation in [intro#finetuning].


==== File systems

We return to the rule set for file systems, and look at other ways to set up rules intelligently:

* We show the ‘Magic Factor’, and also explain the ‘Reference Drive Size’


==== Hosts permitted to go DOWN

Examples are printers that are switched off at night. We show a practical way you can still monitor such a device effectively, without triggering false alarms by switching it off.

==== Switch ports

As in the beginner’s manual, we show how switch ports can be effectively monitored.

* Monitoring of core and distribution switches: every port in use is monitored
* Access switches: Either only monitor the uplinks or all ports, but then evaluate the link status DOWN as (OK).
* We show how to intelligently configure monitoring using aliases that are configured in the switch (discovery, threshold values)


==== Hosts that reboot

Cushion regular reboots resulting from recurring scheduled downtimes, as described in the beginner’s manual.


==== Logwatch under Windows

This is still missing in the beginner’s manual. We explain to the participants what options they have, so that Logwatch’s Windows event logs do not produce so many false alarms.

. Reclassify all log messages on the Checkmk server as ‘ignore’ (and maintain a positive list on the Checkmk server)
. Remove the services from the monitoring
. Forward the messages to the [ec|Event Console] -- however we only mention this because the Event Console only appears in part 2 of the course.


==== Average values

Several check plug-ins have an option by which threshold values are not based on the latest minute value, but instead an average value of 15 minutes can be used, for example (e.g., CPU usage). This can be used to reduce sporadic false alarms.


==== Predictive Monitoring

We show this as well.


==== Timespecific Parameters

These are also a method for more precise monitoring/evaluation, when for example, CPU usage can go up between 10 p.m. and 10:30 p.m. due to a running job. We also show why this is better than not monitoring at all during this time.


==== Sporadic errors.

If nothing else helps, you can suppress a notification with the [.guihints]#Max Check Attempts# function. We then explain the difference between soft and hard states. The most important area of application here is for avoiding alarms.


==== Parents

We introduce the concept of parents, with which one defines a network topology from the perspective of Checkmk. Parents are actually a prerequisite for a host becoming (UNREACH).

* What is the purpose of the parents (e.g., to avoid multiple alarms)
* We configure parents, also using folder-inheritance
* We show that a host can have multiple parents
* We are now again showing the network card from the dashboards

We briefly address this feature with the parent scan, and that the feature only works on Layer 3.


==== Processes and services

We show how to monitor processes (Windows and Linux), and services (Windows). We first show the manual checks. As an example, we take the case of a virus scanner that should run on every Windows computer, and then we show how to set up a discovery rule so that the services are created automatically.

For Windows we discuss various methods of dealing with the services check as described in the beginner’s manual.



== Day 4


=== Advanced service management


==== Permanently ignoring services

We first explain to the participants that a service can have different configuration states in Checkmk -- the service can be:

* being monitored normally
* available, but is currently not being monitored (undecided)
* available, but is permanently not being monitored (disabled)
* being monitored, but is not currently available (missing)
* statically configured ({{Manual Checks}})# 

Now we show how to move a service back and forth between the first three states. Above all we also show that clicking on the [.guihints]#Move to disabled services# icon actually creates or modifies one rule per host. We show how to generalize this rule by removing the explicit host.

We next show the alternative [.guihints]#Disabled checks# rule set, with which you can switch off entire check types. This can be particularly useful with SNMP devices.

We would again like to point out that in real monitoring it is not a good thing if services are longer in the [.guihints]#undecided# state.


==== Discovery check

We introduce the Discovery check. We’ll also show you how to set this check up to add services automatically. We discuss with the participants the cases for which this procedure makes sense. We explain how this works with the automatic activation of changes, and the effects it has.

==== Bulk discovery

We show the bulk discovery with its various options in WATO.


=== Users and permissions

We introduce users, roles and permissions as described in the beginner’s manual. In addition to the elements in the beginner’s manual, we show:

* How to create your own roles
* The roles and permissions matrix

Then we will also show you how to maintain hosts in WATO as a normal non-admin user. To do this the admin must create folders and enter certain contact groups into the permission.

We show how the various checkboxes for the inheritance of the contact groups in the folders work, and also show the differences between visibility in the status GUI and the permission to edit hosts in a folder in WATO.

We do not show the LDAP connection here. One can point this out, but we do not show it because it is only possible in CMK-2.


=== Notifications

==== Preliminary considerations

We discuss with the participants which events trigger notifications (change of state, maintenance times, etc.). We also show the views in which you can see the events that would have triggered notifications.

Based on the architecture, we show how the notifications are generated by the core and forwarded to the notification module. The following events can be alarmed:

* A change of state (e.g., (OK) → (WARN))
* The change between a steady and an ICON[icon_flapping.png] discontinuous state (flapping)
* The start or end of a ICON[icon_downtime.png] planned maintenance time
* The ICON[icon_ack.png] [basics_ackn|confirmation of a problem] by a user ({{Acknowledgment}})# 
* An notification triggered manually by a ICON[icon_commands.png] [commands|command]
* Execution of an ICON[icon_alert_handlers.png] [alert_handlers|Alerthandlers] (from CEE version Version [1.4.0i2])
* An event that was sent by the ICON[icon_mkeventd.png] [ec|Event Console] for the notification

Then we discuss the configuration properties which influence notifications:

* Maintenance time
* Max Check Attempts
* Acknowledgments with a ‘sticky’ attribute when switching between (WARN) and (CRIT)
* The Main Switch in the Master Control
* Membership of contact groups
* Hosts that are (DOWN) switch off the notifications from the services
* Parents: hosts that are (UNREACH) are -- by default -- not notified

==== Setting up notifications

For the training we install the `postfix` package without a smart host, and then deliver the mails directly to the local users. As the email address we use, for example, `linux@localhost`.

However we explain to the participants that in real life you have to set up a smart host, and show them the command line command with which you can try out sending mail.

First of all, we follow the beginner’s manual. It is important that we have set up the built-in email service of Linux properly, and also show the participants how they can test it.

We also show how you can adjust the notification using your own rules, as described in the main part of the manual.

We show the fallback email address, including the yellow warning from the global settings.

Of course we also show the participants how they can try out notifications:

* The list of the last 10 notifications and the replay function.
* Tests with ‘fake check results’.
* We mention that the log file `notify.log` exists, but without going into very much detail.


==== Time Periods

We show how to define time periods and how these work. Then we show how to use the time periods to configure the notification -- namely:

* In the monitoring configuration ({{Notification Period for Hosts/Services}})# 
* In the notification rules themselves

As examples we define the time periods `workhours`, `nonworkhours`, and another for the holidays by downloading an ical file from the internet.

We would like to point out that it is not a good idea to change the [.guihints]#Check period}}.# If there are time-windows in which the state of a service is uncertain, it is better to work with recurring scheduled downtimes.


=== Distributed monitoring

==== Distributed status views

This point is not included in the beginner’s manual. We do it as in the article on [distributed_monitoring|Distributed Monitoring] in the manual.

In the first step we set up two Checkmk instances by hand and add them to each host. We then connect the second instance via live status -- still without a central WATO -- under the GUI of the first instance, and thus show a distributed monitoring with a decentralized configuration.

We also show the [.guihints]#Site status# sidebar snap-in.

We explain how the Livestatus proxy works. We strongly recommend using it -- also for the local site.

We also show how encryption works and how to set it up.


==== The centralized configuration

In the second step we now switch to a central WATO, and also manage the remote site via the central WATO. We also show that the hosts of the slave site are overwritten. If the question arises about how to migrate the slave site, we say that you could copy the files from `etc/conf.d/wato` by hand, but that goes beyond the scope of the beginner’s course. In case of doubt request support!

Then we show you how to secure the connection via SSL. To do this you have to set up the web server with SSL, and switch the Inter-WATO connection to HTTPS. This is tedious but important!

*Note:* we do not discuss any details or questions about OpenSSL, but only show what you have to do to ensure that it functions correctly. This topic should not take too long either.


== Day 5

=== The Hardware/Software (HW/SW) Inventory

There is currently no article here. We show:

. How do you activate the HW/SW inventory on the Checkmk server (rule)? You don’t see much for the servers yet, but you can see a lot for SNMP devices.
. Now install the inventory plug-in for our Linux servers.
. Next we show how then installation works under Windows.
. We show how you can see the inventory data on the GUI -- namely the tree-like representation.
. Then we show the tabular views, e.g., that of the switch ports or of the installed software
. We show how you can see the history of any hardware and software changes in the GUI (we simulate changes, e.g., by installing packages)
. We show how Checkmk automatically creates host labels based on this data.


=== A recap of configuration

We will now again discuss which folder and tag structure makes sense for a particular purpose.

We show the WATO page with the ‘Best Practices’ check.


=== Backup & Restore

We show how to back up a Checkmk instance with `omd backup` and `omd restore`. While doing so, we also show the `--no-rrds` and `--no-logs` and `-N` options. And then we will show you how to set up automatic backup jobs directly in WATO.

Then we point out that the WATO backup module does not work in distributed environments -- it only backs up the master site.

=== Updating Checkmk

Normal update: Now we update to the latest stable version. We explain that an upgrade from (CFE) works in the same way. If any of the participants already uses the (CRE), we explain how an update to the (EE) works.

Deinstallation of no longer needed Checkmk versions.


=== Collecting aggregation metrics data

Now it is Friday, and we have data from the last five days. We can again show the differences between the three different functions -- min/max/avg -- in the graphs.

* Click on the min, max, average columns. Why do the curves in the display change?

== Feedback and criticism


*Here we collect feedback from our training partners*.

=== Robert Sander

Hello,

Here is a quick first feedback from Part 1 of the training course from last week:

Most participants were considerably surprised by the recent changes in the content. In particular they missed Local Checks and the Agent Bakery, as some of them had signed up for it.

We then had plenty of time in the process. The content for Tuesday was already finished by around 14:00, so I simply added the local checks. And on Friday there was enough time for the bakery and the updater.

I would advocate leaving these two topics in Part 1, as Local Checks (and MRPE) help people a lot to individually monitor their infrastructures. And the bakery also helps the admin tremendously.

In Part 2 there are still enough advanced topics.


=== Karl Deutsch

* I just think it’s a shame that classic beginner’s topics such as PDF reporting and NagVis did not change in Part 1.
* Re-include agent *Bakery* (without updater) and local checks in Part 1
