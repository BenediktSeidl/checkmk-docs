
= Writing your own check plug-ins
:revdate: draft
[.seealso][#localchecks] [#agent_linux] [#agent_windows] [#cmk_commandline] [#legacy_writing_checks] [#mkps] [#simulation_mode] [#snmp] [#wato_monitoringagents] [#wato_services]
== Introduction



(CMK) includes nearly 2000 ready-made check plug-ins for all imaginable hardware and software.
These are maintained by the Checkmk team, and new plug-ins are added every week.
On the <a href="https://exchange.checkmk.com">Checkmk-Exchange</a>
there are also more plug-ins contributed by our users.

And yet there are always situations where a device, an application,
or just a specific metric that is important to you is not covered by any of
these plug-ins - maybe because it is something that was developed within your own company
and is therefore not available to anyone else.


=== Does it always have to be a real plug-in?


What options do you have for implementing an effective monitoring here?
Well - you could of course contact our <a href="https://checkmk.de/support.html">support team</a>
and request that they develop a suitable plug-in for you - but naturally it's quicker
if you can do it yourself.
You have three options:

[cols=, options="header"]
|===

|``
NL:`name`: Der Name des Checkplugins. Wenn Sie keinen Ärger bekommen möchten, nehmen Sie hier den gleichen Namen wie bei Ihrer neuen Agentensektion. Damit weiß der Check automatisch, welche Sektion er auswerten soll.
NL:`service_name`: Der Name des Services wie er dann im Monitoring erscheinen soll.
NL:`discovery_function`: Die Funktion zum Erkennen von Services dieses Typs (dazu gleich mehr).
NL:`check_funktion`: Die Funktion zum Durchführen des eigentlichen Checks (auch dazu gleich mehr).

Für unseren Check sieht das dann also so aus:

F+:
register.check_plugin(
    name = "linux_usbstick",
    service_name = "USB stick",
    discovery_function = discover_linux_usbstick,
    check_function = check_linux_usbstick,
)
F-:

Versuchen Sie am besten noch nicht, das gleich auszuprobieren, denn natürlich
müssen wir die Funktionen `discovery_linux_usbstick` und `check_linux_usbstick`
vorher noch schreiben. Und diese müssen im Quellcode _vor_ obiger Deklaration
erscheinen.


H2:Die Discovery-Funktion schreiben

Eine Besonderheit von (CMK) ist die automatische Erkennung von zu
überwachenden Services. Damit dies klappt, muss jedes Checkplugin eine
Funktion definieren, welche anhand der Agentenausgaben erkennt, _ob_ ein Service
dieses Typs bzw. _welche_ Services des Typs für den betreffenden Host
angelegt werden sollen.

Die Discovery-Funktion wird immer dann aufgerufen, wenn für einen Host
die Serviceerkennung durchgeführt wird. Sie entscheidet dann ob, bzw.
welche Services angelegt werden sollen. In Standardfall bekommt sie genau
ein Argument mit dem Namen `section`. Dieses enthält die Daten
der Agentensektion in einem geparsten Format (dazu später mehr).

Wir implementieren folgende simple Logik: _Wenn_ die Agentensektion
`linux_usbstick` vorhanden ist, dann legen wir auch einen passenden
Service an. Dann erscheint dieser automatisch auf allen Hosts, wo unser
Agentenplugin ausgerollt ist. Das Vorhandensein der Sektion erkennen wir
ganz einfach daran, dass unsere Discovery überhaupt aufgerufen wird!

Die Discovery-Funktion muss Für jeden anzulegenden Service mittels
`yield` ein Objekt vom Typ `Service` zurückgeben (nicht mit
`return`). Bei Checks, die pro Host nur einmal auftreten können,
benötigt man keine weitere Angaben:

F+:
def discovery_linux_usbstick(section):
    yield Service()
F-:

H2:Die Check-Funktion schreiben

Somit können wir nun zur eigentlichen Check-Funktion kommen, welche anhand
aktueller Agentenausgaben endlich entscheidet, welchen Zustand ein Service
annehmen soll. Da unser Check keine Parameter hat und es auch immer nur
einen pro Host gibt, wird unsere Funktion ebenfalls mit dem einzigen
Argument `section` aufgerufen.

Da wir diesmal den Inhalt auch wirklich brauchen, müssen wir uns
mit dem Format dieses Arguments befassen. Solange Sie keine explizite
[devel_check_plugins#parsefunction|Parse-Funktion] definiert haben, zerlegt
(CMK) jede Zeile der Sektion anhand von Leerzeichen in eine _Liste von
Worten_. Das Ganze wird dann wiederum eine Liste dieser Wortlisten. Als
Endergebnis haben wir also immer eine Liste von Listen.

Im einfachen Fall, dass unserer Agentenplugin nur zwei Devices findet,
sieht das dann z.B. so aus (hier gibt es pro Zeile nur ein Wort):

F+:
[['ata-APPLE_SSD_SM0512F_S1K5NYBF810191'], ['wwn-0x5002538655584d30']]
F-:

Die Checkfunktion geht nun Zeile für Zeile durch und sucht nach
einer Zeile, deren erstes (und einziges) Wort mit `usb-SCSI_DISK` beginnt.
Wenn das der Falll ist, wird der Zustand (CRIT).
Hier ist die Implementierung:

F+:
def check_linux_usbstick(section):
    for line in section:
        if line[0].startswith("usb-SCSI_DISK"):
            yield Result(state=state.CRIT, summary="Found USB stick")
            return
    yield Result(state=state.OK, summary="No USB stick found")
F-:

Und hier die Erklärung:
LI:Mit `for line in section` gehen wir in einer Schleife alle Zeilen der Agentenausgabe durch.
LI:Dann prüfen wir, ob das erste Wort der Zeile -- das jeweilige Gerät -- mit `usb-SCSI_DISK` beginnt.
LI:Falls ja, erzeugen wir ein Check-Resultat mit dem Status (CRIT) und dem Text `Found USB stick`. Und wir beenden dann die Funktion mit einem `return`.
LI:Falls die Schleife durchlaufen wird, ohne etwas zu finden, erzeugen wir den Status (OK) und den Text `No USB stick found`.

H2:Die Discovery testen

COMMENT[Das hier schreibe ich, sobald die Ausgabe von cmk -v aufgeräumt ist.]

H2:Den Check testen

COMMENT[Das hier schreibe ich, sobald die Ausgabe von cmk -v aufgeräumt ist.]

H2:Das ganze Plugin auf einen Blick

Und hier ist das ganze Plugin nochmal komplett:

F+:local/lib/check_mk/base/plugins/agent_based/linux_usbstick.py
from .agent_based_api.v1 import *

def discover_linux_usbstick(section):
    yield Service()

def check_linux_usbstick(section):
    for line in section:
        if line[0].startswith("usb-SCSI_DISK"):
            yield Result(state=state.CRIT, summary="Found USB stick")
            return
    yield Result(state=state.OK, summary="No USB stick found")

register.check_plugin(
    name = "linux_usbstick",
    service_name = "USB stick",
    discovery_function = discover_linux_usbstick,
    check_function = check_linux_usbstick,
)
F-:

Und das hier war das Plugin für den Linuxagenten:

F+:/usr/lib/check_mk_agent/plugins/linux_usbstick
#!/bin/sh
echo '<<<linux_usbstick>>>'
ls /dev/disk/by-id/ | grep -v -- -part
F-:

H1:Checks mit mehr als einem Service pro Host (Items)

H2:Grundprinzip

In unserem Beispiel haben wir einen sehr einfachen Check gebaut, der auf
einem Host einen Service erzeugt -- oder eben nicht. Ein sehr üblicher Fall
ist aber natürlich auch, dass es von einem Check mehrere Services auf einem
Host geben kann.

Das häufigste Beispiel dafür sind die Dateisysteme eines Hosts. Das Plugin
mit dem Namen `df` legt pro Dateisystem auf dem Host einen Service
an. Um diese Services zu unterscheiden, wird der Mountpunkt des Dateisystems
(z.B. `/var`) bzw. der Laufwerksbuchstabe (z.B. `C:`)
in den Namen des Services eingebaut.  Das ergibt dann als Servicename
z.B. `Filesystem /var` oder `Filesystem C:`. Das Wort
`/var` bzw. `C:` wird hier als _Item_ bezeichnet. Wir
sprechen also auch von einem Check _mit Items_.

Wenn Sie einen Check mit Items bauen möchten, müssen Sie folgende
Dinge umsetzen:

LI:Die Discovery-Funktion muss die Liste der Items generieren, die auf dem Host sinnvollerweise überwacht werden sollen.
LI:Im Servicenamen müssen Sie das Item mithilfe des Platzhalters `%s` einbauen (also z.B. `"Filesystem %s"`).
LI:Die Check-Funktion wird pro Item einmal separat aufgerufen und bekommt dieses als Argument. Sie muss dann aus den Agentendaten die für dieses Item relevanten Daten herausfischen.

H2:Ein einfaches Beispiel

Um das ganze praktisch ausprobieren zu können, bauen wir uns einfach
eine weitere Agentensektion, die nur Spieldaten ausgibt. Dazu genügt ein
kleines Shellskript. Die Sektion soll hier im Beispiel `foobar` heißen:

F+:/usr/lib/check_mk_agent/plugins/foobar
#!/bin/sh
#!/bin/sh
echo "<<<foobar>>>"
echo "West 100 100"
echo "East 197 200"
echo "North 0 50"
F-:

Von _Foobar_ gibt es hier drei Sektionen: `West`, `East`
und `North` (was immer auch das bedeuten mag). In jeder Sektion gibt
es eine Anzahl von _Plätzen_ von denen einige belegt sind (z.B. sind
in `West` 34 von 180 Plätzen belegt).

Nun legen wir dazu ein passendes Checkplugin an. Die Registrierung ist wie
gehabt, allerdings mit dem wichtigen Unterschied, dass der Servicename jetzt
genau einmal ein `%s` enthält. An dieser Stelle wird später dann von
(CMK) der Name des Items eingesetzt:

F+:
register.check_plugin(
    name = "foobar",
    service_name = "Foobar Sector <b class=hilite>%s*",
    discovery_function = discover_foobar,
    check_function = check_foobar,
)
F-:

Die Discovery-Funktion hat jetzt die Aufgabe, die zu überwachenden Items zu
ermitteln. Wie gehabt bekommt sie das Argument `section`.  Und auch hier
handelt es sich um eine Liste von Zeilen, welche ihrerseits wiederum Listen
von Worten sind. Diese sieht in unserem Beispiel aus aus:

F+:
[['West', '100', '100'], ['East', '197', '200'], ['North', '0', '50']]
F-:

So eine Liste kann man mit Python prima in einer Schleife
durchlaufen und den drei Worten pro Zeile gleich sinnvolle Namen geben:

F+:
for sector, used, slots in section:
    ...
F-:

In jeder Zeile ist das erste Wort -- hier der Sektor -- unser Item.
Immer wenn wir ein Item gefunden haben, geben wir das mit `yield` zurück,
wobei wir ein Objekt vom Typ `Service` erzeugen, welches den Sektornamen
als Item bekommt. Die beiden andere Spalten in der Ausgabe sind uns erstmal
egal, denn bei der Discovery ist es schließlich unerheblich, wieviele Slots
belegt sind. Insgesamt sieht das dann so aus:

F+:
def discover_foobar(section):
    for sector, used, slots in section:
        yield Service(item=sector)
F-:

Es wäre natürlich ein Leichtes, hier anhand von beliebigen Kriterien manche
Zeilen auszulassen. Vielleicht gibt es ja Sektoren, welche die Größe 0 haben
und die man grundsätzlich nie überwachen möchte? Lassen Sie solche Zeilen
einfach aus und yielden Sie dafür kein Item.

Wenn dann später der Host überwacht wird, dann wird die Check-Funktion
für jeden Service -- und damit für jedes Item -- separat aufgerufen. Sie
bekommt deswegen zusätzlich zur Sektion das Argment `item` mit dem
jeweils gesuchten Item. Jetzt gehen wir wieder alle Zeilen der Reihe nach
durch. Dabei suchen diejenige Zeile heraus, die zum gewünschten Item gehört:

F+:
def check_foobar(item, section):
    for sector, used, slots in section:
        if sector == item:
            ...
F-:

Jetzt fehlt nur noch die eigentliche Logik, welche festlegt, wann das Ding denn überhaupt (OK),
(WARN) oder (CRIT) sein soll. Wir machen es hier so:

LI:Wenn alle Slots belegt sind, soll das Ding (CRIT) werden.
LI:Wenn weniger als 10 Slots frei sind, dann wird es (WARN).
LI:Ansonsten (OK)

Die belegten und insgesamten Slots kommen ja immer als Wort zwei und drei
in jeder Zeile. Aber: es handelt sich hier um Strings, nicht um Zahlen.
Diese brauchen wir aber, um vergleichen und rechnen zu können. Daher
wandeln wir die Strings mit `int()` in Zahlen um.

Das Checkergebnis liefern wir dann, indem wir ein Objekt vom Typ `Result`
per `yield` liefern. Dieses benötigt die Parameter `state` und
`summary`:

F+:
def check_foobar(item, section):
    for sector, used, slots in section:
        if sector == item:
            used = int(used)   # convert string to int
            slots = int(slots)   # convert string to int
            if used == slots:
                s = state.CRIT
            elif slots - used < 10:
                s = state.WARN
            else:
                s = state.OK
            yield Result(
                state = s,
                summary = f"used {used} out of {slots} slots")
            return
F-:

Dazu noch folgende Hinweise:

NL:Der Befehl `return` sorgt dafür, dass die Check-Funktion nach dem Bearbeiten des gefundenen Items sofort abgebrochen wird. Es gibt schließlich auch nichts mehr weiter zu tun.
NL:Wird die Schleife durchlaufen, ohne das gesuchte Item zu finden, so erzeugt (CMK) _automatisch_ das Resultat `UNKNOWN - Item not found in monitoring data`. Das ist so gewollt und gut so. Behandeln Sie diesen Fall nicht selbst. Wenn sie ein gesuchtes Item nicht finden, so lassen sie Python einfach aus der Funktion rauslaufen und (CMK) seine Arbeit erledigen.
NL:Mit dem Argument `summary` definieren Sie den Text, den der Service aus Statusausgabe produziert. Er ist rein informell und wird von (CMK) nicht weiter ausgewertet.

COMMENT[Die folgenden Ausgaben sind gefaket. Hier muss im CMK noch die Ausgabe gefixt werden.]

Probieren wir jetzt zunächst die Discovery aus. Der Übersicht halber beschränke ich das
ganze mit der Option `--checks=foobar` auf unser Plugin:

C+:
OM:cmk --checks=foobar -vI myhost123
  <b class=green>3* foobar
SUCCESS - Found 3 services, 1 host labels
C-:

Und jetzt können wir auch gleich das Checken ausprobieren (ebenfalls auf
`foobar` begrenzt):

C+:
OM:cmk --checks=foobar -v myhost123
Foobar Sector East   <b class=yellow>WARN - used 197 out of 200 slots*
Foobar Sector North  <b class=green>OK - used 0 out of 50 slots*
Foobar Sector West   <b class=red>CRIT - used 100 out of 100 slots*
C-:


H2:Beispiel komplett

Und hier nochmal das ganze Beispiel komplett. Damit es keine Fehler wegen nicht definierter Funktionsnamen gibt,
müssen die Funktionen immer vor dem Registrieren definiert werden.


F+:local/lib/check_mk/base/plugins/agent_based/foobar.py
from .agent_based_api.v1 import *
import pprint

def discover_foobar(section):
    for sector, used, slots in section:
        yield Service(item=sector)

def check_foobar(item, section):
    for sector, used, slots in section:
        if sector == item:
            used = int(used)    # convert string to int
            slots = int(slots)  # convert string to int
            if used == slots:
                s = state.CRIT
            elif slots - used < 10:
                s = state.WARN
            else:
                s = state.OK
            yield Result(
                state = s,
                summary = f"used {used} out of {slots} slots")
            return

register.check_plugin(
    name = "foobar",
    service_name = "Foobar Sector %s",
    discovery_function = discover_foobar,
    check_function = check_foobar,
)
F-:

H1:Messwerte

H2:Werte in der Checkfunktion ermitteln

Nicht immer, aber oft befassen sich Checks mit Zahlen. Mit seinem [graphing|Graphingsystem]
hat (CMK) eine Komponente, um solche Zahlen zu speichern, auszuwerten und darzustellen. Das
geht dabei völlig unabhängig von der Berechnung der Zuständige (OK), (WARN) und (CRIT).

Solche Messwerte -- oder auch Metriken genannt -- werden von der Checkfunktion ermittelt
und einfach als zusätzliches Ergebnis zurückgegeben. Dazu dient das Objekt `Metrik`,
welches mindestens die beiden Argument `name` und `value` benötigt.
Hier ist ein Beispiel:

F+:
    yield Metrik(name="fooslots", value=used)
F-:

H2:Informationen zu den Schwellwerten

Weiterhin gibt es noch zwei optionale Argumente. Mit dem Argument `levels` können Sie eine Information
zu Schwellwerten für (WARN) und (CRIT) mitgeben, und zwar in Form eines Paares von zwei Zahlen.
Diese wird dann üblicherweise im Graphen als gelbe und rote Linie eingezeichnet. Die erste Zahl
steht für die Warnschwelle, die zweite für die kritische. Dabei gilt die Konvention, dass der Check beim
Erreichen der Warnschwelle bereits auf (WARN) geht (bei (CRIT) analog).

Das sieht dann z.B. so aus (hier mit hartkodierten Schwellwerten):

F+:
    yield Metrik(name="fooslots", value=used, levels=(190,200))
F-:

Hinweise:

LI:Falls nur eine der beiden Schwellen definiert ist, tragen Sie für die andere einfach `None` ein, also z.B. `levels=(None, 200)`.
LI:Es sind auch Fließkommazahlen erlaubt, aber keine Strings.
LI:Achtung: für die _Überprüfung_ der Schwellwerte ist die Checkfunktion selbst verantwortlich.  Die Angabe von `levels` dient lediglich als Randinformation für das Graphingsystem!


H2:Der Wertebereich

Analog zu den Schwellwerten können Sie dem Graphingsystem auch die Information über
den möglichen Wertebereich mitgeben. Damit ist der kleinste und größte mögliche Wert
gemeint. Das geschieht im Argument `boundaries`, wobei auch hier optional
für eine der beiden Grenzen `None` eingesetzt werden kann. Beispiel:

F+:
    yield Metrik(name="fooslots", value=used, boundaries=(0, 200))
F-:

Und jetzt unsere Checkfunktion aus dem obigen Beispiel nochmal, aber
diesmal mit der Rückgabe von Metrikinformation inklusive Schwellwerte und
Wertebereich (diesmal natürlich nicht mit fixen sondern mit berechneten Werten):

F+:
def check_foobar(item, section):
    for sector, used, slots in section:
        if sector == item:
            used = int(used)    # convert string to int
            slots = int(slots)  # convert string to int

*            yield Metric(*
*                name="fooslots",*
*                value=used,*
*                levels=(slots-10, slots),*
*                boundaries=(0, slots))*

            if used == slots:
                s = state.CRIT
            elif slots - used < 10:
                s = state.WARN
            else:
                s = state.OK
            yield Result(
                state = s,
                summary = f"used {used} out of {slots} slots")
            return
F-:

COMMENT[Irgendwo müssen wir noch schreiben, dass man cmk -R braucht, damit der Check auch im laufenden CMK funktioniert. Bzw. überhaupt zeigen, wie das mit der Kommandozeile und dem System interagiert. Das cmk -R braucht man vor allem, um dann die metriken auszuprobieren.]
COMMENT[Die Option -p wäre noch nützlich zu zeigen hier]
COMMENT[Hinweise darauf, dass die Definition von Graphen etc. später kommt und dass man den Defaultgraph bekommt]
COMMENT[Hinweis, welchen Namen man für seine Metrik nehmen soll!]


H1:Weitere Aspekte

In diesem Artikel werden in Zukunft noch weitere Aspkete der Pluginentwicklung besprochen
werden. Die wichtigsten sind:

LI:Ausgeben von Metriken (noch ohne Graphdefinitionen)
LI:Fehlerbehandlung
LI:Teilresultate, Summary und Details
LI:SNMP-basierte Checks
LI:Schwellwerte und andere Checkparameter

Und diese hier werden später auch noch beschrieben:

LI:Die Renderfunktionen (korrekte Darstellung von Zahlen)
LI:Checks im Cluster
LI:Checks mit einem Regelsatz, welche die Discovery steuert
LI:Counter und andere persistierte Daten
LI:Host- und Servicelabels erzeugen
LI:Includefunktionen, geteilter Code
LI:Definition von Perf-O-Metern, Graphtemplates, Metriken
LI:Manpages schreiben
LI:Checks, die mehr als eine Sektion verwenden
LI:Deklaratoren in den Sektionen, z.B. `sep(...)`.
LI:Mehrere Checks für die gleiche Sektion
LI:Ein Check, der mehrere Sektionen auswertet

H1:Ausblick

Wenn das klappt, sind Sie eigentlich fertig. Sie können das Ganze aber noch
um etliche Zusatzfeatures erweitern, wie zum Beispiel:

LI:Definitionen für die von den Services gelieferten [graphing|Messdaten], damit schöne und gut beschriftete Graphen und „Perf-O-Meter“ erzeugt werden.
LI:Ein Regelsatz, mit dem Sie die Parameter des Checkplugins konfigurieren können.
LI:Ein Regelsatz, welcher das Agentenplugin für die [wato_monitoringagents#bakery|Agentenbäckerei] konfiguriert.
LI:Ein Regelsatz, mit der der Spezialagent konfiguriert werden kann.
LI:Eine Manualpage, welche das Checkplugin für den Anwender dokumentiert.
LI:Ein [mkps|MKP-Paket], in welchem das Plugin paketiert und einfach installierbar ist.

Artikel dazu folgen hier in Kürze...

### H1:Komplexe Agentenausgaben mittels Parsefunktion bändigen#parsefunction
### Der nächste Schritt ist die sogenannten _Parse-Funktion_. Diese
### hat die Aufgabe, die „rohen“ Agentendaten zu parsen und in eine logisch
### aufgeräumte Form zu bringen, die für alle weiteren Schritte einfach
### zu verarbeiten ist. Konvention ist, dass diese nach der Agentensektion
### benannt wird und mit `parse_` beginnt. Sie bekommt als einziges
### Argument `string_table`. Bitte beachten Sie, dass Sie hier nicht
### frei in der Wahl des Arguments sind. Es muss wirklich so heißen.
###
### Wir schreiben unsere Parse-Funktion jetzt erstmal so, dass wir einfach
### nur die Daten, die sie bekommt, auf der Konsole ausgeben. Dazu nehmen
### wir einfach die `print`-Funktion (Achtung: seit Python 3 sind
### hier Klammern zwingend notwendig):
###
### F+:
### def parse_linux_usbstick(string_table):
###     print(string_table)
### F-:
###
### Damit das Ganze irgendetwas bewirken soll, müssen wir unsere Parse-Funktion
### und überhaupt die neue Agentensektion bei (CMK) bekannt machen. Dazu
### rufen wir eine Registrierfunktion auf:
###
### F+:
### register.agent_section(
###     name = "linux_usbstick",
###     parse_function = parse_linux_usbstick,
### )
### F-:
###
### Hier ist es wichtig, dass der Name der Sektion wirklich exakt mit dem
### Sektionsheader in der Agentenausgabe übereinstimmt. Insgesamt
### sieht das jetzt so aus:
###
### F+:local/lib/check_mk/base/plugins/agent_based/linux_usbstick.py
### from .agent_based_api.v1 import *
###
### def parse_linux_usbstick(string_table):
###     print(string_table)
###
### register.agent_section(
###     name = "linux_usbstick",
###     parse_function = parse_linux_usbstick,
### )
### F-:
###
### Wir haben jetzt gewissermaßen das einfachste mögliche Plugin gebaut, was noch
### keinen wirklich Nutzen hat, aber das wir immerhin schon testen können.  Dazu
### stoßen wir auf der Kommandozeile eine Serviceerkennung (Option `-I`)
### von dem Host an, dessen Agenten wir vorhin präpariert haben. _Wenn_
### dessen Ausgabe auch wirklich eine Sektion `linux_usbstick` enthält,
### dann müssten wir unsere Debugausgabe sehen:
###
### C+:
### OM:cmk -I myhost123
### [['ata-APPLE_SSD_SM0512F_S1K5NYBF810191'], ['wwn-0x5002538655584d30']]
### C-:
###
### Etwas übersichtlicher wird die Ausgabe, wenn wir das einfache `print`
### durch ein Pretty-print aus dem Modul `pprint` ersetzen. Das ist für
### alle weitere Debugausgaben sehr empfehlenswert:
###
### F+:local/lib/check_mk/base/plugins/agent_based/linux_usbstick.py
### from .agent_based_api.v1 import *
### *import pprint*
###
### def parse_linux_usbstick(string_table):
###     *pprint.pprint(string_table)*
###
### register.agent_section(
###     name = "linux_usbstick",
###     parse_function = parse_linux_usbstick,
### )
### F-:
###
### Das sieht dann so aus:
###
### C+:
### OM:cmk -I myhost123
### [['ata-APPLE_SSD_SM0512F_S1K5NYBF810191'],
###  ['wwn-0x5002538655584d30']]
### C-:
###
###
### H2:Die Parse-Funktion schreiben
###
### Wenn Sie genau hinsehen, dann erkennen Sie, dass es sich hier verschachtelte
### Listen handelt. Im Argument `string_table` bekommen Sie eine Liste,
### welche _pro Zeile_ der Agentenausgabe eine Liste von _Worten_
### beheinhaltet. Dabei werden die Zeilen an Folgen von Leerzeichen getrennt. Da
### unsere Sektion pro Zeile nur ein Wort enthält, bestehen ergo die inneren
### Listen aus nur jeweils einem Eintrag.
###
### Folgendes Beispiel macht die Struktur noch etwas klarer:
###
### F+:local/lib/check_mk/base/plugins/agent_based/linux_usbstick.py
### from .agent_based_api.v1 import *
### import pprint
###
### def parse_linux_usbstick(string_table):
###     print("Number of lines: %d" % len(string_table))
###     print("Number of words in first line: %d" % len(string_table[0]))
###     print("Length of first word: %d" % len(string_table[0][0]))
###
### register.agent_section(
###     name = "linux_usbstick",
###     parse_function = parse_linux_usbstick,
### )
### F-:
###
### Die Ausgabe sieht dann so aus:
###
### C+:
### OM:cmk -I myhost123
### Number of lines: 3
### Number of words in first line: 1
### Length of first word: 36
### C-:
###
### Für unser Beispiel benötigen wir einfach nur eine einfache Liste der Devicenamen.
### Also machen wir unsere Parse-Funktion so, dass sie aus jeder Zeile das eine Wort
### auspackt und in eine hübsche neue Liste verpackt:
###
### F+:
### def parse_linux_usbstick(string_table):
###     parsed = []
###     for line in string_table:
###         parsed.append(line[0])
###     pprint.pprint(parsed)
### F-:
###
### Die Debugausgabe sieht dann so aus (bitte schauen Sie genau hin, es
### gibt jetzt nur noch ein einziges paar eckiger Klammern):
###
### F+:
### ['ata-APPLE_SSD_SM0512F_S1K5NYBF810191',
###  'wwn-0x5002538655584d30']
### F-:
###
### Damit die Parse-Funktion vollständig ist, müssen wir jetzt noch die
### Debugmeldung entfernen und -- ganz wichtig -- das Ergebnis mit
### `return` zurückgeben:
###
### F+:
### def parse_linux_usbstick(string_table):
###     parsed = []
###     for line in string_table:
###         parsed.append(line[0])
###     *return parsed*
### F-:

|===



|Method
|How to do it
|Advantages
|Disadvantages


|[localchecks|Localcheck]
|Extend a (CMK) Agent with a simple script
|Is very simple, is possible in all programming languages offered by the monitored host’s operating system, even supports service detection
|Threshold configuration only for the agent itself, SNMP not possible or very cumbersome


|Nagios-compatible check plug-in 
|Run the plug-in via _MRPE_ from the [agent_windows#mrpe|Windows] or [agent_linux#mrpe|Linux] agent. 
|Access to all existing Nagios plug-ins, also free choice of the programming language
|Threshold configuration only for the agent itself, SNMP not possible or very cumbersome, no service discovery possible


|Genuine (CMK) plug-in
|Explained here in the manual
|Inserts itself 100% into (CMK), automatic service recognition, central configuration of the thresholds via WATO, very high performance, supports SNMP, automatic host and service labels possible, supports [inventory|HW/SW inventory], (CMK) provides a lot so you do not have to program standard functions yourself. Only a real plug-in has a chance to become part of the official (CMK).
|Requires more training and knowledge of the Python programming language


|log messages
|Monitor _messages_ with the [ec|Event Console]
|No development necessary, but only need to set up rules in the Event Console
|All of the disadvantages of event-based monitoring compared to state-based: no current status, no metrics, no configurable thresholds - you do not know for sure whether any messages actually be received.

|===


This article will show you how to develop real Checkmk check plug-ins - along with everything that goes with them.
Here we show you how to use the newly-developed API for programming plug-ins in version VERSION[1.7.0] of Checkmk.
If you want to develop plug-ins that will work on legacy Checkmk versions you can refer to
[legacy_writing_checks|previous manuals].
However these have not been maintained for some time and are only available in English.


=== Different types of check plug-ins


Before we jump into action, let's first review the different types of check plug-ins that CMK works with:

[cols=, ]
|===


|Agent-based
|The ‘normal’ plug-ins evaluate data that the (CMK) agent sends for Linux, Windows or other operating systems. This agent monitors operating system parameters and applications, and sometimes also server hardware. Each new check plug-in requires an extension of the agent to provide the necessary data. Therefore you first develop an agent plug-in, and then one or more check plug-ins that evaluate this data.


|SNMP
|When monitoring via [snmp|SNMP] you do not need an extension of an agent, but evaluate the data that your device retrieves data from your device via SNMP, which provides this by default. (CMK) supports you and takes over all details and special features of the SNMP protocol.


|Special Agent
|You need a special agent if you do not receive the data that is relevant for monitoring from either the normal (CMK) agent or SNMP. The most common application for Special Agent is querying HTTP-based APIs. Examples are, e.g. Monitoring [monitoring_aws|AWS], [monitoring_azure|Azure], or [monitoring_vmware|VMware]. In this case you write a script that runs directly on the (CMK) server, connects to the API, and outputs data in the same format as an agent plug-in would. For this you write suitable check plug-ins in the same way as with the ‘agent-based’ monitoring.


|Active Check
|This check type forms a special role. Here you first write a classic Nagios-compatible plug-in which is intended for execution _on the (CMK) server_, and which from there uses a network protocol to directly query a service on the target device. The most prominent example is the `check_http` plug-in which allows you to monitor web servers and web pages. You can then integrate this plug-in into (CMK) so that it can be set up as usual via WATO.

|===



=== Prerequisites


If you feel like programming check plug-ins, you need to satisfy the following prerequisites:

* Knowledge of the Python programming language, or at least experience in a similar language (such as PHP, Ruby, Java, etc.), along with the desire to become familiar with Python.
* Experience with Checkmk, especially with regard to agents and checks
* Experience with Linux on the command line

As preparation, the following articles are recommended:

IN:wato_services
IN:wato_monitoringagents
IN:snmp
IN:agent_windows
IN:agent_linux
IN:cmk_commandline
IN:mkps
IN:simulation_mode


=== Steps to your own plug-in


Typically, there are the following phases that you go through when writing your own plug-in:

. *Getting data:* Find out how to actually get the status data you want to monitor. Which command line commands, SNMP paths or API calls provide the necessary raw data? That is sometimes the hardest job.
. *Extending the agent:* You now write a plug-in for the agent with the correct commands — or a special agent to get the API. SNMP eliminates this step.
. *The Check plug-in:* Now write the actual check plug-in which analyzes the data and, based on this, recognizes services and generates their status.

If that works, you are done — but you can also extend the whole process with several additional features:

* Definitions of the [graphing|metrics] provided by the services to produce beautiful and well-labelled graphs and perf-o-meters.
* A set of rules for WATO that you can use to configure check plug-in parameters.
* A ruleset for WATO that configures the agent plug-in for the [wato_monitoringagents#bakery|Agent Bakery].
* A ruleset for WATO that configures the special agent.
* A manual page that documents the check plug-in for the user.

== This article is not finished yet

Now you are probably wondering why this article ends here. The main reason is that we are currently
working on a major overhaul and improvement of the programming API for check plugins. As soon as it is
finalized, we will rewrite this article -- and many more articles on programming extensions. The plan
is that this will be finished with the release of Checkmk version VERSION [1.7.0].

Until then, we ask for a little patience!

### Weiteres Vorgehen:
###
### 1. Beispiel mit Agent: Wieder mit smartctl -A /dev/sda. Erstmal ohne Item. Nur eine Platte, die hartkodiert ist.
### Und ein Check mit der Temperatur mit festen Schwellwerten. Hinweis, dass es das schon gibt, natürlich.
### Vorgehen ziemlich wie legacy_devel_agentbased.
###
### 2. Erst jetzt kommt das Item. Also Plugin anpassen. Discoveryfunktion anpassen. Description anpassen.
###
### --> Sollen wir hier den Sack zumachen und jetzt auf der Ebene SNMP vorstellen?
###
### 3. Parameter: Wie sollen wir es machen, da wir ja keine main.mk mehr zulassen möchten. Wie kann man
### das ohne WATO-Regel machen? Sollen wir wirklich mit der main.mk rummachen? Oder jetzt den riesigen
### Ausflug in die WATO-Regeln machen? --> Gilt aber auch bei SNMP.
###
### | 4. Messdaten: Wie sendet man sie? Wie deklariert man sie in CMK korrekt? Grafendefinitionen?
### |
### | 5. Manualpage.
### +-> Hier müssen wir bedenken, dass dies auch für SNMP-basierte Checks gilt.
